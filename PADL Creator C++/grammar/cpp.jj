/**
 * Copyright (C) 1996, 1997 Sun Microsystems Inc.
 *
 * Use of this file and the system it is part of is constrained by the
 * file COPYRIGHT in the root directory of this system.  You may, however,
 * make any modifications you wish to this file.
 *
 * Author: Sreenivasa Viswanadha
 * Date: 3/20/97
 *
 * This file contains a Java grammar and actions that implement a front-end.
 *
 * Derived in part from the following work:
 *
 * PUBLIC DOMAIN PCCTS-BASED C++ GRAMMAR (cplusplus.g, stat.g, expr.g)
 *
 * Authors: Sumana Srinivasan, NeXT Inc.;            sumana_srinivasan@next.com
 *          Terence Parr, Parr Research Corporation; parrt@parr-research.com
 *          Russell Quong, Purdue University;        quong@ecn.purdue.edu
 *
 * VERSION 1.1
 *
 * -----------------------------------------------------------------------------
 *
 * This file has been modified to connect the C++ grammar to the PADL meta-model
 * for the PTIDEJ tool (http://www.yann-gael.gueheneuc.net/Work/Info/).
 *
 * Authors: Sébastien Robidoux, Université de Montréal; robidose@iro.umontreal.ca
 *          Ward Flores, Université de Montréal;        floresvw@iro.umontreal.ca
 *
 * Date: August 2004
 */
options {
  STATIC=true;
}

PARSER_BEGIN(CPPParser)
package padl.creator.parser;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import padl.creator.CppCreator;
import padl.kernel.ICodeLevelModel;
import padl.kernel.IConstructor;
import padl.kernel.ICppFactory;
import padl.kernel.IDestructor;
import padl.kernel.IElement;
import padl.kernel.IField;
import padl.kernel.IEntity;
import padl.kernel.IFirstClassEntity;
import padl.kernel.IPrimitiveEntity;
import padl.kernel.IGhost;
import padl.kernel.IGlobalField;
import padl.kernel.IMethod;
import padl.kernel.IPackage;
import padl.kernel.IParameter;
import padl.kernel.IRelationship;
import padl.kernel.IUseRelationship;
import padl.kernel.exception.ModelDeclarationException;
import util.lang.Modifier;

public final class CPPParser {
  private static String vers = "0.4";
  private static String id = "C++ Parser";

  //------------------------------------------------------------
  /* Field and methods to recognize a global field */
  private static boolean isGlobalField = false;
  private static void setIsGlobalField(final boolean b) {
    CPPParser.isGlobalField = b;
  }
  private static boolean getIsGlobalField() {
    return CPPParser.isGlobalField;
  }
  
  //------------------------------------------------------------
  /* Field and methods to manage the members acces */

  private static int accessFlag = Modifier.PUBLIC;
  private static void setAccess(final int theAccess) { 
    CPPParser.accessFlag = theAccess; 
  }
  private static int getAccess() {
    return CPPParser.accessFlag;
  }

  //------------------------------------------------------------
  /* Field and methods to recognize a member */

  private static boolean isMember = false;
  private static void enableMember(final boolean b) { 
    CPPParser.isMember = b; 
  }
  private static boolean getIsMember() {
    return CPPParser.isMember;
  }

  //------------------------------------------------------------
  /* Field and methods to manage the member type */
     
  private static String typeMember = "";
  private static void setTypeMember(final String unType) {
    CPPParser.typeMember = unType;
  }
  private static String getTypeMember() {
    return CPPParser.typeMember;
  }
  private static void resetTypeMember() {
    CPPParser.typeMember = "";
  }

  //------------------------------------------------------------
  /* Field and methods to manage the global field type */

  private static String typeGlobalField = "";
  private static void setTypeGlobalField(final String unType) {
    CPPParser.typeGlobalField = unType;
  }
  private static String getTypeGlobalField() {
    return CPPParser.typeGlobalField;
  }

  //------------------------------------------------------------
  /* Field and methods to manage the members of a class */
     
  private static List listOfElements = new ArrayList();
  private static List getListOfElements() {
      return CPPParser.listOfElements;
  }
  private static void addToListOfElements(final IElement anElement) {
      CPPParser.listOfElements.add(anElement);
  }
  private static void resetListOfElements() {
      CPPParser.listOfElements.clear();
  }

  //------------------------------------------------------------
  /* Field and methods to manage the super classes of a class */
     
  private static List listOfGeneralizations = new ArrayList();
  private static List getListOfGeneralizations() {
    return CPPParser.listOfGeneralizations;
  }
  private static void addToListOfGeneralizations(final String aName) {
    CPPParser.listOfGeneralizations.add(aName);
  }
  private static void resetListOfGeneralizations() {
    CPPParser.listOfGeneralizations.clear();
  }

  //------------------------------------------------------------
  /* Field and methods to manage the useRelationships of a class */
  
  private static List listOfUseDisplay = new ArrayList();
  private static List getListOfUseDisplay() {
    return CPPParser.listOfUseDisplay;
  }
  private static void addToListOfUseDisplay(final String aName) {
    final Iterator iterator = CPPParser.listOfUseDisplay.iterator();
    while (iterator.hasNext())
      if (aName.equals((String)iterator.next())) return;
      CPPParser.listOfUseDisplay.add(aName);
  }
  private static void resetListOfUseDisplay() {
    CPPParser.listOfUseDisplay.clear();
  }

  //------------------------------------------------------------
  /* Field and methods to recognize a parameter */
     
  private static boolean isParameter = false;
  private static void enableParameter(final boolean b) { 
    CPPParser.isParameter = b; 
  }
  private static boolean getIsParameter() {
    return CPPParser.isParameter;
  }

  //------------------------------------------------------------
  /* Field and methods to manage the parameter type */
  
  private static String typeParameter = "";
  private static void setTypeParameter(final String aType) {
    CPPParser.typeParameter = aType;
  }
  private static String getTypeParameter() {
    return CPPParser.typeParameter;
  }
  private static void resetTypeParameter() {
    CPPParser.typeParameter = "";
  }

  //------------------------------------------------------------
  /* Field and methods to manage the parameters */
  
  private static List listOfArguments = new ArrayList();
  private static List getListOfArguments() {
    return CPPParser.listOfArguments;
  }
  private static void addToListOfArguments(final IParameter aParameter) {
    CPPParser.listOfArguments.add(aParameter);
  }
  private static void resetListOfArguments() {
    CPPParser.listOfArguments.clear();
  }

  //------------------------------------------------------------
  /* Field and methods to manage the display of table suffixes */
  
  private static String suffix = "";
  private static void setSuffix(final String aSuffix) {
    CPPParser.suffix += aSuffix;
  }
  private static String getSuffix() {
    return CPPParser.suffix;
  }
  private static void resetSuffix() {
    CPPParser.suffix = "";
  }
    
  //------------------------------------------------------------
  /* Field and methods to manage the codeLevelModel */
  /* and the default package to contain entities    */
  
    private static ICodeLevelModel codeLevelModel;
    private static int UniqueIdentifier;
    public static ICodeLevelModel getCodeLevelModel() {
        return CPPParser.codeLevelModel;
    }
    public static void setCodeLevelModel(final ICodeLevelModel aCodeLevelModel) {
        CPPParser.codeLevelModel = aCodeLevelModel;
    }
    private static IPackage createAndGetDefaultPackage() {
        IPackage enclosingPackage = (IPackage) CPPParser.getCodeLevelModel().getConstituentFromID(CppCreator.CPP_PACKAGE_ID);
        if (enclosingPackage == null) {
            try {
                enclosingPackage = factory.createPackage(CppCreator.CPP_PACKAGE_ID);
                CPPParser.getCodeLevelModel().addConstituent(enclosingPackage);
            }
            catch(final ModelDeclarationException mde) {
                mde.printStackTrace();
            }
        }
        return enclosingPackage;
    }

  //------------------------------------------------------------
  /* Field and methods to manage the factory */

  private static ICppFactory factory;
  private static ICppFactory getFactory() {
    return CPPParser.factory;
  }
  private static void setFactory(final ICppFactory aFactory) {
    CPPParser.factory = aFactory;
  }
  
    //------------------------------------------------------------
    // 2004/08/19: Sébastien Robidoux
    // This method replace any ghost find with the same name of a new entity
    // This method will fixed any relation create with the ghost
    // This method will fixed any inheritance create with the ghost
    private static void replaceGhost(final IFirstClassEntity anEntity)
        throws ParseException {
        final IFirstClassEntity entity =
            (IFirstClassEntity) CPPParser.createAndGetDefaultPackage().getConstituentFromName(
                anEntity.getName());

        // If we find a ghost...
        if (entity != null && entity instanceof IGhost) {
            final char[] tempId = entity.getID();
            // Remove the Ghost from the model
            CPPParser.createAndGetDefaultPackage().removeConstituentFromID(tempId);

            // Look in each Entity for link with this ghost
            final Iterator tempListEntities =
                CPPParser
                    .createAndGetDefaultPackage()
                    .getIteratorOnConstituents();
            while (tempListEntities.hasNext()) {
                final IFirstClassEntity tempEntity = (IFirstClassEntity) tempListEntities.next();

                // Look in each possible element of the entity
                final Iterator tempListOfElement =
                    tempEntity.getIteratorOnConstituents();
                while (tempListOfElement.hasNext()) {
                    final IElement tempElement =
                        (IElement) tempListOfElement.next();

                    // If we find a relationship
                    if (tempElement instanceof IRelationship) {
                        final IRelationship tempLink =
                            (IRelationship) tempElement;
                        if (Arrays.equals(tempId, tempLink.getTargetEntity().getID())) {
                            tempLink.setTargetEntity(anEntity);
                        }
                    }
                }

                final Iterator tempListOfInherited =
                    tempEntity.getIteratorOnInheritedEntities();
                // Look in each inhereted
                while(tempListOfInherited.hasNext()) {
                    final IFirstClassEntity tempInherited =
                        (IFirstClassEntity) tempListOfInherited.next();
                    // If we find a ghost in the inheritance list...
                    if (tempId.equals(tempInherited.getID())) {
                        tempEntity.removeInheritedEntity(entity);
                        try {
                            tempEntity.addInheritedEntity(anEntity);
                        }
                        catch (ModelDeclarationException e) {
                            msg("Error with the code-level model. |addInheritedActior()|");
                            throw new ParseException();
                        }
                    }
                }
            }
        }
    }

  //------------------------------------------------------------
  private static void msg(String s) {
    System.out.println(id + " Version " + vers +": " + s);
  }
  

  public static ICodeLevelModel parse(String aFileName,
                                      ICodeLevelModel aCodeLevelModel) {
    InputStream input;
    CPPParser.setCodeLevelModel(aCodeLevelModel);
    /* 2004/08/18: Ward Flores */
    CPPParser.setFactory((ICppFactory) CPPParser.getCodeLevelModel().getFactory());
    /* END */
    
    try {
        input = new FileInputStream(aFileName);
    } catch(FileNotFoundException fnfe) {
        return CPPParser.getCodeLevelModel();
    }
    
    try {
      if (jj_initialized_once) {
         ReInit(input);
         sym.depth = 0;
         CPPParser.resetTypeParameter();
         CPPParser.resetListOfArguments();
         CPPParser.resetListOfElements();
         CPPParser.resetListOfGeneralizations();
         CPPParser.resetListOfUseDisplay();
         CPPParser.resetSuffix();
         CPPParser.resetTypeMember();
      } else {
         new CPPParser(input);
      }
      translation_unit();
      msg("File parsed successfully: \"" + aFileName + "\".");
    } catch (ParseException e) {
      msg("Encountered errors during parse in file: \"" + aFileName + "\".");
    } 
    
    return CPPParser.getCodeLevelModel();
  }
  
  public static void main(String args[]) {
    java.io.InputStream input;

    int ai = 0;

    if (ai == (args.length-1)) {
      msg("Reading from file " + args[ai] + " . . .");
      try {
        input = new java.io.FileInputStream(args[ai]);
      } catch (java.io.FileNotFoundException e) {
        msg("File " + args[0] + " not found.");
        return;
      }
    } else if (ai >= args.length) {
      msg("Reading from standard input . . .");
      input = System.in;
    } else {
      msg("Usage: java " + id + " [-d] [inputfile]");
      return;
    }

    try {
      new CPPParser(input);
      translation_unit();
      msg("Program parsed successfully.");
    } catch (ParseException e) {
      msg("Encountered errors during parse.");
    } 
  }

  /**
   * A symbol table manager object. Currently only types are recorded for
   * doing semantic predicates for parsing.
   */
  static SymtabManager sym;

  /*
   * Methods used in semantics predicates.
   */

  /**
   * Reads a fully qualified name (since it is used during lookahead, we
   * cannot use token. We have to explicitly use getToken).
   */
  // Modif Robidoux
  static String GetFullyScopedName() throws RuntimeException //ParseException
  {
     Token t = getToken(1);

     if (t.kind != ID && t.kind != SCOPE)
        return null;

     StringBuffer s = new StringBuffer();

     int i;
     if (t.kind != SCOPE)
     {
        s.append(t.image);
        t = getToken(2);
        i = 3;
     }
     else
        i = 2;

     while (t.kind == SCOPE)
     {
        s.append(t.image);
        s.append((t = getToken(i++)).image);
        t = getToken(i++);
     }

     return s.toString();
  }

  /**
   * This method first tries to read a sequence of tokens of the form
   *             ("::")? <ID> ("::" <ID>)*
   * and if it succeeds then asks the symbol table manager  if this is
   * the name of a constructor.
   */
  // Modif Robidoux
  static boolean IsCtor() throws RuntimeException //ParseException
  {
      return sym.IsCtor(GetFullyScopedName());
  }
}

PARSER_END(CPPParser)

SKIP :
{
  " "
|
  "\t"
|
  "\r\n"
|
  "\n"
|
  "//" : IN_LINE_COMMENT
|
  "/*" : IN_COMMENT
|
  "#" : PREPROCESSOR_OUTPUT
}

<IN_LINE_COMMENT> SKIP:
{
   "\n" : DEFAULT
}

<IN_LINE_COMMENT> MORE:
{
  < ~[] >
}

<IN_COMMENT> SKIP:
{
   "*/" : DEFAULT
}

<IN_COMMENT> MORE:
{
  < ~[] >
}

<PREPROCESSOR_OUTPUT> SKIP:
{
   "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
  < ~[] >
}

TOKEN :
{
  < LCURLYBRACE: "{" >
| < RCURLYBRACE: "}" >
| < LSQUAREBRACKET: "[" >
| < RSQUAREBRACKET: "]" >
| < LPARENTHESIS: "(" >
| < RPARENTHESIS: ")" >
| < SCOPE: "::" >
| < COLON: ":" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < QUESTIONMARK: "?" >
| < ELLIPSIS: "..." >
| < ASSIGNEQUAL: "=" >
| < TIMESEQUAL: "*=" >
| < DIVIDEEQUAL: "/=" >
| < MODEQUAL: "%=" >
| < PLUSEQUAL: "+=" >
| < MINUSEQUAL: "-=" >
| < SHIFTLEFTEQUAL: "<<=" >
| < SHIFTRIGHTEQUAL: ">>=" >
| < BITWISEANDEQUAL: "&=" >
| < BITWISEXOREQUAL: "^=" >
| < BITWISEOREQUAL: "|=" >
| < OR: "||" >
| < AND: "&&" >
| < BITWISEOR: "|" >
| < BITWISEXOR: "^" >
| < AMPERSAND: "&" >
| < EQUAL: "==" >
| < NOTEQUAL: "!=" >
| < LESSTHAN: "<" >
| < GREATERTHAN: ">" >
| < LESSTHANOREQUALTO: "<=" >
| < GREATERTHANOREQUALTO: ">=" >
| < SHIFTLEFT: "<<" >
| < SHIFTRIGHT: ">>" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < DIVIDE: "/" >
| < MOD: "%" >
| < PLUSPLUS: "++" >
| < MINUSMINUS: "--" >
| < TILDE: "~" >
| < NOT: "!" >
| < DOT: "." >
| < POINTERTO: "->" >
| < DOTSTAR: ".*" >
| < ARROWSTAR: "->*" >
| < AUTO: "auto" >
| < BREAK: "break" >
| < CASE: "case" >
| < CATCH: "catch" >
| < CHAR: "char" >
| < CONST: "const" >
| < CONTINUE: "continue" >
| < _DEFAULT: "default" >
| < DELETE: "delete" >
| < DO: "do" >
| < DOUBLE: "double" >
| < ELSE: "else" >
| < ENUM: "enum" >
| < EXTERN: "extern" >
| < FLOAT: "float" >
| < FOR: "for" >
| < FRIEND: "friend" >
| < GOTO: "goto" >
| < IF: "if" >
| < INLINE: "inline" >
| < INT: "int" >
| < LONG: "long" >
| < NEW: "new" >
| < PRIVATE: "private" >
| < PROTECTED: "protected" >
| < PUBLIC: "public" >
| < REDECLARED: "redeclared" >
| < REGISTER: "register" >
| < RETURN: "return" >
| < SHORT: "short" >
| < SIGNED: "signed" >
| < SIZEOF: "sizeof" >
| < STATIC: "static" >
| < STRUCT: "struct" >
| < CLASS : "class" >
| < SWITCH: "switch" >
| < TEMPLATE: "template" >
| < THIS: "this" >
| < TRY: "try" >
| < TYPEDEF: "typedef" >
| < UNION: "union" >
| < UNSIGNED: "unsigned" >
| < VIRTUAL: "virtual" >
| < VOID: "void" >
| < VOLATILE: "volatile" >
| < WHILE: "while" >
| < OPERATOR: "operator" >
| < TRUETOK: "true" >
| < FALSETOK: "false" >
| < THROW: "throw" >
}

TOKEN [IGNORE_CASE] :
{
  <  OCTALINT : "0" (["0"-"7"])* >
| <  OCTALLONG : <OCTALINT> "l" >
| <  UNSIGNED_OCTALINT : <OCTALINT> "u" >
| <  UNSIGNED_OCTALLONG : <OCTALINT> ("ul" | "lu") >

| <  DECIMALINT : ["1"-"9"] (["0"-"9"])* >
| <  DECIMALLONG : <DECIMALINT> ["u","l"] >
| <  UNSIGNED_DECIMALINT : <DECIMALINT> "u" >
| <  UNSIGNED_DECIMALLONG : <DECIMALINT> ("ul" | "lu") >


| <  HEXADECIMALINT : "0x" (["0"-"9","a"-"f"])+ >
| <  HEXADECIMALLONG : <HEXADECIMALINT> (["u","l"])? >
| <  UNSIGNED_HEXADECIMALINT : <HEXADECIMALINT> "u" >
| <  UNSIGNED_HEXADECIMALLONG : <HEXADECIMALINT> ("ul" | "lu") >


| <  FLOATONE : ((["0"-"9"])+ "." (["0"-"9"])* | (["0"-"9"])* "." (["0"-"9"])+)
              ("e" (["-","+"])? (["0"-"9"])+)? (["f","l"])? >

| <  FLOATTWO : (["0"-"9"])+ "e" (["-","+"])?  (["0"-"9"])+ (["f","l"])? >
}

TOKEN :
{

  <  CHARACTER : ("L")? "'"
   (   (~["'","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )
   "'" >

| <  STRING : ("L")? "\""
   ( ( ~["\"","\\","\n","\r"])
   | ("\\" (
             ["n","t","v","b","r","f","a","\\","?","'","\""]
            |
             "0" (["0"-"7"])*
            |
             ["1"-"9"] (["0"-"9"])*
            |
             ("0x" | "0X") (["0"-"9","a"-"f","A"-"F"])+
           )
     )
   )*
   "\"" >
}

void translation_unit() :
{}
{
   { sym.OpenScope(null, false); }
   ( LOOKAHEAD(2) external_declaration() )* <EOF>
   { sym.CloseScope(); }
}

void external_declaration() :
{ boolean isTypedef = false; }
{
    LOOKAHEAD(("typedef" | template_head())? class_head()  "{")
       ( template_head() )? declaration()
   |
    LOOKAHEAD("enum" (<ID>)? "{")
       enum_specifier() (init_declarator_list(false))?  ";"
   |
    LOOKAHEAD ((template_head())? dtor_ctor_decl_spec()
                               dtor_declarator() "{")
       dtor_definition()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
       ctor_definition()

   |
    LOOKAHEAD((declaration_specifiers())?  function_declarator_lookahead())
       function_definition()

   |
    LOOKAHEAD((scope_override())? "operator")
         conversion_function_decl_or_def()
   |
    template_head()
      (
        LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
           ctor_definition()
      |
        LOOKAHEAD((declaration_specifiers())?  function_declarator_lookahead())
           function_definition()
      |
        isTypedef = declaration_specifiers()
               (init_declarator_list(isTypedef))?  ";"
      )
   |
    { /* 2004/08/24: Sébastien Robidoux, Ward Flores */
      CPPParser.setIsGlobalField(true); }
      declaration()
    { CPPParser.setIsGlobalField(false); }
      /* END */
   |
    ";"
}

void function_definition() :
{
   Scope sc = null;
   boolean isTypedef;
}
{

    LOOKAHEAD(3) isTypedef = declaration_specifiers()
        sc = function_declarator(isTypedef) func_decl_def(sc)
   |
    sc = function_declarator(false) func_decl_def(sc)
}

void func_decl_def(Scope sc) :
{
   boolean closeReqd = false;
}
{
  {
     if (closeReqd = (sc != null && sc != sym.GetCurScope()))
        sym.OpenScope(sc);
  }

  (
    ";"
   |
    compound_statement()
  )

  { if (closeReqd) sym.CloseScope(); }
}

void linkage_specification() :
{}
{
   "extern" <STRING>
   (
    "{" ( external_declaration() )* "}"
      ( LOOKAHEAD(";") ";")?
   |
    declaration()
   )
}

void declaration() :
{ boolean isTypedef = false; }
{
    LOOKAHEAD(2)
      isTypedef = declaration_specifiers()
               (init_declarator_list(isTypedef))? ";"
   |
    linkage_specification()
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean type_modifiers() :
{ boolean isTypedef = false; }
{
   (
     isTypedef = storage_class_specifier()
    |
     type_qualifier()
    |
     "inline"
    |
     "virtual"
    |
     "friend"
   )

   { return isTypedef; }
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean declaration_specifiers() :
{
   Token t = getToken(1);
   boolean isTypedef = false, tmp;
}
{
 (
   (
      LOOKAHEAD(type_modifiers()) tmp = type_modifiers() { isTypedef |= tmp; }
   )+

    [ LOOKAHEAD(2) (
     LOOKAHEAD(builtin_type_specifier()) builtin_type_specifier()
         (  LOOKAHEAD(2) (
            LOOKAHEAD(builtin_type_specifier()) builtin_type_specifier()
          |
            LOOKAHEAD(type_modifiers()) tmp = type_modifiers() )
                                        { isTypedef |= tmp; }
         )*
    |
     (
        class_specifier()
      |
        enum_specifier()
      |
        qualified_type()
     )
     (LOOKAHEAD(2) tmp = type_modifiers() { isTypedef |= tmp;} )*
    ) ]
   |
    LOOKAHEAD(builtin_type_specifier()) builtin_type_specifier()
         ( LOOKAHEAD(2) (
            LOOKAHEAD(builtin_type_specifier()) builtin_type_specifier()
          |
            tmp = type_modifiers() { isTypedef |= tmp; } )
         )*

   |
    (
      class_specifier()
     |
      enum_specifier()
     |
      qualified_type()
    )
    (LOOKAHEAD(2) tmp = type_modifiers() { isTypedef |= tmp; } )*
 )

 {      
  /* 2004/07/19: Sébastien Robidoux */
  if (CPPParser.getIsMember()) {
    if (CPPParser.getIsParameter()) {
        CPPParser.setTypeParameter(t.image);
    } else {
        CPPParser.setTypeMember(t.image);
    }
  } else if (CPPParser.getIsGlobalField()) {
    CPPParser.setTypeGlobalField(t.image);
  }
 }
  /* END */ 
  
 { return isTypedef; }
}

/*
void type_specifier() :
{}
{
    simple_type_specifier()
   |
    class_specifier()
   |
    enum_specifier()
}
*/

void simple_type_specifier() :
{}
{
   (
    builtin_type_specifier()
   |
    qualified_type()
   )
}

void scope_override_lookahead() :
{}
{
    "::"
   |
    <ID> ("<" template_argument_list() ">")? "::"
}

String scope_override() :
{
   String name = "";
   Token t;
}
{
  (
    ("::")  { name += "::"; }
    (
      LOOKAHEAD(2) t = <ID> ("<" template_argument_list() ">")? "::"
                   { name += t.image + "::"; }
    )*
   |
    (
      LOOKAHEAD(2) t = <ID> ("<" template_argument_list() ">")? "::"
                   { name += t.image + "::"; }
    )+
  )
  { return name; }
}


String qualified_id() :
{
   String name = "";
   Token t;
   /* 2004/08/03: Sébastien Robidoux */
   String operateur = "";
   /* END */
}
{
    [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]
    (
      t = <ID> 
      [ "<" template_argument_list()  ">" ]
      { return name + t.image; }
     |
      "operator" operateur = optor() { return "operator" + operateur; }
    )
}

void ptr_to_member() :
{}
{
    scope_override()  "*"
}

void qualified_type() :
{
  /* 2004/08/03: Sébastien Robidoux */
  String name = "";
  /* END */
}
{
    LOOKAHEAD({ sym.IsFullyScopedTypeName(GetFullyScopedName()) } )
        name = qualified_id()
    {
      /* 2004/08/03: Sébastien Robidoux */
      CPPParser.addToListOfUseDisplay(name);
      /* END */
    
    }
}

void type_qualifier() :
{}
{
    "const" | "volatile"
}

/**
 * Very temporary. Just returns true if it sees a typedef. Finally, we will
 * need a structure that stores all the attributes.
 */
boolean storage_class_specifier() :
{}
{
   ( "auto" | "register" | "static" | "extern" ) { return false; }
   | "typedef"  { return true; }
}

void builtin_type_specifier() :
{}
{
   "void" | "char" | "short" | "int" | "long" | "float" |
   "double" | "signed" | "unsigned"
}

void init_declarator_list(boolean isTypedef) :
{}
{
   init_declarator(isTypedef) ("," init_declarator(isTypedef))*
}

void init_declarator(boolean isTypedef) :
{ String name; }
{
   name = declarator()
   {
      if (isTypedef)
         sym.PutTypeName(name);
         
        /* 2004/07/19: Sébastien Robidoux */
        /* 2004/08/09: Ward Flores */
        if (CPPParser.getIsGlobalField()) {
            try {
                // Addition of fields
                final IGlobalField gfield =
                    CPPParser.getFactory().createGlobalField(
                        name.toCharArray(),
                        CPPParser.getTypeGlobalField().toCharArray(),
                        1);
                gfield.setVisibility(CPPParser.getAccess());
                CPPParser.createAndGetDefaultPackage().addConstituent(gfield);
            }
            catch (ModelDeclarationException mde) {
                msg("Error with the code-Level model. |createField()|");
                {
                    throw new ParseException();
                }
            }
        }
        /* END */

   }
   (
    "=" initializer()
   |
    "(" expression_list()  ")"
   )?
}

void class_head() :
{}
{
   ("struct" | "union" | "class")
   (<ID> (base_clause(null))?)?
}

void class_specifier()  :
{
   /* 2004/08/10 : Sébastien Robidoux*/
   /* 2004/08/10 : Ward Flores*/

   IFirstClassEntity entity = null;
   CPPParser.setAccess(Modifier.PUBLIC);   
   ClassScope sc = null;
   Token t;
}
{
   (
     {
        // Create a structure (getToken(2) gives the structure name)
        try {
          entity = CPPParser.getFactory().createStructure(getToken(2).image.toCharArray());
          CPPParser.replaceGhost(entity);
        } catch (ModelDeclarationException e) {
          msg("Error with the code-level model. |createStructure()|");
          throw new ParseException();
        }
     }
     "struct"
     |
     {
       // Create an union (getToken(2) gives the union name)
       try {
         entity = CPPParser.getFactory().createUnion(getToken(2).image.toCharArray());
         CPPParser.replaceGhost(entity);
       } catch (ModelDeclarationException e) {
         msg("Error with the code-level model. |createUnion()|");
         throw new ParseException();
       }
     }
     "union"
     |
     {
       // Create a class (getToken(2) gives the class name)
       try {
         entity = CPPParser.getFactory().createClass(getToken(2).image.toCharArray(),getToken(2).image.toCharArray());
         CPPParser.replaceGhost(entity);
       } catch (ModelDeclarationException e) {
         msg("Error with the code-level model. |createClass()|");
         throw new ParseException();
       }
     }
     "class"
   )

{
}
   (
    "{"
        {
           sym.OpenScope(null, false);
        }
        (member_declaration())*
    "}"
    
        {
    /* 2004/07/15 : Sébastien Robidoux*/
    /* 2004/08/03 : Ward Flores*/

    try {
        // Addition of useRelationships
        final Iterator it1 = CPPParser.getListOfUseDisplay().iterator();
        while (it1.hasNext()) {
            String targetName = (String) it1.next();
            IFirstClassEntity targetEntity;
            targetEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage()
                    .getConstituentFromName(
                    targetName);
            // Create a Ghost if no Entity found...
            if (targetEntity == null && !targetName.equals(entity.getName())) {
                // Create a Ghost
                targetEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(targetName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetName.toCharArray());
                CPPParser.createAndGetDefaultPackage().addConstituent(
                    targetEntity);
            }
            if( targetEntity != null ) {
                final IUseRelationship useRelationship =
                    CPPParser.getFactory()
                        .createUseRelationship(
                        	("uR" + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetEntity,
                        	2);
                CPPParser.addToListOfElements(useRelationship);
            }
        }
        CPPParser.resetListOfUseDisplay();

        // Addition of members
        final Iterator it2 = CPPParser.getListOfElements().iterator();
        while (it2.hasNext()) {
            entity.addConstituent((IElement) it2.next());
        }
        CPPParser.resetListOfElements();

        // Addition of classes, structs or unions
        CPPParser.createAndGetDefaultPackage().addConstituent(entity);

        // Addition of super classes
        final Iterator it3 =
            CPPParser.getListOfGeneralizations().iterator();
        while (it3.hasNext()) {
            String superName = (String) it3.next();
            IFirstClassEntity superEntity;
            superEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage().getConstituentFromName(
                    superName);
            //Create un Ghost if the parent isn't in the model...
            if (superEntity == null) {
                // Create a Ghost
                superEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(superName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	superName.toCharArray());
                CPPParser.createAndGetDefaultPackage().addConstituent(
                    superEntity);
            }
            entity.addInheritedEntity(superEntity);
        }
        CPPParser.resetListOfGeneralizations();

    }
    catch (ModelDeclarationException e2) {
        msg("Error with the Code Level Model at step 1");
        {
            e2.printStackTrace();
            if (true) {
                if (true) {
                    if (true)
                        throw new ParseException();
                }
            }
        }
    }
    /*END*/

        }
        {
           sym.CloseScope();
        }
   |
    LOOKAHEAD(2) t = <ID>
     {
        sc = (ClassScope)sym.OpenScope(t.image, true);
     }
     (base_clause(sc))?
    "{"
      (member_declaration())*
    "}"
        {
    /* 2004/07/15 : Sébastien Robidoux*/
    /* 2004/08/03 : Ward Flores*/

    try {
        // Addition of useRelationships
        final Iterator it1 = CPPParser.getListOfUseDisplay().iterator();
        while (it1.hasNext()) {
            String targetName = (String) it1.next();
            IFirstClassEntity targetEntity;
            targetEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage()
                    .getConstituentFromName(
                    targetName);
            // Create a Ghost if no Entity found...
            if (targetEntity == null && !targetName.equals(entity.getName())) {
                // Create a Ghost
                targetEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(targetName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetName.toCharArray());
                CPPParser.createAndGetDefaultPackage().addConstituent(
                    targetEntity);
            }
            if( targetEntity != null ) {
                final IUseRelationship useRelationship =
                    CPPParser.getFactory()
                        .createUseRelationship(
                        	("uR" + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetEntity,
                        	2);
                CPPParser.addToListOfElements(useRelationship);
            }
        }
        CPPParser.resetListOfUseDisplay();

        // Addition of members
        final Iterator it2 = CPPParser.getListOfElements().iterator();
        while (it2.hasNext()) {
            entity.addConstituent((IElement) it2.next());
        }
        CPPParser.resetListOfElements();

        // Addition of classes, structs or unions
        CPPParser.createAndGetDefaultPackage().addConstituent(entity);

        // Addition of super classes
        final Iterator it3 =
            CPPParser.getListOfGeneralizations().iterator();
        while (it3.hasNext()) {
            String superName = (String) it3.next();
            IFirstClassEntity superEntity;
            superEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage().getConstituentFromName(
                    superName);
            //Create un Ghost if the parent isn't in the model...
            if (superEntity == null) {
                // Create a Ghost
                superEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(superName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	superName.toCharArray());
                CPPParser.createAndGetDefaultPackage().addConstituent(
                    superEntity);
            }
            entity.addInheritedEntity(superEntity);
        }
        CPPParser.resetListOfGeneralizations();

    }
    catch (ModelDeclarationException e2) {
        msg("Error with the Code Level Model at step 2");
        {
            e2.printStackTrace();
            if (true) {
                if (true) {
                    if (true)
                        throw new ParseException();
                }
            }
        }
    }
    /*END*/
        }
        {
           sym.CloseScope();
        }
   |
    t=<ID> (LOOKAHEAD(2) "<" template_argument_list()  ">")?
        {
    /* 2004/07/15 : Sébastien Robidoux*/
    /* 2004/08/03 : Ward Flores*/
    try {
        // Addition of useRelationships
        final Iterator it1 =
            CPPParser.getListOfUseDisplay().iterator();
        while (it1.hasNext()) {
            String targetName = (String) it1.next();
            IFirstClassEntity targetEntity;
            targetEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage()
                    .getConstituentFromName(
                    targetName);
            // Create a Ghost if no Entity found...
            if (targetEntity == null && !targetName.equals(entity.getName())) {
                // Create a Ghost
                targetEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(targetName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetName.toCharArray());
                CPPParser.createAndGetDefaultPackage()
                    .addConstituent(
                    targetEntity);
            }
            if( targetEntity != null ) {
                final IUseRelationship useRelationship =
                    CPPParser.getFactory()
                        .createUseRelationship(
                        	("uR" + CPPParser.UniqueIdentifier++).toCharArray(),
                        	targetEntity,
                        	2);
                CPPParser.addToListOfElements(useRelationship);
            }
        }
        CPPParser.resetListOfUseDisplay();
        // Addition of members
        final Iterator it2 =
            CPPParser.getListOfElements().iterator();
        while (it2.hasNext()) {
            entity.addConstituent((IElement) it2.next());
        }
        CPPParser.resetListOfElements();

        // Addition of classes, structs or unions
        CPPParser.createAndGetDefaultPackage().addConstituent(entity);

        // Addition of super classes
        final Iterator it3 =
            CPPParser.getListOfGeneralizations().iterator();
        while (it3.hasNext()) {
            String superName = (String) it3.next();
            IFirstClassEntity superEntity;
            superEntity =
                (IFirstClassEntity) CPPParser.createAndGetDefaultPackage().getConstituentFromName(superName);
            //Create un Ghost if the parent isn't in the model...
            if (superEntity == null) {
                // Create a Ghost
                superEntity =
                    CPPParser.getFactory()
                        .createGhost(
                        	(superName + CPPParser.UniqueIdentifier++).toCharArray(),
                        	superName.toCharArray());
                CPPParser.createAndGetDefaultPackage()
                    .addConstituent(
                    superEntity);
            }
            entity.addInheritedEntity(superEntity);
        }
        CPPParser.resetListOfGeneralizations();

    }
    catch (ModelDeclarationException e2) {
        msg("Error with the Code Level Model at step 3");
        {
            if (true) {
                if (true) {
                    if (true)
                        throw new ParseException();
                }
            }
        }
    }
    /*END*/
        }
    
    { sym.PutTypeName(t.image); }
   )
}

void base_clause(ClassScope scope) :
{}
{
   ":" base_specifier(scope) ( "," base_specifier(scope) )*
}

void base_specifier(ClassScope scope) :
{ Token t;
  /* 2004/07/20: Sébastien Robidoux */
  CPPParser.addToListOfGeneralizations(getToken(2).image);
  /* END */
 }
{
   ("virtual" (access_specifier())? | access_specifier() ("virtual")?)?
   (LOOKAHEAD(scope_override_lookahead()) scope_override())?
   t = <ID> ("<" template_argument_list()  ">")?
   {
      scope.AddSuper(sym.GetScope(t.image));
   }
}

int access_specifier() :
{}
{
   /* 2004/07/19: Sébastien Robidoux */
   "public" {return Modifier.PUBLIC;}
   | 
   "protected" {return Modifier.PROTECTED;} 
   | 
   "private" {return Modifier.PRIVATE;}
   /* END */
}

void member_declaration() :
{ boolean isTypedef = false; 
  int tmp;
  /* 2004/07/19: Sébastien Robidoux */
  /* 2004/08/03: Ward Flores */
  // Member recognized
  CPPParser.enableMember(true);
  CPPParser.resetListOfArguments();
  CPPParser.resetSuffix();
}
{
 (
    LOOKAHEAD(("typedef")? class_head() "{") declaration()

   |
    LOOKAHEAD("enum" (<ID>)? "{") enum_specifier()
       ( member_declarator_list(false) )?  ";"
   |
    LOOKAHEAD( "operator" )
       conversion_function_decl_or_def()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() dtor_declarator() "{")
       dtor_definition()
   |
    LOOKAHEAD(("inline"| "virtual")* "~")
       dtor_ctor_decl_spec() simple_dtor_declarator()  ";"
   |
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead())
       ctor_definition()
   |
    LOOKAHEAD(dtor_ctor_decl_spec() ctor_declarator_lookahead() ";")
      (dtor_ctor_decl_spec() ctor_declarator() ";")
   |
    LOOKAHEAD((declaration_specifiers())? function_declarator_lookahead())
       function_definition()
   |
    LOOKAHEAD(declaration_specifiers())
       isTypedef = declaration_specifiers()
           (member_declarator_list(isTypedef))? ";"
   |
    LOOKAHEAD(<ID>) function_declarator(false) ";"
   |
    LOOKAHEAD(3)
     qualified_id() ";"
   |
    tmp = access_specifier() ":"
    { // Point out the access of the next member 
      CPPParser.setAccess(tmp);
    }
   |
    ";"   
 )    
   { // Member end
     CPPParser.enableMember(false); } 
}

void member_declarator_list(boolean isTypedef) :
{}
{
   member_declarator(isTypedef) ("=" <OCTALINT>)?
   ("," member_declarator(isTypedef) ("=" <OCTALINT>)?)*
}

void member_declarator(boolean isTypedef) :
{ String name; }
{
   name = declarator()
   {
      if (isTypedef)
         sym.PutTypeName(name);
   }
  { /* 2004/07/19: Sébastien Robidoux */
    /* 2004/08/09: Ward Flores */
    if( CPPParser.getIsMember() ) {
      try {
        // Addition of fields
        final IField field = CPPParser.getFactory().createField(
                        name.toCharArray(),
                        name.toCharArray(),
                        (CPPParser.getTypeMember()).toCharArray(),
                        1);
        field.setVisibility(CPPParser.getAccess());
        CPPParser.addToListOfElements(field);
      } catch (ModelDeclarationException mde) {
        msg("Error with the code-level model. |createField()|");
        throw new ParseException();
      }
    }
    /* END */
  }
}

void conversion_function_decl_or_def() :
{
   Scope sc = null;
   String name = null;
}
{
   [ LOOKAHEAD(scope_override_lookahead()) name = scope_override() ]

   "operator" declaration_specifiers() ("*" | "&")?

   "(" (parameter_list())? ")"
   (LOOKAHEAD(2) type_qualifier())?
   (exception_spec())?
   func_decl_def(null)  // Temporary (fix the null)
}

void enum_specifier() :
{ Token t; }
{
   "enum"
   (
    "{" enumerator_list() "}"
   |
    t=<ID>
      {
        /* 2004/08/19: Ward Flores */
        // Create an enum
        try {                   
          IFirstClassEntity entity = CPPParser.getFactory().createEnum(t.image.toCharArray());
          CPPParser.replaceGhost(entity);
          // Add the enum to the default package
          CPPParser.createAndGetDefaultPackage().addConstituent(entity);
        } catch (ModelDeclarationException e) {
          msg("Error with the code-level model. |createEnum()|");
          throw new ParseException();
        }
        /* END */
      }
    (LOOKAHEAD(2) "{" enumerator_list() "}")?
    { sym.PutTypeName(t.image); }
   )
}

void enumerator_list() :
{}
{
   enumerator() ("," enumerator())*
}

void enumerator() :
{}
{
   <ID> ("=" constant_expression())?
}

void ptr_operator() :
{}
{
    "&" cv_qualifier_seq()
   |
    "*" cv_qualifier_seq()
   |
    ptr_to_member() cv_qualifier_seq()
}

void cv_qualifier_seq() :
{}
{
   [ LOOKAHEAD(2) (
     "const" [ LOOKAHEAD(2) "volatile" ]
    |
     "volatile" [ LOOKAHEAD(2) "const" ] )
   ]
}

String declarator() :
{ String name; }
{
  (
    LOOKAHEAD(ptr_operator())
      ptr_operator() name = declarator()
      { 
            /* 2004/07/19: Sébastien Robidoux */
            if (CPPParser.getIsMember()) {
                if (CPPParser.getIsParameter()) {
                    CPPParser.setTypeParameter(CPPParser.getTypeParameter() + " *");
                }
                else {
                    CPPParser.setTypeMember(CPPParser.getTypeMember() + " *");
                }
            } else if (CPPParser.getIsGlobalField()) {
                CPPParser.setTypeGlobalField(CPPParser.getTypeGlobalField() + "*");
            }
            /* END */
      }
   |
    name = direct_declarator()
  )

  { return name; }
}

String direct_declarator() :
{
   String name;
   Token t;
}
{
   /* 2004/08/02: Ward Flores
    * Addition of suffixes "[]" for the table fields */
      
   LOOKAHEAD(2)
    "~" t = <ID> (LOOKAHEAD(2) declarator_suffixes())?
        {return "~" + t.image; }
   |
    "(" name = declarator() ")" (LOOKAHEAD(2) declarator_suffixes())?
        { return name; }
   |
    name = qualified_id() (LOOKAHEAD(2) declarator_suffixes() { name += CPPParser.getSuffix(); } )?
        { return name; }
}

void declarator_suffixes() :
{}
{
   /* 2004/08/02: Ward Flores
    * Recursive addition of suffixes "[]" */
    
    ("[" { CPPParser.setSuffix("[]"); } (constant_expression())? "]" )+
   |
    "(" (parameter_list())? ")"
    (LOOKAHEAD(2) type_qualifier())?
    (exception_spec())?
}

/**
 * Used only for lookahead.
 */
void function_declarator_lookahead() :
{}
{
   (LOOKAHEAD(2) ptr_operator() )* qualified_id() "("
}

Scope function_declarator(boolean isTypedef) :
{ Scope sc = null; }
{
  (
    LOOKAHEAD(ptr_operator())
      { /* 2004/07/19: Sébastien Robidoux */
        if( CPPParser.getIsMember() ) { CPPParser.setTypeMember( CPPParser.getTypeMember() + " *" ); }
        /* END */
      }
      ptr_operator() sc = function_declarator(isTypedef)
   |
     sc = function_direct_declarator(isTypedef)
  )

  { return sc; }
}

Scope function_direct_declarator(boolean isTypedef) :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;
}
{
     name = qualified_id()

     {
        sc = sym.GetScopeOfFullyScopedName(name);

        if (closeReqd = (sc != null && sc != sym.GetCurScope()))
           sym.OpenScope(sc);
     }

     "(" (parameter_list())?  ")"
     (LOOKAHEAD(2) type_qualifier())?
     (exception_spec())?
     (LOOKAHEAD("=") "=" <OCTALINT>)?

     {
        if (closeReqd)
           sym.CloseScope();

        if (isTypedef)
           sym.PutTypeName(name);

       { 
         /* 2004/07/20 - Ward Flores */
         if (CPPParser.getIsMember()) {
           try {
           // Addition of methods
           final IMethod method = CPPParser.getFactory()
                            .createMethod(
                            	(name + CPPParser.UniqueIdentifier++).toCharArray(),
           						name.toCharArray());
           method.setReturnType(CPPParser.getTypeMember().toCharArray());
           method.setVisibility(CPPParser.getAccess());
           
           // Addition of parameters
           final Iterator iterator = CPPParser.getListOfArguments().iterator();
           while (iterator.hasNext()) {            
              method.addConstituent((IParameter) iterator.next());               
           }
           CPPParser.resetListOfArguments();
           
           CPPParser.addToListOfElements(method);
           } catch (ModelDeclarationException mde) {
           msg("Error with the code-level model. |createMethod()|");
           throw new ParseException();
           }
         }
       } 
       return sc;
    }    
}

void dtor_ctor_decl_spec() :
{}
{
   [
    "virtual" [ "inline"]
   |
    "inline"  [ "virtual"]
   ]
}

void dtor_definition() :
{}
{
   (template_head())?
   dtor_ctor_decl_spec()
   dtor_declarator()
   compound_statement()
}

void ctor_definition() :
{
   Scope sc = null;
   boolean closeReqd = false;
}
{
   dtor_ctor_decl_spec() sc = ctor_declarator()

   {
      if (closeReqd = (sc != null && sc != sym.GetCurScope()))
         sym.OpenScope(sc);
   }

   (exception_spec())?

   (
     ";"
    |
     [ ctor_initializer() ] compound_statement()
   )

   { if (closeReqd) sym.CloseScope(); }
}

void ctor_declarator_lookahead() :
{}
{
   LOOKAHEAD( { IsCtor() } ) qualified_id() "("
}

Scope ctor_declarator() :
{
  String name;
  Scope sc = null;
  boolean closeReqd = false;
}
{
   LOOKAHEAD( { IsCtor() } )
      name = qualified_id()

     {
        sc = sym.GetScopeOfFullyScopedName(name);

        if (closeReqd = (sc != null && sc != sym.GetCurScope()))
           sym.OpenScope(sc);
     }

     "(" [ LOOKAHEAD(2) parameter_list() ]  ")"

     [ LOOKAHEAD(2) exception_spec() ]

     {
        if (closeReqd)
           sym.CloseScope();

       { /* Modification 2004/07/27 : Sébastien Robidoux */
           if (CPPParser.getIsMember()) {
           
           try {
             // Addition of constructors
             final IConstructor constr = CPPParser.getFactory()
                            .createConstructor(
                            	(name + CPPParser.UniqueIdentifier++).toCharArray(),
                            	name.toCharArray());
             constr.setVisibility(CPPParser.getAccess());
           
             // Addition of parameters
             final Iterator iterator = CPPParser.getListOfArguments().iterator();
             while (iterator.hasNext()) {              
                constr.addConstituent((IParameter) iterator.next());             
             }
             CPPParser.resetListOfArguments();
           
             CPPParser.addToListOfElements(constr);
           } catch (ModelDeclarationException mde) {
             msg("Error with the code-level model. |createConstructor()|");
             mde.printStackTrace();
             throw new ParseException();
           }
         }
       } 


        return sc;
     }
}

void ctor_initializer() :
{}
{
   ":" superclass_init() ("," superclass_init())*
}

void superclass_init() :
{}
{
   qualified_id()  "(" (expression_list())?  ")"
}

void dtor_declarator() :
{}
{
   (LOOKAHEAD(scope_override_lookahead()) scope_override())?
    simple_dtor_declarator()
}

void simple_dtor_declarator() :
{
  /* 2004/08/03: Sébastien Robidoux */
  String name = "~" + getToken(2).image;
  /* END */
}
{
   "~"
   LOOKAHEAD( { IsCtor() } ) <ID> "(" (parameter_list())?  ")"
   {
     /* 2004/08/03: Sébastien Robidoux */
     if (CPPParser.getIsMember()) {
       try {
         // Addition of destructors
         final IDestructor destr = CPPParser.getFactory().createDestructor(
         	(name + CPPParser.UniqueIdentifier++).toCharArray(),
         	name.toCharArray());
         destr.setVisibility(CPPParser.getAccess());

         // Addition of parameters
         final Iterator iterator = CPPParser.getListOfArguments().iterator();
         while (iterator.hasNext()) {
           destr.addConstituent((IParameter) iterator.next());
         }
         CPPParser.resetListOfArguments();

         CPPParser.addToListOfElements(destr);
       } catch (ModelDeclarationException mde) {
         msg("Error with the code-level model. |createDestructor()|");
         throw new ParseException();
       }
     }
     
     /* END */
   }
}

void parameter_list() :
{ /* 2004/07/27: Sébastien Robidoux */
  CPPParser.enableParameter(CPPParser.getIsMember());
  /* END */}
{
  (
    parameter_declaration_list() [ LOOKAHEAD(2) [ "," ] "..." ]
   |
    "..."
  )
  { /* 2004/07/27: Sébastien Robidoux */
    CPPParser.enableParameter(false);
    /* END */} 
}

void parameter_declaration_list() :
{}
{
   parameter_declaration() (LOOKAHEAD(2) "," parameter_declaration())*
}

void parameter_declaration() :
{ String name = " "; }
{
   declaration_specifiers()
   (
    LOOKAHEAD(declarator()) name = declarator()
   |
    abstract_declarator()
   )
   ("=" assignment_expression())?
   { /* 2004/07/27: Sébastien Robidoux */
     if (CPPParser.getIsMember()) {
			try {
				// Addition of parameters
				IEntity targetEntity;
				String typeName = CPPParser.getTypeParameter();
				if (typeName.indexOf(' ') > -1) {
					// For pointers...
					typeName = typeName.substring(0, typeName.indexOf(' '));
				}
				targetEntity =
					(IFirstClassEntity) CPPParser
						.createAndGetDefaultPackage()
						.getConstituentFromName(typeName);
				if (targetEntity == null) {
					// I assume that it is a primitive type, else it is a ghost...
					try {
						targetEntity =
							(IPrimitiveEntity) CPPParser
								.getFactory()
								.createPrimitiveEntity(typeName.toCharArray());
					}
					catch (final ModelDeclarationException mde) {
						targetEntity =
							(IFirstClassEntity) CPPParser
								.getFactory()
								.createGhost(
									typeName.toCharArray(),
									typeName.toCharArray());
					}
				}
				final IParameter param =
					CPPParser.getFactory().createParameter(
						targetEntity,
						CPPParser.getTypeParameter().toCharArray(),
						1);
				CPPParser.addToListOfArguments(param);
			}
			catch (final ModelDeclarationException mde) {
				msg("Error with the code-level model. |createParameter()|");
				msg(mde.toString());
				throw new ParseException();
			}
     }
     
     /* END */}
}

void initializer() :
{}
{
    LOOKAHEAD(3)
     "{" initializer() ("," initializer())* "}"
   |
    assignment_expression()
}

void type_name() :
{}
{
   declaration_specifiers() abstract_declarator()
}

void abstract_declarator() :
{}
{
   [ LOOKAHEAD(2) (
    "(" abstract_declarator()   ")"
    (abstract_declarator_suffix())+
   |
    ("[" (constant_expression())? "]")+
   |
    ptr_operator() abstract_declarator() 
      { /* 2004/07/19: Sébastien Robidoux */
        if( CPPParser.getIsMember() ) { 
          if( CPPParser.getIsParameter() ) {
            CPPParser.setTypeParameter( CPPParser.getTypeParameter() + " *" );  
          } else {
            CPPParser.setTypeMember( CPPParser.getTypeMember() + " *" ); 
          }
        }
        /* END */
      }
    )
   ]
}

void abstract_declarator_suffix() :
{}
{
    "[" ( constant_expression() )?  "]"
   |
    "(" (parameter_list())? ")"
}

void template_head() :
{}
{
   "template" "<" template_parameter_list() ">"
}

void template_parameter_list() :
{}
{
   template_parameter() ("," template_parameter())*
}

void template_parameter() :
{ Token t; }
{
    LOOKAHEAD(3)
      "class" t=<ID> { sym.PutTypeName(t.image); }
   |
    parameter_declaration()
}

void template_id() :
{}
{
   <ID> "<" template_argument_list() ">"
}

void template_argument_list() :
{}
{
   template_argument() ("," template_argument())*
}

void template_argument() :
{}
{
    LOOKAHEAD(3)
      type_name()
   |
    shift_expression()
}

void statement_list() :
{}
{
   (LOOKAHEAD(statement()) statement())+
}

void statement() :
{}
{
    LOOKAHEAD( declaration() )
      declaration()
   |
    LOOKAHEAD( expression() ";" )
      expression() ";"
   |
    compound_statement()
   |
    selection_statement()
   |
    jump_statement()
   |
    ";"
   |
    try_block()
   |
    throw_statement()
   |
    LOOKAHEAD(2)
      labeled_statement()
   |
    iteration_statement()
}

void labeled_statement() :
{}
{
    <ID> ":" statement()
   |
    "case" constant_expression()  ":" statement()
   |
    "default"  ":" statement()
}

void compound_statement() :
{}
{
   "{"

   { sym.OpenScope(null, false); }

   (statement_list())?

   { sym.CloseScope(); }

   "}"
}

void selection_statement() :
{}
{
    "if" "(" expression() ")" statement()
     (LOOKAHEAD(2) "else" statement())?
   |
    "switch" "(" expression() ")" statement()
}

void iteration_statement() :
{}
{
    "while" "(" expression() ")" statement()
   |
    "do" statement() "while" "(" expression() ")" ";"
   |
    "for" "(" (LOOKAHEAD(3) declaration() | expression() ";" | ";")
    (expression())? ";" (expression())? ")" statement()
}

void jump_statement() :
{}
{
    "goto" <ID> ";"
   |
    "continue" ";"
   |
    "break" ";"
   |
    "return" (expression())? ";"
}

void try_block() :
{}
{
   "try" compound_statement() (handler())*
}

void handler() :
{}
{
   "catch" "(" exception_declaration() ")"
   compound_statement()
 |
   "finally" compound_statement()
}

void exception_declaration() :
{}
{    parameter_declaration_list()
   |
     "..."
}

void throw_statement() :
{}
{    "throw" (assignment_expression())? ";"
}

void expression() :
{}
{
   assignment_expression() ( LOOKAHEAD(2) "," assignment_expression())*
}

void assignment_expression() :
{}
{
    conditional_expression()
    (("="
   | "*="
   | "/="
   | "%="
   | "+="
   | "-="
   | "<<="
   | ">>="
   | "&="
   | "^="
   | "|="
   )
   assignment_expression()
   )?
}

void conditional_expression() :
{}
{   logical_or_expression()
   ("?" conditional_expression()  ":" conditional_expression())?
}

void constant_expression() :
{}
{    conditional_expression()
}

void logical_or_expression() :
{}
{    logical_and_expression() ( "||" logical_and_expression())*
}

void logical_and_expression() :
{}
{    inclusive_or_expression() ( "&&" inclusive_or_expression())*
}

void inclusive_or_expression() :
{}
{    exclusive_or_expression()( "|" exclusive_or_expression())*
}

void exclusive_or_expression() :
{}
{    and_expression()( "^" and_expression())*
}

void and_expression() :
{}
{    equality_expression()( LOOKAHEAD(2) "&" equality_expression())*
}

void equality_expression() :
{}
{    relational_expression()(( "!=" | "==") relational_expression())*
}

void relational_expression() :
{}
{  shift_expression()
   (
     LOOKAHEAD(2)
     (
         "<"
       | ">"
       | "<="
       | ">="
     )
     shift_expression()
   )*
}

void shift_expression() :
{}
{    additive_expression()(( "<<" | ">>") additive_expression())*
}

void additive_expression() :
{}
{    multiplicative_expression()
   (LOOKAHEAD(2) ( "+" | "-") multiplicative_expression())*
}

void multiplicative_expression() :
{}
{  pm_expression()
   (LOOKAHEAD(2) ( "*" | "/" | "%") pm_expression())*
}

void pm_expression() :
{}
{
    cast_expression() (( ".*" | "->*" ) cast_expression())*
}

void cast_expression() :
{}
{
    LOOKAHEAD( "(" type_name() ")" )
     "(" type_name() ")" cast_expression()
   |
     unary_expression()
}

void unary_expression() :
{}
{
     "++" unary_expression()
   |
     "--" unary_expression()
   |
     LOOKAHEAD(3)
     unary_operator() cast_expression()
   |
     "sizeof"
     (
       LOOKAHEAD("(")
       "(" type_name()  ")"
     |
       unary_expression()
     )
   |
     postfix_expression()
}

void new_expression() :
{}
{
   (LOOKAHEAD("::") ("::"))?
   "new"
   (
     LOOKAHEAD("(" type_name() ")" )
      "(" type_name() ")"
    |
     (LOOKAHEAD("(" expression_list() ) "(" expression_list() ")")?
     (
       LOOKAHEAD("(" type_name() ")" )
       "(" type_name() ")"
      |
       LOOKAHEAD(declaration_specifiers())
        new_type_id()
     )
   )
   (LOOKAHEAD(new_initializer()) new_initializer())?
}

void new_type_id() :
{}
{
   declaration_specifiers()
   ( LOOKAHEAD(new_declarator()) new_declarator() )?
}

void new_declarator() :
{}
{
     direct_new_declarator()
   |
     ptr_operator() cv_qualifier_seq()  [ LOOKAHEAD(2) new_declarator() ]
}

void direct_new_declarator() :
{}
{
   (LOOKAHEAD(2) "[" expression() "]" )+
}

void new_initializer() :
{}
{    "(" ( expression_list() )? ")"
}

void delete_expression() :
{}
{    ( "::" )? "delete" ( "[" "]" )? cast_expression()
}

void unary_operator() :
{}
{    "&"
   | "*"
   | "+"
   | "-"
   | "~"
   | "!"
}

void postfix_expression() :
{}
{
   LOOKAHEAD(3)
    primary_expression()
    ( LOOKAHEAD(2) (
     "[" expression() "]"
    |
     "(" ( expression_list() )? ")"
    |
     "." id_expression()
    |
     "->" id_expression()
    |
     "++"
    |
     "--" )
    )*
  |
   simple_type_specifier() "(" ( expression_list() )? ")"
}

void id_expression() :
{}
{
   (LOOKAHEAD(scope_override_lookahead()) scope_override())?
   (     <ID>
   | "operator" optor()
   | "~"  <ID>
   )
}

void primary_expression() :
{}
{
     "this"
   | ( LOOKAHEAD(2) <STRING> )+
   | "(" expression()  ")"
   |
     LOOKAHEAD( ("::")? "new")
     new_expression()
   |
     LOOKAHEAD( ("::")? "delete")
     delete_expression()
   | id_expression()
   | constant()
}

void expression_list() :
{}
{    assignment_expression()( "," assignment_expression())*
}

void constant() :
{}
{    <OCTALINT>
   | <OCTALLONG>
   | <DECIMALINT>
   | <DECIMALLONG>
   | <HEXADECIMALINT>
   | <HEXADECIMALLONG>

   | <UNSIGNED_OCTALINT>
   | <UNSIGNED_OCTALLONG>
   | <UNSIGNED_DECIMALINT>
   | <UNSIGNED_DECIMALLONG>
   | <UNSIGNED_HEXADECIMALINT>
   | <UNSIGNED_HEXADECIMALLONG>

   | <CHARACTER>
   | <FLOATONE>
   | <FLOATTWO>
   | "true"
   | "false"
}

/* 2004/08/03: Sébastien Robidoux */
/* Modif void to String           */

String optor() :
{ 
  /* 2004/07/03: Sébastien Robidoux */
  String operateur = "";
}
{
   (
     "new" [ LOOKAHEAD(2) "[" "]" ]
   | "delete" [ LOOKAHEAD(2) "[" "]" ]
   | "+" { operateur = "+"; }
   | "-" { operateur = "-"; }
   | "*" { operateur = "*"; }
   | "/" { operateur = "/"; }
   | "%" { operateur = "%"; }
   | "^" { operateur = "^"; }
   | "&" { operateur = "&"; }
   | "|" { operateur = "|"; }
   | "~" { operateur = "~"; }
   | "!" { operateur = "!"; }
   | "=" { operateur = "="; }
   | "<" { operateur = "<"; }
   | ">" { operateur = ">"; }
   | "+=" { operateur = "+="; }
   | "-=" { operateur = "-="; }
   | "*=" { operateur = "*="; }
   | "/=" { operateur = "/="; }
   | "%=" { operateur = "%="; }
   | "^=" { operateur = "^="; }
   | "&=" { operateur = "&="; }
   | "|=" { operateur = "|="; }
   | "<<" { operateur = "<<"; }
   | ">>" { operateur = ">>"; }
   | ">>=" { operateur = ">>="; }
   | "<<=" { operateur = "<<="; }
   | "==" { operateur = "=="; }
   | "!=" { operateur = "!="; }
   | "<=" { operateur = "<="; }
   | ">=" { operateur = ">="; }
   | "&&" { operateur = "&&"; }
   | "||" { operateur = "||"; }
   | "++" { operateur = "++"; }
   | "--" { operateur = "--"; }
   | "," { operateur = ","; }
   | "->*" { operateur = "->*"; }
   | "->" { operateur = "->"; }
   | "(" ")" 
   | "[" "]" 
   | declaration_specifiers() (LOOKAHEAD(2) ("*"|"&"))?
   )
   { return operateur; }
}

void exception_spec() :
{}
{
   "throw" "(" exception_list() ")"
}

void exception_list() :
{}
{
   type_name() ( "," type_name())*
}

TOKEN :
{
  <  ID : ["a"-"z","A"-"Z", "_"] (["a"-"z","A"-"Z","0"-"9","_"])* >
}


/*end*/

