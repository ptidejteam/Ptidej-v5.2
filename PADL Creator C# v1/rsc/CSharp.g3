/**
 * This C# grammar is as close to the standard as possible. Most changes involve
 * the resolution of left recursion (direct and indirect).
 *
 * The tree produced contains all tokens (except whitespace, comments, preprocessor directives).
 * The tree structure is very close to the concrete syntax tree.
 *
 * Due to lexical ambiguities ( >> can be a rightshift of 2 closing angle brackets after a
 * nested type parameter) the 'lexical parser approach' as proposed on the ANTLR mailing
 * list has been used. By doubling the lexical rules in the parser, context can be used to
 * disambiguate. Whitespace and comment handling is also done in the parser part (rule
 * ignoredtail). Consider the whole construct a hack.
 
 * During the parsing nodes of named entities have their name assigned. Helper attributes
 * have been defined where necessary (e.g. name, signature, content). 
 * The content attribute has originally only been the predefined text attribute. However, 
 * after changing to the lexing parser approach this did not work anymore, because the 
 * text attribute does now not only contain the token text but also the text of the 
 * following ignoredtail. This is a hack introduced because of the lexing parser hack.
 *
 * Known issues:
 * - Casts and parenthesized expressions are ambiguous, 
 *   i.e. the following cases cannot be distinguished syntactically
 *   - (a)-x   :  cast of -x to a or the subtraction a - x
 *   In such a case the parser will prefer the cast     
 *   
 * - DelegateCreationExpressions have been removed from the grammar because they
 *   cannot be syntactically distinguished from an ObjectCreationExpression.
 * -----------------------------------------------------------------------------
 *
 * This file has been modified to connect the C# grammar to the PADL meta-model
 * for the PTIDEJ tool (http://www.yann-gael.gueheneuc.net/Work/Info/).
 *
 * Author: Gerardo Cepeda Porras, Universit� de Montr�al; gerardocepeda@gmail.com
 *
 * Date: April 2009
 */

grammar CSharp;
options {
	output=AST;
	k=*;
	backtrack=true;
}

tokens {

	CompilationUnit;
	UsingDirectives;
	ExternAliasDirectives;
	UsingAliasDirective;
	UsingNamespaceDirective;
	NamespaceMemberDeclarations;
	NamespaceMemberDeclaration;
	NamespaceDeclaration;
	NamespaceName;
	TypeName;
	SimpleType;
	QualifiedAliasMember;
	TypeDeclaration;
	ClassMemberDeclaration;
	StructMemberDeclaration;
	InterfaceMemberDeclaration;
	EnumMemberDeclaration;

	ArgumentList;
	Argument;

	Constant;
	Field;
    Method;
    Class;
    Struct;
    Interface;
    Enum;
    Delegate;
    Indexer;
    Event;
    Operator;
    Constructor;
    Finalizer;
    Property;
    StaticConstructor;

	ConstantDeclarators;
	ConstantDeclarator;
	VariableDeclarators;
	VariableDeclarator;
    GetAccessor;
    SetAccessor;
    AddAccessor;
    RemoveAccessor;
    AccessorDeclarations;
    UnaryOperatorDeclarator;
    UnaryOperator;
    BinaryOperatorDeclarator;
    BinaryOperator;
    ConversionOperatorDeclarator;
    BaseInitializer;
    ThisInitializer;

    ClassBase;
    Body;



    Modifiers;
    TypeParameterConstraintsClauses;
    TypeParameterConstraintsClause;
    TypeParameterList;
    TypeParameter;

    Type;
    NullableType;
    ArrayType;
    ExpressionList;
    RankSpecifiers;
    ArrayInitializer;
    Statement;
    StatementList;


	//expressions
	MemberAccess;
	Literal;
	SimpleName;
	ParenthesizedExpression;
	ThisAccess;
	BaseAccess;
	ObjectCreationExpression;
	TypeOfExpression;
	UnboundTypeName;
	GenericDimensionSpecifier;
	CheckedExpression;
	UncheckedExpression;
	DefaultValueExpression;
	AnonymousMethodExpression;
	InvocationExpression;
	ElementAccess;
	PostIncrementExpression;
	PostDecrementExpression;
	ArrayCreationExpression;

    InterfaceMethod;
    InterfaceProperty;
    InterfaceEvent;
    InterfaceIndexer;


	MulTExpression;
	DivExpression;
	ModExpression;
	AddExpression;
	SubExpression;
	LeftShiftExpression;
	RightShiftExpression;
	LessExpression;
	GreaterExpression;
	LessEqualExpression;
	GreaterEqualExpression;
	IsExpression;
	AsExpression;
	EqualsExpression;
	NotEqualsExpression;
	BitwiseAndExpression;
	BitwiseXorExpression;
	BitwiseOrExpression;
	AndExpression;
	OrExpression;
	NullCoalescingExpression;
	ConditionalExpression;
	Assignment;
	ConstantExpression;
	BooleanExpression;

	Block;
	ExpressionStatement;
	EmptyStatement;
	LabeledStatement;
	DeclarationStatement;
	LocalVariableDeclaration;
	LocalConstantDeclaration;
	IfStatement;
	IfSection;
	ElseSection;
	SwitchStatement;
	SwitchSection;
	SwitchLabel;
	WhileStatement;
	DoStatement;
	ForStatement;
	ForInitializer;
	ForCondition;
	ForIterator;
	ForEachStatement;
	BreakStatement;
	ContinueStatement;
	GotoStatement;
	ReturnStatement;
	ThrowStatement;
	TryStatement;
	TryBlock;
	CatchClause;
	FinallyClause;
	CheckedStatement;
	UncheckedStatement;
	LockStatement;
	UsingStatement;
	YieldStatement;


	ParameterList;
	Parameter;
	ParameterArray;

	TypeArgumentList;
	QualifiedIdentifier;

	GlobalAttributes;
	GlobalAttributeSection;
	GlobalAttributeTargetSpecifier;

	Attributes;
	AttributeSection;
	AttributeTargetSpecifier;
	Attribute;
	AttributeArguments;
	NamedArgument;

	TypeParameterConstraints;
	PrimaryConstraint;
	SecondaryConstraints;
	ConstructorConstraint;

	Identifier;
	
	RIGHTSHIFTASSIGN;
	RIGHTSHIFT;
	GE;

}


@parser::header {
//package com.comarch.depth.csharp.parser.antlr;
package padl.creator.parser;

import padl.creator.*;
import padl.kernel.IConstructor;
import padl.creator.CSharpCreator;
import padl.kernel.ICSharpFactory;
//import padl.kernel.IDestructor;
import padl.kernel.IElement;
import padl.kernel.IInterface;
import padl.kernel.IConstituentOfOperation;
import padl.kernel.IEntity;
import padl.kernel.IField;
import padl.kernel.IGhost;
//import padl.kernel.IGlobalField;
import padl.kernel.ICodeLevelModel;
import padl.kernel.IClass;
import padl.kernel.IMethod;
import padl.kernel.IParameter;
import padl.kernel.IPackage;
import padl.kernel.IRelationship;
import padl.kernel.IUseRelationship;
import padl.kernel.exception.ModelDeclarationException;
import util.lang.Modifier;
import java.util.Iterator;
import util.io.Output;
}

@lexer::header {
//package com.comarch.depth.csharp.parser.antlr;
package padl.creator.parser;
}

@members {
	private static ICodeLevelModel codeLevelModel;
    	public ICSharpFactory factory;
    	private IClass entity;
    	private IMethod mamethod;
    	private IInterface myinterface;
    	private IField myField;
    	public int Classmodifier;
    	public int Fieldmodifier;
    	public int MethodModifier;
    	public Object MethodReturn;
        public char [] Methordreturns;
        public IField element1;
        public IMethod  element;
        public Object internalInterface;
        public IParameter param;
        public int InterfaceModifier;
        public boolean methodstock=false;
    	private Map<Object, String> tokenNameMap = new HashMap<Object, String>();
    	public ArrayList <IElement> classStockBody = new ArrayList<IElement>();
    	public ArrayList <IConstituentOfOperation> MethodStockBody = new ArrayList<IConstituentOfOperation>();
        public int ElementclassNumber=0;
        public int ElementMethodNumber=0;

	public ICSharpFactory getFactory() {
		return this.factory;
	}
	public void setFactory(final ICSharpFactory aFactory) {
		this.factory = aFactory;
	}
	public static ICodeLevelModel getCodeLevelModel() {
		return codeLevelModel;
	}
	public ICodeLevelModel setCodeLevelModel(final ICodeLevelModel acodeLevelModel) {
		  return this.codeLevelModel = acodeLevelModel;
	}
   	private void msg(final String s) {
   		System.out.println(s);
   	}
}



keyword
    :    aBSTRACT | aS | bASE | bOOL | bREAK | bYTE | cASE | cATCH | cHAR  | cHECKED | cLASS | cONST
    |    cONTINUE | dECIMAL | dEFAULT | dELEGATE | dO | dOUBLE | eLSE | eNUM | eVENT | eXPLICIT | eXTERN
    |    fALSE | fINALLY | fIXED | fLOAT | fOR | fOREACH | gOTO | iF | iMPLICIT | iN | iNT | iNTERFACE
    |    iNTERNAL | iS | lOCK | lONG | nAMESPACE | nEW | nULL | oBJECT | oPERATOR | oUT | oVERRIDE
    |    pARAMS | pRIVATE | pROTECTED |  pUBLIC | rEADONLY | rEF | rETURN | sBYTE | sEALED | sHORT
    |    sIZEOF | sTACKALLOC | sTATIC | sTRING | sTRUCT | sWITCH | tHIS | tHROW | tRUE | tRY | tYPEOF
    |    uINT | uLONG | uNCHECKED | uNSAFE | uSHORT | uSING | vIRTUAL | vOID | vOLATILE | wHILE
    ;


identifier returns [String content]
	:	ident {$content = $ident.start.getText();}
	->	Identifier[$ident.start]
	|	aDD {$content = "add";}
	->	Identifier[$aDD.start]
	| 	aLIAS {$content = "alias";}
	->	Identifier[$aLIAS.start]
	| 	gET {$content = "get";}
	->	Identifier[$gET.start]
	| 	pARTIAL {$content = "partial";}
	->	Identifier[$pARTIAL.start]
	| 	rEMOVE {$content = "remove";}
	->	Identifier[$rEMOVE.start]
	| 	sET {$content = "set";}
	->	Identifier[$sET.start]
	| 	wHERE {$content = "where";}
	->	Identifier[$wHERE.start]
	| 	yIELD {$content = "yield";}
	->	Identifier[$yIELD.start]
	;


//A.2 Syntactic grammar

//A.2.1 Basic concepts
compilationunit
@before
{
	codeLevelModel = Factory.getInstance().createCodeLevelModel("C#".toCharArray());
	maclass= Factory.getInstance().createClass(toCharArray());
	mamethod=Factory.getInstance().createMethod(toCharArray());
	myinterface=Factory.getInstance().createInterface(toCharArray());
	myField=Factory.getInstance().createField(toCharArray(), toCharArray(), int);
}
    :   ignoredtail? externaliasdirectives? usingdirectives? globalattributes? namespacememberdeclarations? EOF
    -> ^(CompilationUnit externaliasdirectives? usingdirectives? globalattributes? namespacememberdeclarations?)
    ;


namespacename
    :   namespaceortypename
    ->	^(NamespaceName namespaceortypename)
    ;

typename returns [String name]
    :   namespaceortypename
    	{$name = $namespaceortypename.name;}
    ->	^(TypeName namespaceortypename)
    ;

//left recursion removed
//was originally:
//	:	Identifier typeargumentlist?
//  |	qualifiedaliasmember
//	|	namespaceortypename dOT identifier typeargumentlist?
namespaceortypename returns [String name]
@init {
	StringBuilder sb = new StringBuilder();
}
	:	(simplenamespaceortypename dOT {sb.append($simplenamespaceortypename.name).append('.');})+
		identifier typeargumentlist? {sb.append($identifier.content); $name = sb.toString();}
	|	simplenamespaceortypename {$name = $simplenamespaceortypename.name;}//$name = ref labels
	;

//added for namespaceortypename recursion removal
simplenamespaceortypename returns [String name]
	:	identifier typeargumentlist?
		{$name = $identifier.content;}
	|	qualifiedaliasmember
		{$name = $qualifiedaliasmember.name;}
	;


//A.2.2 Types
type returns [String name]
    :   referencetype					//referencetype must be tried first because it contains arraytype
    	{$name = $referencetype.name;}  //otherwise some "normal" type would be matched, leaving out the array brackets
    -> ^(Type referencetype)
    |	valuetype
    	{$name = $valuetype.name;}
    -> ^(Type valuetype)
    |   typeparameter
    	{$name = $typeparameter.name;}
    -> ^(Type typeparameter)
    ;

valuetype returns [String name]
    :   structtype
    	{$name = $structtype.name;}
    |   enumtype
    	{$name = $enumtype.name;}
    ;

structtype returns [String name]
    :   nullabletype					//try to match nullabletype first, becuase typename or simpletype
    	{$name = $nullabletype.name;}	//will also match a nullable type, but leave the '?' out
    |	typename
    	{$name = $typename.name;}
    |   simpletype
    	{$name = $simpletype.name;}
    ;

simpletype returns [String name]
    :   numerictype
    	{$name = $numerictype.content;}
    ->	^(SimpleType numerictype)
    |   bOOL
    	{$name = "bool";}
    ->	^(SimpleType bOOL)
    ;

numerictype returns [String content]
    :   integralType {$content = $integralType.start.getText();}
    |   floatingpointtype {$content = $floatingpointtype.start.getText();}
    |   dECIMAL {$content = "decimal";}
    ;

integralType
    :   sBYTE
    |   bYTE
    |   sHORT
    |   uSHORT
    |   iNT
    |   uINT
    |   lONG
    |   uLONG
    |   cHAR
    ;

floatingpointtype
    :   fLOAT
    |   dOUBLE
    ;

enumtype returns [String name]
    :   typename
    	{$name = $typename.name;}
    ;

nullabletype returns [String name]
    :   nonnullablevaluetype qUESTION
    	{$name = $nonnullablevaluetype.name + '?';}
    ->	^(NullableType nonnullablevaluetype qUESTION)
    ;

nonnullablevaluetype returns [String name]
    :   enumtype
    	{$name = $enumtype.name;}
    |	typename
    	{$name = $typename.name;}
    |   simpletype
    	{$name = $simpletype.name;}
    ;

referencetype returns [String name]
    :   arraytype							//arraytype must be matched first, otherwise an array type
    	{$name = $arraytype.signature;}		//is parsed as a class type
    |	classtype
    	{$name = $classtype.name;}
    |   interfacetype
    	{$name = $interfacetype.name;}
    |   delegatetype
    	{$name = $delegatetype.name;}
    ;

classtype returns [String name]
    :   typename
    	{$name = $typename.name;}
    |   oBJECT
    	{$name = "object";}
    |   sTRING
    	{$name = "string";}
    ;

interfacetype returns [String name]
    :   typename
    	{$name = $typename.name;}
    ;

delegatetype returns [String name]
    :   typename
    	{$name = $typename.name;}
    ;

//A.2.3 Variables
variablereference
    :   expression
    ;


//A.2.4 Expressions
argumentlist //removed left recursion
    :   argument (cOMMA argument)*
    ->	^(ArgumentList argument (cOMMA argument)*)
    ;

argument
    :	expression
    ->	^(Argument expression)
    |   rEF variablereference
    ->	^(Argument rEF variablereference)
    |   oUT variablereference
    ->	^(Argument oUT variablereference)
    ;




///////////////////////////////////////////////////////////////////
//
// The following is a set of expression rules containing recursion
// Rules that differ from the original specification are marked
//
///////////////////////////////////////////////////////////////////

/**
 * primaryexpression and primarynoarraycreationexpression have been
 * merged. The idea behind rule primarynoarraycreationexpression is
 * to forbid an elementaccess after an  arraycreationexpression. (e.g. new int[3][1] )
 *
 * However, an expression such as new String[] {"s"}[0] is being executued
 * in Visual Studio, though it violates the official grammar. Therefore
 * this grammar has also been relaxed by removing
 * primarynoarraycreationexpression.
 *
 * An alTernative would have been to introduce a rule
 * arraycreationexpression_withinitializer, for which elementaccess
 * is allowed.
 */
primaryexpression options {memoize=true;}
	:	primarynoarraycreationexpression
	|	arraycreationexpression_withoutinitializer
	;


primary_nonrec
	:	arraycreationexpression_withoutinitializer
	|	primarynoarray_nonrec
	;

primarynoarraycreationexpression
	:	memberaccess_rec_rest
	|	invocationexpression
	|	elementaccess
	|	postincrementexpression
	|	postdecrementexpression
	|	primarynoarray_nonrec
	;


/**
 * Shortcut rule, contains all primaryexpressions that do not have
 * a recursive reference to primaryexpression.
 */
primarynoarray_nonrec
	: 	arraycreationexpression_withinitializer
	|	literal
	|	simplename
	|	parenthesizedexpression
	|	memberaccess_nonrec
	|	thisaccess
	|	baseaccess
	|	objectcreationexpression
//	|	delegatecreationexpression		cannot be distinguished from objectcreationexpression
	|	typeofexpression
	|	checkedexpression
	|	uncheckedexpression
	|	defaultvalueexpression
	|	anonymousmethodexpression
	;

/**
 * The non-recursive right hand sides of rule memberaccess
 */
memberaccess_nonrec
	:	predefinedtype dOT identifier typeargumentlist?
	->	^(MemberAccess predefinedtype dOT identifier typeargumentlist?)
	|	qualifiedaliasmember dOT identifier typeargumentlist?
	->	^(MemberAccess qualifiedaliasmember dOT identifier typeargumentlist?)
	;

memberaccess_rec_rest
	//edited alTernative, originally recursive: primaryexpression dOT Identifier typeargumentlist?
	:	(primary_nonrec -> primary_nonrec)
		(
			(
				invocation_rest -> ^(InvocationExpression $memberaccess_rec_rest invocation_rest)
			|	postdecrement_rest -> ^(PostDecrementExpression $memberaccess_rec_rest postdecrement_rest)
			|	elementaccess_rest -> ^(ElementAccess $memberaccess_rec_rest elementaccess_rest)
			|	postincrement_rest -> ^(PostIncrementExpression $memberaccess_rec_rest postincrement_rest)
			)*
			memberaccess_rest -> ^(MemberAccess $memberaccess_rec_rest memberaccess_rest)
		)+
	;


memberaccess_rest
	:	dOT identifier typeargumentlist?
	;

elementaccess
	:	(primarynoarray_nonrec -> primarynoarray_nonrec)
		(
			(
				invocation_rest -> ^(InvocationExpression $elementaccess invocation_rest)
			|	postdecrement_rest -> ^(PostDecrementExpression $elementaccess postdecrement_rest)
			|	memberaccess_rest -> ^(MemberAccess $elementaccess memberaccess_rest)
			|	postincrement_rest -> ^(PostIncrementExpression $elementaccess postincrement_rest)
			)*
			elementaccess_rest -> ^(ElementAccess $elementaccess elementaccess_rest)
		)+
	;


elementaccess_rest
	:	lBRACKET expressionlist rBRACKET
	;

/**
 * Left recursion removed. The original rule was
 * invocationexpression : primaryexpression lPAREN argumentlist? rPAREN ;
 *
 * Works in conjunction with the other 4 recursive rules
 * postincrementexpression, postdecrementexpression, memberaccess, elementaccess
 */
invocationexpression
	//rule without tree construction is:
	//invocationexpression :  nonrec (( inc_rest | dec_rest | member_rest | element_rest)* invocation_rest)+ ;
	:	(primary_nonrec -> primary_nonrec)
		(
			(
				postincrement_rest -> ^(PostIncrementExpression $invocationexpression postincrement_rest)
			|	postdecrement_rest -> ^(PostDecrementExpression $invocationexpression postdecrement_rest)
			|	memberaccess_rest -> ^(MemberAccess $invocationexpression memberaccess_rest)
			|	elementaccess_rest -> ^(ElementAccess $invocationexpression elementaccess_rest)
			)*
			invocation_rest -> ^(InvocationExpression $invocationexpression invocation_rest)
		)+
	;


invocation_rest
	: 	lPAREN argumentlist? rPAREN
	;

/**
 * Left recursion removed. The original rule was
 * postincrementexpression : primaryexpression increment ;
 *
 * Works in conjunction with the other 4 recursive rules
 * postincrementexpression, postdecrementexpression, memberaccess, elementaccess
 */
postincrementexpression
	//rule without tree construction is:
	//invocationexpression :  nonrec (( invocation_rest | dec_rest | member_rest | element_rest)* inc_rest)+ ;
	:	(primary_nonrec -> primary_nonrec)
		(
			(
				invocation_rest -> ^(InvocationExpression $postincrementexpression invocation_rest)
			|	postdecrement_rest -> ^(PostDecrementExpression $postincrementexpression postdecrement_rest)
			|	memberaccess_rest -> ^(MemberAccess $postincrementexpression memberaccess_rest)
			|	elementaccess_rest -> ^(ElementAccess $postincrementexpression elementaccess_rest)
			)*
			postincrement_rest -> ^(PostIncrementExpression $postincrementexpression postincrement_rest)
		)+
	;


postincrement_rest
	:	iNCREMENT
	;

postdecrementexpression
	:	(primary_nonrec -> primary_nonrec)
		(
			(
				invocation_rest -> ^(InvocationExpression $postdecrementexpression invocation_rest)
			|	postincrement_rest -> ^(PostIncrementExpression $postdecrementexpression postincrement_rest)
			|	memberaccess_rest -> ^(MemberAccess $postdecrementexpression memberaccess_rest)
			|	elementaccess_rest -> ^(ElementAccess $postdecrementexpression elementaccess_rest)
			)*
			postdecrement_rest -> ^(PostDecrementExpression $postdecrementexpression postdecrement_rest)
		)+
	;

postdecrement_rest
	:	dECREMENT
	;


simplename
    :   identifier typeargumentlist?
    -> 	^(SimpleName identifier typeargumentlist?)
    ;

parenthesizedexpression
    :   lPAREN expression rPAREN
    ->	^(ParenthesizedExpression lPAREN expression rPAREN)
    ;



predefinedtype
    :    bOOL | bYTE | cHAR | dECIMAL | dOUBLE | fLOAT | iNT | lONG
    |    oBJECT | sBYTE | sHORT | sTRING | uINT | uLONG | uSHORT
    ;



expressionlist    //removed left recursion
    :   expression (cOMMA expression)*
    ->	^(ExpressionList expression (cOMMA expression)*)
    ;

thisaccess
    :   tHIS
    ->	^(ThisAccess tHIS)
    ;

baseaccess
    :   bASE dOT identifier typeargumentlist?
    ->	^(BaseAccess bASE dOT identifier typeargumentlist?)
    |   bASE lBRACKET expressionlist rBRACKET
    ->	^(BaseAccess bASE lBRACKET expressionlist rBRACKET)
    ;


objectcreationexpression
    :   nEW type lPAREN argumentlist? rPAREN
    ->	^(ObjectCreationExpression nEW type lPAREN argumentlist? rPAREN)
    ;



arraycreationexpression
	:	arraycreationexpression_withinitializer
	|	arraycreationexpression_withoutinitializer
	;


arraycreationexpression_withinitializer
	//statements such as new a(new b(new c())) resulT in lot of repeated execution of this rule during
	//the synpred evaluation. using memoize avoids expensive reparsing
    :   nEW nonarraytype lBRACKET expressionlist rBRACKET rankspecifiers? arrayinitializer
    ->	^(ArrayCreationExpression nEW nonarraytype lBRACKET expressionlist rBRACKET rankspecifiers? arrayinitializer)
    //specification uses arraytype instead of nonarraytype rankspecifiers
    //while both are syntactically equivalent, I don't want to use arraytype here, because that would introduce an
    //AST-node ArrayType (see rule arraytype). The other array creation expressions cannot have such an
    //ArrayType node, which seems somehow inconsistent
    |	nEW nonarraytype rankspecifiers arrayinitializer
    ->	^(ArrayCreationExpression nEW nonarraytype rankspecifiers arrayinitializer)
    ;

arraycreationexpression_withoutinitializer
    :	nEW nonarraytype lBRACKET expressionlist rBRACKET rankspecifiers?
    ->	^(ArrayCreationExpression nEW nonarraytype lBRACKET expressionlist rBRACKET rankspecifiers?)
    ;

/**
 * A delegatecreationexpression cannot be syntactically distinguished from an objectcreationexpression.
 * As we do no type inferencing here, there is no way this rule can ever be matched.
 */
//delegatecreationexpression
//    :   nEW delegatetype lPAREN expression rPAREN
///    ;

typeofexpression
    :   tYPEOF lPAREN type rPAREN
    ->	^(TypeOfExpression tYPEOF lPAREN type rPAREN)
    |   tYPEOF lPAREN unboundtypename rPAREN
    ->	^(TypeOfExpression tYPEOF lPAREN unboundtypename rPAREN)
    |   tYPEOF lPAREN vOID rPAREN
    ->	^(TypeOfExpression tYPEOF lPAREN vOID rPAREN)
    ;

unboundtypename    //removed left recursion
    :   identifier genericdimensionspecifier?  (dOT identifier genericdimensionspecifier?)*
    ->	^(UnboundTypeName identifier genericdimensionspecifier?  (dOT identifier genericdimensionspecifier?)*)
    | 	identifier dOUBLECOLON identifier genericdimensionspecifier? (dOT identifier genericdimensionspecifier?)*
    ->	^(UnboundTypeName identifier dOUBLECOLON identifier genericdimensionspecifier? (dOT identifier genericdimensionspecifier?)*)
    ;

genericdimensionspecifier
    :   lT commas? gT
    ->	^(GenericDimensionSpecifier lT commas? gT)
    ;

commas //removed left recursion
    :   (cOMMA) (cOMMA)*     ;

checkedexpression
    :   cHECKED lPAREN expression rPAREN
    ->	^(CheckedExpression cHECKED lPAREN expression rPAREN)
    ;

uncheckedexpression
    :   uNCHECKED lPAREN expression rPAREN
    ->	^(UncheckedExpression uNCHECKED lPAREN expression rPAREN)
    ;

defaultvalueexpression
    :   dEFAULT lPAREN type rPAREN
    ->	^(DefaultValueExpression dEFAULT lPAREN type rPAREN)
    ;

anonymousmethodexpression
    :   dELEGATE anonymousmethodsignature? block
    ->	^(AnonymousMethodExpression dELEGATE anonymousmethodsignature? block)
    ;

anonymousmethodsignature
    :   lPAREN anonymousmethodparameterlist? rPAREN
    ;

anonymousmethodparameterlist //removed left recursion
    :   (anonymousmethodparameter) (cOMMA anonymousmethodparameter)*
    ;

anonymousmethodparameter
    :   parametermodifier? type identifier
	->	^(Parameter parametermodifier? type identifier)
    ;

unaryexpression options {memoize=true;}
    :   castexpression		//try to match castexpression before primaryexpression, because primaryexpression
    |	primaryexpression	//does also match a cast expression, but leaves some tokens unmatched
    |   pLUS unaryexpression
    |   mINUS unaryexpression
    |   eXCLAM unaryexpression
    |   tILDE unaryexpression
    |   preincrementexpression
    |   predecrementexpression
    ;

preincrementexpression
    :   iNCREMENT unaryexpression
    ;

predecrementexpression
    :   dECREMENT unaryexpression
    ;

castexpression
    :   lPAREN type rPAREN unaryexpression
    ;


mulTiplicativeexpression //removed left recursion
    :   (unaryexpression -> unaryexpression)
    	(
    		mUL unaryexpression	-> ^(MulTExpression $mulTiplicativeexpression mUL unaryexpression)
    	| 	dIV unaryexpression	-> ^(DivExpression $mulTiplicativeexpression dIV unaryexpression)
    	| 	mOD unaryexpression	-> ^(ModExpression $mulTiplicativeexpression mOD unaryexpression)
    	)*
    ;

additiveexpression //removed left recursion
    :   (mulTiplicativeexpression ->	mulTiplicativeexpression)
    	(
    		pLUS mulTiplicativeexpression 	-> ^(AddExpression $additiveexpression pLUS mulTiplicativeexpression)
    	|	mINUS mulTiplicativeexpression  -> ^(SubExpression $additiveexpression mINUS mulTiplicativeexpression)
    	)*
    ;

shiftexpression //removed left recursion
    :   (additiveexpression -> additiveexpression)
    	(
    		lEFTSHIFT additiveexpression 	-> ^(LeftShiftExpression $shiftexpression lEFTSHIFT additiveexpression)
    	| 	rIGHTSHIFT additiveexpression	-> ^(RightShiftExpression $shiftexpression rIGHTSHIFT additiveexpression)
    	)*
    ;
    
relationalexpression //removed left recursion
    :   (shiftexpression -> shiftexpression)
        (
        	lT shiftexpression 	-> ^(LessExpression $relationalexpression lT shiftexpression)
        | 	gT shiftexpression 	-> ^(GreaterExpression $relationalexpression gT shiftexpression)
        | 	lE shiftexpression 	-> ^(LessEqualExpression $relationalexpression lE shiftexpression)
        | 	gE shiftexpression 	-> ^(GreaterEqualExpression $relationalexpression gE shiftexpression)
        | 	iS type 			-> ^(IsExpression $relationalexpression iS shiftexpression)
        | 	aS type				-> ^(AsExpression $relationalexpression aS shiftexpression)
        )*
    ;

equalityexpression //removed left recursion
    :   (relationalexpression -> relationalexpression)
    	(
    		eQUALS relationalexpression 	-> ^(EqualsExpression $equalityexpression eQUALS relationalexpression)
    	| 	nOTEQUALS relationalexpression	-> ^(NotEqualsExpression $equalityexpression nOTEQUALS relationalexpression)
    	)*
    ;

andexpression //removed left recursion
    :   (equalityexpression -> equalityexpression)
    	(aMPERSAND equalityexpression 	-> ^(BitwiseAndExpression $andexpression aMPERSAND equalityexpression)
    	)*
    ;

exclusiveorexpression //removed left recursion
    :   (andexpression -> andexpression)
    	(bITWISEXOR andexpression	-> ^(BitwiseXorExpression $exclusiveorexpression bITWISEXOR andexpression)
    	)*
    ;

inclusiveorexpression //removed left recursion
    :   (exclusiveorexpression -> exclusiveorexpression)
    	(bITWISEOR exclusiveorexpression	-> ^(BitwiseOrExpression $inclusiveorexpression bITWISEOR exclusiveorexpression)
    	)*
    ;

conditionalandexpression //removed left recursion
	:	(inclusiveorexpression -> inclusiveorexpression)
		(lOGICALAND inclusiveorexpression	-> ^(AndExpression $conditionalandexpression lOGICALAND inclusiveorexpression)
		)*
    ;

conditionalorexpression //removed left recursion
    :   (conditionalandexpression -> conditionalandexpression)
    	(lOGICALOR conditionalandexpression	-> ^(OrExpression $conditionalorexpression lOGICALOR conditionalandexpression)
    	)*
    ;

nullcoalescingexpression
    :   (conditionalorexpression -> conditionalorexpression)
    	//build only tree if this optional clause is entered
    	(dOUBLEQUESTION nullcoalescingexpression
   	    ->	^(NullCoalescingExpression conditionalorexpression dOUBLEQUESTION nullcoalescingexpression)
    	)?

    ;

conditionalexpression
    :   (nullcoalescingexpression -> nullcoalescingexpression)
        //build only tree if this optional clause is entered
    	(qUESTION expression cOLON expression
    	->	^(ConditionalExpression nullcoalescingexpression qUESTION expression cOLON expression)
    	)?
    ;

assignment
    :   unaryexpression assignmentoperator expression
    ->	^(Assignment unaryexpression assignmentoperator expression)
    ;


assignmentoperator
    :    aSSIGN | aDDASSIGN | sUBASSIGN | mULASSIGN | dIVASSIGN | mODASSIGN
    |    bITWISEANDASSIGN | bITWISEORASSIGN | bITWISEXORASSIGN | lEFTSHIFTASSIGN
    |    rIGHTSHIFTASSIGN
    ;
    

expression options {memoize=true;}
//expressions can be nested a lot, memoize them to avoid
//mulTiple parsing due to synpred evaluation
    :   assignment	//assignment must stand above conditionalexpression
    				//because otherwise something in like ((i = 0) > 1)
    				//the i would be matched as a conditionalexpression
    |   conditionalexpression
    ;

constantexpression
    :   expression
    ->	^(ConstantExpression expression)
    ;

booleanexpression
    :   expression
    ->	^(BooleanExpression expression)
    ;


//A.2.5 Statements
statement
    :   labeledstatement
    -> ^(Statement labeledstatement)
    |   declarationstatement
    -> ^(Statement declarationstatement)
    |   embeddedstatement
    -> ^(Statement embeddedstatement)
    ;

embeddedstatement
    :   block
    |   emptystatement
    |   expressionstatement
    |   selectionstatement
    |   iterationstatement
    |   jumpstatement
    |   trystatement
    |   checkedstatement
    |   uncheckedstatement
    |   lockstatement
    |   usingstatement
    |   yieldstatement
    ;

block
    :   lBRACE statementlist? rBRACE
    -> 	^(Block lBRACE statementlist? rBRACE)
    ;

statementlist //removed left recursion
    :   statement+
    ->	^(StatementList statement+)
    ;

emptystatement
    :   sEMICOLON
    ->	^(EmptyStatement sEMICOLON)
    ;

labeledstatement
    :   identifier cOLON statement
    ->	^(LabeledStatement identifier cOLON statement)
    ;

declarationstatement
    :   localvariabledeclaration sEMICOLON
    ->	^(DeclarationStatement localvariabledeclaration sEMICOLON)
    |   localconstantdeclaration sEMICOLON
    ->	^(DeclarationStatement localconstantdeclaration sEMICOLON)
    ;

localvariabledeclaration
    :   type localvariabledeclarators
    ->	^(LocalVariableDeclaration type localvariabledeclarators)
    ;

localvariabledeclarators //removed left recursion
    :   localvariabledeclarator (cOMMA localvariabledeclarator)*
    ;

localvariabledeclarator
    :   identifier (aSSIGN localvariableinitializer)?
    ;


localvariableinitializer
    :   expression
    |   arrayinitializer
    ;

localconstantdeclaration
    :   cONST type constantdeclarators
    ->	^(LocalConstantDeclaration cONST type constantdeclarators)
    ;


expressionstatement
    :   statementexpression sEMICOLON
    ->	^(ExpressionStatement statementexpression sEMICOLON)
    ;

statementexpression
    : 	invocationexpression  //invocationexpression must come before objectcreationexpression
    						  //or else something like new A().a() will not be recognized
	|   objectcreationexpression
    |   assignment
    |   postincrementexpression
    |   postdecrementexpression
    |   preincrementexpression
    |   predecrementexpression
    ;

selectionstatement
    :   ifstatement
    |   switchstatement
    ;

ifstatement
    :   iF lPAREN booleanexpression rPAREN embeddedstatement eLSE embeddedstatement
    ->	^(IfStatement iF lPAREN booleanexpression rPAREN ^(IfSection embeddedstatement) eLSE ^(ElseSection embeddedstatement))
    |   iF lPAREN booleanexpression rPAREN embeddedstatement
    ->	^(IfStatement iF lPAREN booleanexpression rPAREN ^(IfSection embeddedstatement))
    ;

switchstatement
    :   sWITCH lPAREN expression rPAREN switchblock
    ->	^(SwitchStatement sWITCH lPAREN expression rPAREN switchblock)
    ;

switchblock
    :   lBRACE switchsections? rBRACE
    ->	^(Block lBRACE switchsections? rBRACE)
    ;

switchsections //removed left recursion
    :   switchsection+
    ;

switchsection
    :   switchlabels statementlist
    ->	^(SwitchSection switchlabels statementlist)
    ;

switchlabels //removed left recursion
    :   switchlabel+
    ;

switchlabel
    :   cASE constantexpression cOLON
    ->	^(SwitchLabel cASE constantexpression cOLON)
    |   dEFAULT cOLON
    ->	^(SwitchLabel dEFAULT cOLON)
    ;

iterationstatement
    :   whilestatement
    |   dostatement
    |   forstatement
    |   foreachstatement
    ;

whilestatement
    :   wHILE lPAREN booleanexpression rPAREN embeddedstatement
    ->	^(WhileStatement wHILE lPAREN booleanexpression rPAREN embeddedstatement)
    ;



dostatement
    :   dO embeddedstatement wHILE lPAREN booleanexpression rPAREN sEMICOLON
    ->	^(DoStatement dO embeddedstatement wHILE lPAREN booleanexpression rPAREN sEMICOLON)
    ;

forstatement
    :   fOR lPAREN forinitializer? sEMICOLON forcondition? sEMICOLON foriterator? rPAREN embeddedstatement
    ->	^(ForStatement fOR lPAREN forinitializer? sEMICOLON forcondition? sEMICOLON foriterator? rPAREN embeddedstatement)
    ;

forinitializer
    :   localvariabledeclaration
    ->	^(ForInitializer localvariabledeclaration)
    |   statementexpressionlist
    ->	^(ForInitializer statementexpressionlist)
    ;

forcondition
    :   booleanexpression
    ->	^(ForCondition booleanexpression)
    ;

foriterator
    :   statementexpressionlist
    ->	^(ForIterator statementexpressionlist)
    ;

statementexpressionlist
    :   statementexpression (cOMMA statementexpression)*
    ;

foreachstatement
    :   fOREACH lPAREN type identifier iN expression rPAREN embeddedstatement
    ->	^(ForEachStatement fOREACH lPAREN type identifier iN expression rPAREN embeddedstatement)
    ;

jumpstatement
    :   breakstatement
    |   continuestatement
    |   gotostatement
    |   returnstatement
    |   throwstatement
    ;

breakstatement
    :   bREAK sEMICOLON
    ->	^(BreakStatement bREAK sEMICOLON)
    ;

continuestatement
    :   cONTINUE sEMICOLON
    ->	^(ContinueStatement cONTINUE sEMICOLON)
    ;

gotostatement
    :   gOTO identifier sEMICOLON
    ->	^(GotoStatement gOTO identifier sEMICOLON)
    |   gOTO cASE constantexpression sEMICOLON
    ->	^(GotoStatement gOTO cASE constantexpression sEMICOLON)
    |   gOTO dEFAULT sEMICOLON
    ->	^(GotoStatement gOTO dEFAULT sEMICOLON)
    ;

returnstatement
    :   rETURN expression? sEMICOLON
    ->	^(ReturnStatement rETURN expression? sEMICOLON)
    ;

throwstatement
    :   tHROW expression? sEMICOLON
    ->	^(ThrowStatement tHROW expression? sEMICOLON)
    ;

trystatement
    :   tRY block catchclauses? finallyclause
    ->	^(TryStatement ^(TryBlock tRY block) catchclauses? finallyclause)
    |   tRY block catchclauses
    ->	^(TryStatement ^(TryBlock tRY block) catchclauses)
    ;

catchclauses
    :   specificcatchclauses? generalcatchclause
    |   specificcatchclauses
    ;

specificcatchclauses //removed left recursion
    :   specificcatchclause+
    ;

specificcatchclause
    :   cATCH lPAREN classtype identifier? rPAREN block
    ->	^(CatchClause cATCH lPAREN classtype identifier? rPAREN block)
    ;

generalcatchclause
    :   cATCH block
    ->	^(CatchClause cATCH block)
    ;


finallyclause
    :   fINALLY block
    ->	^(FinallyClause fINALLY block)
    ;

checkedstatement
    :   cHECKED block
    ->	^(CheckedStatement cHECKED block)
    ;

uncheckedstatement
    :   uNCHECKED block
    ->	^(UncheckedStatement uNCHECKED block)
    ;

lockstatement
    :   lOCK lPAREN expression rPAREN embeddedstatement
    ->	^(LockStatement lOCK lPAREN expression rPAREN embeddedstatement)
    ;

usingstatement
    :   uSING lPAREN resourceacquisition rPAREN embeddedstatement
    ->	^(UsingStatement uSING lPAREN resourceacquisition rPAREN embeddedstatement)
    ;

resourceacquisition
    :   localvariabledeclaration
    |   expression
    ;

yieldstatement
    :   yIELD rETURN expression sEMICOLON
    ->	^(YieldStatement yIELD rETURN expression sEMICOLON)
    |   yIELD bREAK sEMICOLON
    ->	^(YieldStatement yIELD bREAK sEMICOLON)
    ;

namespacedeclaration returns [String name]
@after {
	tokenNameMap.put($namespacedeclaration.tree, $name);
}
    :   (nAMESPACE) =>
    	nAMESPACE qualifiedIdentifier namespacebody sEMICOLON?
    	{$name = $qualifiedIdentifier.name;}
    ->	^(NamespaceDeclaration nAMESPACE qualifiedIdentifier namespacebody sEMICOLON?)
    ;


qualifiedIdentifier returns [String name] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}		//iteratively build complete name from single Identifiers
    :   i1=identifier {sb.append($i1.content);}
    	(dOT i2=identifier	{sb.append('.').append($i2.content);})*
    	//rule matched, name computed, store it in attribute name
    	{$name = sb.toString();}
    ->	^(QualifiedIdentifier identifier (dOT identifier)*)
    ;

namespacebody
    :   lBRACE externaliasdirectives? usingdirectives? namespacememberdeclarations? rBRACE
    ->	^(Body lBRACE externaliasdirectives? usingdirectives? namespacememberdeclarations? rBRACE)
    ;

externaliasdirectives //left recursion removed
    :   externaliasdirective+
    ->	^(ExternAliasDirectives externaliasdirective+)
    ;

externaliasdirective
    :   eXTERN aLIAS identifier sEMICOLON
    ;

usingdirectives //left recursion removed
    :   usingdirective+
    ->	^(UsingDirectives usingdirective+)
    ;

usingdirective
    :   usingaliasdirective
    |   usingnamespacedirective
    ;

usingaliasdirective
    :   uSING identifier aSSIGN namespaceortypename sEMICOLON
	-> ^(UsingAliasDirective uSING identifier aSSIGN namespaceortypename sEMICOLON)
    ;

usingnamespacedirective
    :   uSING namespacename sEMICOLON
	-> ^(UsingNamespaceDirective uSING namespacename sEMICOLON)
    ;

namespacememberdeclarations //left recursion removed
    :   namespacememberdeclaration+
    ;

namespacememberdeclaration
    :   namespacedeclaration
    |   typedeclaration
    ;



typedeclaration
    :   (attributes? classmodifiers? pARTIAL? cLASS) => classdeclaration
    ->	^(TypeDeclaration classdeclaration)
    |   (attributes? structmodifiers? pARTIAL? sTRUCT) => structdeclaration
    ->	^(TypeDeclaration structdeclaration)
    |   (attributes? interfacemodifiers? pARTIAL? iNTERFACE) => interfacedeclaration
    ->	^(TypeDeclaration interfacedeclaration)
    |   (attributes? enummodifiers? eNUM) => enumdeclaration
    ->	^(TypeDeclaration enumdeclaration)
    |   (attributes? delegatemodifiers? dELEGATE) => delegatedeclaration
    ->	^(TypeDeclaration delegatedeclaration)
    ;

qualifiedaliasmember returns [String name]
    :   i1=identifier dOUBLECOLON i2=identifier typeargumentlist?
    	{$name = $i1.content + "::" + $i2.content;}
    ->	^(QualifiedAliasMember identifier dOUBLECOLON identifier typeargumentlist?)
    ;

//A.2.6 Gestion des Classes
classdeclaration returns [String name]
@after {
	tokenNameMap.put($classdeclaration.tree, $name);
	//	System.out.println($classdeclaration.tree);
	//	System.out.println($name);
	try {
              		final IClass entity = this.getFactory().createClass(retval.name.toCharArray());
              		codeLevelModel.addConstituent(entity);
              	//	classStockBody.add(element1);
              		ElementclassNumber=ElementclassNumber+1;
              	// body devra etre une liste entity.addConstituent($body);
              	    for(int i=0; i<ElementclassNumber; i++){
                            			
                            	    entity.addConstituent(classStockBody.get(i));
                            	    
                            		
                            		}
             		 
                            		
                            		
                            		if(Classmodifier== Modifier.PUBLIC){
                            			entity.setPublic(true);
                            			//System.out.println("voila yousra");
                                  }
                            		else if(Classmodifier== Modifier.PRIVATE){
                            			entity.setPrivate(true);
                            			//System.out.println("voila yousra");
                            			
                            			}
                            		if(Classmodifier== Modifier.PROTECTED){
                            			entity.setProtected(true);
                            			//System.out.println("voila yousra");
                            			
                            			}
                            		if(Classmodifier== Modifier.STATIC){
                            			entity.setStatic(true);
                            			//System.out.println("voila yousra");
                            			
                            			}
                            		if(Classmodifier== Modifier.ABSTRACT){
                            			entity.setAbstract(true);
                            			//System.out.println("voila yousra");
                            			
                            			}
                            		if(Classmodifier== Modifier.ABSTRACT+ Modifier.PUBLIC){
                            			entity.setAbstract(true);
                            			System.out.println("voila yousra");
                            			
                            			}
                            		
                            		System.out.print( Modifier.toString(Classmodifier)+" ");
                            		
                            		//System.out.println(((Object)retval.tree));
                            		System.out.println("class "+retval.name);
                            		
                            			
                            		
                            	// body devra etre une liste entity.addConstituent($body);
                            		System.out.println("le nombre de constituent de la class est "+entity.getNumberOfConstituents());
                            		
                            	} 
                            	catch (ModelDeclarationException e) {
                            		msg("Error with the code-level model. |createStructure()|");
                            	}

                          
            
}
    :   attributes? classmodifiers? pARTIAL? cLASS identifier typeparameterlist?
    		classbase? typeparameterconstraintsclauses? classbody sEMICOLON?
    	{
    		$name = $identifier.content;
    	//	$body = $classbody.content;
    	}
    -> ^(Class attributes? classmodifiers? pARTIAL? cLASS identifier typeparameterlist?
    		classbase? typeparameterconstraintsclauses? classbody sEMICOLON?)
    ;


classmodifiers //left recursion removed
//@after 
//ajouuuuuuuut
	//this.getClass.setModif
    :   classmodifier+
    ->  ^(Modifiers classmodifier+)
    ;

classmodifier
    :   nEW
   {  System.out.println(nEW664.getTree());}
    |   pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    |   aBSTRACT
    |   sEALED
    |   sTATIC
    ;

classbase
    :	cOLON classtype cOMMA interfacetypelist
    ->  ^(ClassBase cOLON classtype cOMMA interfacetypelist)
//the following rule cannot be distinguished from the first one and is therefore
//uncommented    
//    |   cOLON interfacetypelist
//    ->  ^(ClassBase cOLON interfacetypelist)
    |   cOLON classtype
    ->  ^(ClassBase cOLON classtype)
    ;

interfacetypelist //left recursion removed
    :   interfacetype (cOMMA interfacetype)*
    ;

classbody
    :   lBRACE classmemberdeclaration* rBRACE
    -> ^(Body lBRACE classmemberdeclaration* rBRACE)
    ;

/*classmemberdeclarations //left recursion removed
    :   classmemberdeclaration+
    ;
*/

classmemberdeclaration
    :	(attributes? constantmodifiers? cONST) =>  constantdeclaration
    ->	^(ClassMemberDeclaration constantdeclaration)
    |   fielddeclaration
    ->	^(ClassMemberDeclaration fielddeclaration)
    |   (methodheader) => methoddeclaration
    ->	^(ClassMemberDeclaration methoddeclaration)
    |   propertydeclaration
    ->	^(ClassMemberDeclaration propertydeclaration)
    |   (attributes? eventmodifiers? eVENT) => eventdeclaration
    ->	^(ClassMemberDeclaration eventdeclaration)
    |   (attributes? indexermodifiers? indexerdeclarator) => indexerdeclaration
    ->	^(ClassMemberDeclaration indexerdeclaration)
    |   (attributes? operatormodifiers operatordeclarator) => operatordeclaration
    ->	^(ClassMemberDeclaration operatordeclaration)
    |   (attributes? constructormodifiers? constructordeclarator) => constructordeclaration
    ->	^(ClassMemberDeclaration constructordeclaration)
    |   (attributes? eXTERN? tILDE) => finalizerdeclaration
    ->	^(ClassMemberDeclaration finalizerdeclaration)
    |   (attributes? staticconstructormodifiers identifier lPAREN rPAREN) => staticconstructordeclaration
    ->	^(ClassMemberDeclaration staticconstructordeclaration)
    |   typedeclaration
    ->	^(ClassMemberDeclaration typedeclaration)
    ;

constantdeclaration returns [String name]
@after {
	tokenNameMap.put($constantdeclaration.tree, $name);
}
    :   attributes? constantmodifiers? cONST type constantdeclarators sEMICOLON
    {	$name = $constantdeclarators.name;}
    ->	^(Constant attributes? constantmodifiers? cONST type constantdeclarators sEMICOLON)
    ;

constantmodifiers //left recursion removed
    :   constantmodifier+
    ->	^(Modifiers constantmodifier+)
    ;

constantmodifier
    :   nEW
    |    pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    ;

constantdeclarators returns [String name] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   c1=constantdeclarator {sb.append($c1.name);}
    	(cOMMA c2=constantdeclarator {sb.append(',').append($c2.name);})*
    	{$name = sb.toString();}
    ->	^(ConstantDeclarators constantdeclarator (cOMMA constantdeclarator)*)
    ;

constantdeclarator returns [String name]
    :   identifier aSSIGN constantexpression
    	{$name = $identifier.content;}
    ->	^(ConstantDeclarator identifier aSSIGN constantexpression)
    ;
     
fielddeclaration returns [String name, String Type, int Cardinality]
@after {

  
	//tokenNameMap.put($fielddeclaration.tree, $name, $Type);
		
    //System.out.println($fielddeclaration.tree);
	//System.out.println($name);
	//System.out.println("la mama");
try {
		 element1 = this.getFactory().createField(retval.name.toCharArray(), retval.Type.toCharArray(),1);
           		 if (methodstock= true){
            	    	MethodStockBody.add(element1);
            	    	ElementMethodNumber = ElementMethodNumber+1;  
            	     }
           	classStockBody.add(element1);
           	
           	
           if(Fieldmodifier== Modifier.PUBLIC){
                                          			element1.setPublic(true);
                                          			//System.out.println("voila yousra");
                                                }
                                          		else if(Fieldmodifier== Modifier.PRIVATE){
                                          			element1.setPrivate(true);
                                          			//System.out.println("voila yousra");
                                          			
                                          			}
                                          		if(Fieldmodifier== Modifier.PROTECTED){
                                          		element1.setProtected(true);
                                          			//System.out.println("voila yousra");
                                          			
                                          			}
                                          		if(Fieldmodifier== Modifier.STATIC){
                                          		element1.setStatic(true);
                                          			//System.out.println("voila yousra");
                                          			
                                          			}
                                          		
                                          		if(Fieldmodifier== Modifier.VOLATILE){
                                          		//element1.setStatic(true);
                                          			
                                                  
                                          			
                                          			}
                                          		
                                          		System.out.print( Modifier.toString(Fieldmodifier)+" ");
                                          		System.out.print(retval.Type+" ");
              	                                System.out.println(retval.name+" ");
                                          		//System.out.println(((Object)retval.tree));
                                          //		System.out.print("class "+retval.name); 	
		
	} 
	catch (ModelDeclarationException e) {
		e.printStackTrace(Output.getInstance().errorOutput());
	
	
	
	
	
	}
	
	
}

    :   attributes? fieldmodifiers? type variabledeclarators sEMICOLON
    {	
    	 $name = $variabledeclarators.name;
       {	retval.Type = (type713!=null?type713.name:null);}
    }
    ->	^(Field attributes? fieldmodifiers? type variabledeclarators sEMICOLON)
    ;

fieldmodifiers //left recursion removed
    :   fieldmodifier+
    ->	^(Modifiers fieldmodifier+)
    ;

fieldmodifier
    :   nEW
    { System.out.println(nEW717.getTree());}
    |    pUBLIC
 {    Fieldmodifier=Modifier.PUBLIC;}
    |   pROTECTED
  {   Fieldmodifier=Modifier.PROTECTED;}
    |   iNTERNAL
     { System.out.println(iNTERNAL720.getTree());}
    |   pRIVATE
 {    Fieldmodifier=Modifier.PRIVATE;}
    |   sTATIC
   {  Fieldmodifier=Modifier.STATIC;}
    |   rEADONLY
    { System.out.println(rEADONLY723.getTree());}
    |   vOLATILE
   {  System.out.println(vOLATILE724.getTree());}
    ;

variabledeclarators returns [String name] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   v1=variabledeclarator {sb.append($v1.name);}
    	(cOMMA v2=variabledeclarator {sb.append(',').append($v2.name);})*
    	{$name = sb.toString();}
    ->	^(VariableDeclarators variabledeclarator (cOMMA variabledeclarator)*)
    ;

variabledeclarator returns [String name]
    :   identifier (aSSIGN variableinitializer)?
    	{$name = $identifier.content;}
    ->	^(VariableDeclarator identifier (aSSIGN variableinitializer)?)
    ;



methoddeclaration returns [String signature, String membername]
@after {
	tokenNameMap.put($methoddeclaration.tree, $signature);
	
	
		
		
	try {
		 element = this.getFactory().createMethod(retval.signature.toCharArray());
               		
               		classStockBody.add(element);
                    ElementclassNumber = ElementclassNumber+1;
              		
                    
              		
                    for(int i=0; i<ElementMethodNumber; i++){
             			
              			element.addConstituent(MethodStockBody.get(i));
                 	    
                 		
                 		}
              		 System.out.println("le nombre de constituent de la methode est "+element.getNumberOfConstituents());
              
              		
              		 
              		 //maclass.addConstituent(element);
              		
                          
              			if(MethodModifier == Modifier.PUBLIC){
                           element.setPublic(true);
                         //System.out.println("voila yousra");
                                                }
                      if(MethodModifier== Modifier.PROTECTED){
                                element.setProtected(true);
                              //System.out.println("voila yousra");
                                          			
                                          			}                          
                          if(MethodModifier== Modifier.PRIVATE){
                               element.setPrivate(true);
                                  //System.out.println("voila yousra");
                                          		
                                        }
                             
                             if(MethodModifier== Modifier.STATIC){
                              element.setStatic(true);
                            //System.out.println("voila yousra");
                                          			
                                       }
                                          			
                           if(MethodModifier== Modifier.ABSTRACT){
                                  element.setAbstract(true);
                              //System.out.println("voila yousra");
                                          			
                                          			}               			           
                                  
              		
              		 System.out.print( Modifier.toString(MethodModifier)+" "+ MethodReturn+" ");     
                        System.out.println(retval.signature);
                                 
                            		
                       Methordreturns=(MethodReturn.toString()).toCharArray();
                       //Element PADL
                     element.setReturnType(Methordreturns);
	} 
	catch (ModelDeclarationException e) { 
		e.printStackTrace(Output.getInstance().errorOutput());
	}

	
}
    :   methodheader methodbody {$signature = $methodheader.signature + $methodheader.membername;}
    -> ^(Method methodheader methodbody)
    ;

//saves the method signature in attribute name
methodheader returns [String signature, String membername]
@init {
	String formalParams = "";
	String typeParams = "";
}
    :   attributes?
    	methodmodifiers?
    	returntype
    	membername
    	//if typeparameterlist exists, save string representation in typeParams
    	(typeparameterlist {typeParams = $typeparameterlist.signature;})?
    	lPAREN
    	//if formalparameterlist exists, save string representation in formalParams
    	(formalparameterlist {formalParams = $formalparameterlist.signature;})?
    	rPAREN
    	typeparameterconstraintsclauses?
    	//compute whole signature string
    	{$signature = $membername.name + typeParams + '(' + formalParams +')';}
    
    	
    -> 	attributes? methodmodifiers? returntype membername typeparameterlist?
    		^(ParameterList lPAREN formalparameterlist? rPAREN) typeparameterconstraintsclauses?
    ;

methodmodifiers //left recursion removed
    :   methodmodifier+
    -> ^(Modifiers methodmodifier+)
    ;

methodmodifier
    :   nEW
   {   System.out.println(nEW741.getTree());}
    |    pUBLIC
  {   MethodModifier =Modifier.PUBLIC;}
    |   pROTECTED
    {MethodModifier=Modifier.PROTECTED;}
    |   iNTERNAL
   {  System.out.println(iNTERNAL744.getTree()+" ");}
    |   pRIVATE
   {  MethodModifier=Modifier.PRIVATE;}
    |   sTATIC
   { MethodModifier=Modifier.STATIC;}
    |   vIRTUAL
   { System.out.println(vIRTUAL747.getTree()+" ");}
    |   sEALED
    { System.out.println(vIRTUAL747.getTree()+" ");}
    |   oVERRIDE
   {System.out.println(oVERRIDE749.getTree()+" ");}
    |   aBSTRACT
   { MethodModifier=Modifier.ABSTRACT;}
    |   eXTERN
     { System.out.println(eXTERN751.getTree()+" ");}
    ;

returntype
    :   type
  {  MethodReturn=   type752.name;}
    |   vOID
 {  MethodReturn=   vOID753.getTree();}
    ;

membername returns [String name]
 
@init {
	StringBuilder sb = new StringBuilder();
} 
    :   (interfacetype dOT {sb.append($interfacetype.name).append('.');})?
    	identifier {sb.append($identifier.content); $name = sb.toString();}
    ;

methodbody
    :   block
    |   sEMICOLON
    ;

formalparameterlist returns [String signature]
    :   fixedparameters cOMMA parameterarray
    	{$signature = $fixedparameters.signature + ',' + $parameterarray.signature;}
    |   fixedparameters
    	{$signature = $fixedparameters.signature;}
    |   parameterarray
    	{$signature = $parameterarray.signature;}
    ;

fixedparameters returns [String signature] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   f1=fixedparameter {sb.append($f1.signature);}
    	(cOMMA f2=fixedparameter {sb.append(',').append($f2.signature);})*
    	{$signature = sb.toString();}
    ;

fixedparameter returns [String signature]
@init {
	StringBuilder sb = new StringBuilder();
}

	:   attributes?
		(parametermodifier {sb.append($parametermodifier.content);})?
		type identifier {
			sb.append($type.name); 
			$signature = sb.toString();
			System.out.println($identifier.name);
		}
    ->	^(Parameter attributes? parametermodifier? type identifier)
    ;

parametermodifier returns [String content]
    :   rEF {$content = "ref";}
    |   oUT {$content = "out";}
    ;

parameterarray returns [String signature]
    :   attributes? pARAMS arraytype identifier
    	{$signature = $arraytype.signature;} //the PARAMS keyword is not part of signature
    ->	^(ParameterArray attributes? pARAMS arraytype identifier)
    ;


propertydeclaration returns [String name]
@after {
	tokenNameMap.put($propertydeclaration.tree, $name);
}
    :   attributes? propertymodifiers? type membername lBRACE accessordeclarations rBRACE
    	{$name = $membername.name;}
    ->	^(Property attributes? propertymodifiers? type membername 
    	^(AccessorDeclarations lBRACE accessordeclarations rBRACE))
    ;


propertymodifiers //left recursion removed
    :   propertymodifier+
    ->	^(Modifiers propertymodifier+)
    ;

propertymodifier
    :   nEW
    |   pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    |   sTATIC
    |   vIRTUAL
    |   sEALED
    |   oVERRIDE
    |   aBSTRACT
    |   eXTERN
    ;

accessordeclarations
    :   getaccessordeclaration setaccessordeclaration?
    |   setaccessordeclaration getaccessordeclaration?
    ;

getaccessordeclaration
    :   attributes? accessormodifier? gET accessorbody
    ->	^(GetAccessor attributes? accessormodifier? gET accessorbody)
    ;

setaccessordeclaration
    :   attributes? accessormodifier? sET accessorbody
    ->	^(SetAccessor attributes? accessormodifier? sET accessorbody)
    ;

accessormodifier
    :   pROTECTED			-> 	^(Modifiers pROTECTED)
    |   iNTERNAL			-> 	^(Modifiers iNTERNAL)
    |   pRIVATE				-> 	^(Modifiers pRIVATE)
    |   pROTECTED iNTERNAL	-> 	^(Modifiers pROTECTED iNTERNAL)
    |   iNTERNAL pROTECTED	->	^(Modifiers iNTERNAL pROTECTED)
    ;

accessorbody
    :   block
    |   sEMICOLON
    ;

eventdeclaration returns [String name]
@after {
	tokenNameMap.put($eventdeclaration.tree, $name);
}
    :   attributes? eventmodifiers? eVENT type variabledeclarators sEMICOLON
    	{$name = $variabledeclarators.name;}
    ->	^(Event attributes? eventmodifiers? eVENT type variabledeclarators sEMICOLON)
    |   attributes? eventmodifiers? eVENT type membername lBRACE eventaccessordeclarations rBRACE
    	{$name = $membername.name;}
    ->	^(Event attributes? eventmodifiers? eVENT type membername
    	^(AccessorDeclarations lBRACE eventaccessordeclarations rBRACE))
    ;

eventmodifiers //left recursion removed
    :   eventmodifier+
    ->	^(Modifiers eventmodifier+)
    ;

eventmodifier
    :   nEW
    |   pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    |   sTATIC
    |   vIRTUAL
    |   sEALED
    |   oVERRIDE
    |   aBSTRACT
    |   eXTERN
    ;



eventaccessordeclarations
    :   addaccessordeclaration removeaccessordeclaration
    |   removeaccessordeclaration addaccessordeclaration
    ;

addaccessordeclaration
    :   attributes? aDD block
    ->	^(AddAccessor attributes? aDD block)
    ;

removeaccessordeclaration
    :   attributes? rEMOVE block
    ->	^(RemoveAccessor attributes? rEMOVE block)
    ;

indexerdeclaration returns [String signature]
@after {
	tokenNameMap.put($indexerdeclaration.tree, $signature);
}
    :   attributes? indexermodifiers? indexerdeclarator lBRACE accessordeclarations rBRACE
 		{$signature = $indexerdeclarator.signature;}
    ->	^(Indexer attributes? indexermodifiers? indexerdeclarator
    	^(AccessorDeclarations lBRACE accessordeclarations rBRACE))
    ;

indexermodifiers //left recursion removed
    :   indexermodifier+
	->  ^(Modifiers indexermodifier+)
    ;

indexermodifier
    :   nEW
    |   pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    |   vIRTUAL
    |   sEALED
    |   oVERRIDE
    |   aBSTRACT
    |   eXTERN
    ;

/**
 * Using interfacetype from indexerdeclarator does not work (bug?), so copy
 * interfacetype and use that
 */
/*interfacetype_for_indexer returns [String name]
@init {
	StringBuilder sb = new StringBuilder();
}
	:	(simplenamespaceortypename dOT {sb.append($simplenamespaceortypename.name).append('.');})+
		identifier {sb.append($identifier.text); $name = sb.toString();}
		typeargumentlist?
	->	^(TypeName (simplenamespaceortypename dOT)+ identifier typeargumentlist?)
	|	simplenamespaceortypename
		{$name = $simplenamespaceortypename.name;}
	->	^(TypeName simplenamespaceortypename)
    ;
*/

indexerdeclarator returns [String signature]
    :   type (interfacetype dOT)? tHIS lBRACKET formalparameterlist rBRACKET
    	{$signature = "this" + "[" + $formalparameterlist.signature + "]";}
	->	type (interfacetype dOT)? tHIS ^(ParameterList lBRACKET formalparameterlist? rBRACKET)
    ;


operatordeclaration returns [String signature]
@after {
	tokenNameMap.put($operatordeclaration.tree, $signature);
}
    :   attributes? operatormodifiers operatordeclarator operatorbody
    	{$signature = $operatordeclarator.signature;}
    ->	^(Operator attributes? operatormodifiers operatordeclarator operatorbody)
    ;

operatormodifiers //left recursion removed
    :   operatormodifier+
    ->	^(Modifiers operatormodifier+)
    ;

operatormodifier
    :   pUBLIC
    |   sTATIC
    |   eXTERN
    ;

operatordeclarator returns [String signature]
    :   unaryoperatordeclarator
    	{$signature = $unaryoperatordeclarator.signature;}
    ->	^(UnaryOperatorDeclarator unaryoperatordeclarator)
    |   binaryoperatordeclarator
    	{$signature = $binaryoperatordeclarator.signature;}
    ->	^(BinaryOperatorDeclarator binaryoperatordeclarator)
    |   conversionoperatordeclarator
    	{$signature = $conversionoperatordeclarator.signature;}
    ->	^(ConversionOperatorDeclarator conversionoperatordeclarator)
    ;

unaryoperatordeclarator returns [String signature]
    :   type oPERATOR overloadableunaryoperator lPAREN t1=type identifier rPAREN
    	{$signature = $overloadableunaryoperator.content + '(' + $t1.name + ')';}
    ->	type oPERATOR ^(UnaryOperator overloadableunaryoperator)
    	^(ParameterList lPAREN ^(Parameter type identifier) rPAREN)
    ;

overloadableunaryoperator returns [String content]
    : pLUS  {$content = "+";}
    | mINUS {$content = "-";}
    | eXCLAM {$content = "!";}
    | tILDE {$content = "~";}
    | iNCREMENT {$content = "++";}
    | dECREMENT {$content = "--";}
    | tRUE {$content = "true";}
    | fALSE {$content = "false";}
    ;

binaryoperatordeclarator returns [String signature]
    :   type oPERATOR overloadablebinaryoperator lPAREN t1=type identifier cOMMA t2=type identifier rPAREN
    	{$signature = $overloadablebinaryoperator.content + '(' + $t1.name + ',' + $t2.name + ')';}
    ->	type oPERATOR ^(BinaryOperator overloadablebinaryoperator)
    	^(ParameterList lPAREN ^(Parameter type identifier) cOMMA ^(Parameter type identifier) rPAREN)
    ;

overloadablebinaryoperator returns [String content]
    : 	pLUS {$content = "+";}
    | 	mUL {$content = "-";}
    | 	dIV {$content = "/";}
    | 	mOD {$content = "*";}
    | 	aMPERSAND {$content = "&";}
    | 	bITWISEOR {$content = "|";}
    | 	bITWISEXOR {$content = "^";}
    |   lEFTSHIFT {$content = "<<";}
    | 	rIGHTSHIFT {$content = ">>";}
    | 	eQUALS {$content = "==";}
    | 	nOTEQUALS {$content = "!=";}
    | 	gT {$content = ">";}
    | 	lT {$content = "<";}
    | 	gE {$content = ">=";}
    | 	lE {$content = "<=";}
    ;

conversionoperatordeclarator returns [String signature]
    :   iMPLICIT oPERATOR tret=type lPAREN tparam=type identifier rPAREN
    	{$signature = $tret.name + '(' + $tparam.name + ')';}
    ->	iMPLICIT oPERATOR type ^(ParameterList lPAREN ^(Parameter type identifier) rPAREN)
    |   eXPLICIT oPERATOR tret=type lPAREN tparam=type identifier rPAREN
	    {$signature = $tret.name + '(' + $tparam.name + ')';}
    ->	eXPLICIT oPERATOR type ^(ParameterList lPAREN ^(Parameter type identifier) rPAREN)
    ;

operatorbody
    :   block
    |   sEMICOLON
    ;

constructordeclaration returns [String signature]
@after {
	tokenNameMap.put($constructordeclaration.tree, $signature);
}
    :   attributes? constructormodifiers? constructordeclarator constructorbody
	    {$signature = $constructordeclarator.signature;}
    ->	^(Constructor attributes? constructormodifiers? constructordeclarator constructorbody)
    ;

constructormodifiers //left recursion removed
    :   constructormodifier+
    ->	^(Modifiers constructormodifier+)
    ;

constructormodifier
    :   pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    |   eXTERN
    ;


constructordeclarator returns [String signature]
@init {
	String formalParams = "";
}
    :   identifier
    	lPAREN
    	(formalparameterlist {formalParams = $formalparameterlist.signature;})?
    	rPAREN constructorinitializer?
    	{$signature = $identifier.content + '(' + formalParams + ')';}
    ->	identifier ^(ParameterList lPAREN formalparameterlist? rPAREN) constructorinitializer?
    ;

constructorinitializer
    :   cOLON bASE lPAREN argumentlist? rPAREN
    ->	^(BaseInitializer cOLON bASE lPAREN argumentlist? rPAREN)
    |   cOLON tHIS lPAREN argumentlist? rPAREN
    ->	^(ThisInitializer cOLON tHIS lPAREN argumentlist? rPAREN)
    ;

constructorbody
    :   block
    |   sEMICOLON
    ;

staticconstructordeclaration returns [String signature]
@after {
	tokenNameMap.put($staticconstructordeclaration.tree, $signature);
}
    :   attributes? staticconstructormodifiers identifier lPAREN rPAREN staticconstructorbody
    	{$signature = $identifier.content + "()";}
    ->	^(StaticConstructor attributes? staticconstructormodifiers identifier
    	^(ParameterList lPAREN rPAREN) staticconstructorbody)
    ;

staticconstructormodifiers
    :   eXTERN? sTATIC
    ->	^(Modifiers eXTERN? sTATIC)
    |   sTATIC eXTERN?
    ->  ^(Modifiers sTATIC eXTERN?)
    ;

staticconstructorbody
    :   block
    |   sEMICOLON
    ;

finalizerdeclaration returns [String signature]
@after {
	tokenNameMap.put($finalizerdeclaration.tree, $signature);
}
    :   attributes? eXTERN? tILDE identifier lPAREN rPAREN finalizerbody
    	{$signature = "~" + $identifier.content + "()";}
    ->	^(Finalizer attributes? ^(Modifiers eXTERN)? tILDE identifier ^(ParameterList lPAREN rPAREN) finalizerbody)
    ;

finalizerbody
    :   block
    |   sEMICOLON
    ;

//A.2.7 Structs

structdeclaration returns [String name]
@after {
	tokenNameMap.put($structdeclaration.tree, $name);
}
    :   attributes? structmodifiers? pARTIAL? sTRUCT identifier typeparameterlist?
    		structinterfaces? typeparameterconstraintsclauses? structbody sEMICOLON?
	   	{$name = $identifier.content;}
    ->  ^(Struct attributes? structmodifiers? pARTIAL? sTRUCT identifier typeparameterlist?
    		structinterfaces? typeparameterconstraintsclauses? structbody sEMICOLON?)
    ;



structmodifiers //left recursion removed
    :   structmodifier+
    -> ^(Modifiers structmodifier+)
    ;

structmodifier
    :   nEW
    |    pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    ;

structinterfaces
    :   cOLON interfacetypelist
    ;

structbody
    :   lBRACE structmemberdeclaration* rBRACE
    -> ^(Body lBRACE structmemberdeclaration* rBRACE)
    ;


structmemberdeclaration
    :	(attributes? constantmodifiers? cONST) =>  constantdeclaration
    ->	^(StructMemberDeclaration constantdeclaration)
    |   fielddeclaration
    ->	^(StructMemberDeclaration fielddeclaration)
    |   (methodheader) => methoddeclaration
    ->	^(StructMemberDeclaration methoddeclaration)
    |   propertydeclaration
    ->	^(StructMemberDeclaration propertydeclaration)
    |   (attributes? eventmodifiers? eVENT) => eventdeclaration
    ->	^(StructMemberDeclaration eventdeclaration)
    |   (attributes? indexermodifiers? indexerdeclarator) => indexerdeclaration
    ->	^(StructMemberDeclaration indexerdeclaration)
    |   (attributes? operatormodifiers operatordeclarator) => operatordeclaration
    ->	^(StructMemberDeclaration operatordeclaration)
    |   (attributes? constructormodifiers? constructordeclarator) => constructordeclaration
    ->	^(StructMemberDeclaration constructordeclaration)
    |   (attributes? staticconstructormodifiers identifier lPAREN rPAREN) => staticconstructordeclaration
    ->	^(StructMemberDeclaration staticconstructordeclaration)
    |   typedeclaration
    ->	^(StructMemberDeclaration typedeclaration)
    ;

//A.2.8 Arrays
arraytype returns [String signature]
    :   nonarraytype rankspecifiers
    	{$signature = $nonarraytype.name + $rankspecifiers.signature;}
	->	^(ArrayType nonarraytype rankspecifiers)
    ;

nonarraytype returns [String name]
    :   valuetype {$name = $valuetype.name;}
//    ->	^(NonType valuetype)
    |   classtype {$name = $classtype.name;}
//    ->	^(Type classtype)
    |   interfacetype {$name = $interfacetype.name;}
//    ->	^(Type interfacetype)
    |   delegatetype {$name = $delegatetype.name;}
//    ->	^(Type delegatetype)
    |   typeparameter {$name = $typeparameter.name;}
//    ->	^(Type typeparameter)
    ;

rankspecifiers returns [String signature] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   (rankspecifier {sb.append($rankspecifier.signature);})+
    	{$signature = sb.toString();}
    ->	^(RankSpecifiers rankspecifier+)
    ;

rankspecifier returns [String signature]
@init {
	StringBuilder sb = new StringBuilder();
}
    :   lBRACKET (dimseparators {sb.append($dimseparators.signature);})? rBRACKET
    	{$signature = '[' + sb.toString() + ']';}
    ;

dimseparators returns [String signature] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   (cOMMA {sb.append(',');})+
    	{$signature = sb.toString();}
    ;

arrayinitializer
    :   lBRACE variableinitializerlist? rBRACE
    ->	^(ArrayInitializer lBRACE variableinitializerlist? rBRACE)
    |   lBRACE variableinitializerlist cOMMA rBRACE
    ->	^(ArrayInitializer lBRACE variableinitializerlist cOMMA rBRACE)
    ;


variableinitializerlist //left recursion removed
    :   variableinitializer (cOMMA variableinitializer)*
    ;

variableinitializer
    :   expression
    |   arrayinitializer
    ;


//A.2.9 Interfaces
interfacedeclaration returns [String name]
@after {
	tokenNameMap.put($interfacedeclaration.tree, $name);
	
	
	
	
		System.out.println($interfacedeclaration.tree);
		System.out.println($name);
		
		
	try {
		final IInterface element2 = this.getFactory().createInterface(retval.name.toCharArray());
      		
      		codeLevelModel.addConstituent(element2);
	} 
	catch (ModelDeclarationException e) { 
		e.printStackTrace(Output.getInstance().errorOutput());
	}

	
}
	
	



    :   attributes? interfacemodifiers? pARTIAL? iNTERFACE identifier typeparameterlist?
    		interfacebase? typeparameterconstraintsclauses? interfacebody sEMICOLON?
    	{$name = $identifier.content;}
   	-> ^(Interface attributes? interfacemodifiers? pARTIAL? iNTERFACE identifier typeparameterlist?
    		interfacebase? typeparameterconstraintsclauses? interfacebody sEMICOLON?)
    ;

interfacemodifiers //left recursion removed
    :   interfacemodifier+
    -> ^(Modifiers interfacemodifier+)
    ;

interfacemodifier
    :   nEW
    |    pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    ;

interfacebase
    :   cOLON interfacetypelist
    ;

interfacebody
    :   lBRACE interfacememberdeclaration* rBRACE
    -> ^(Body lBRACE interfacememberdeclaration* rBRACE)
    ;


interfacememberdeclaration
    :   interfacemethoddeclaration
    ->	^(InterfaceMemberDeclaration interfacemethoddeclaration)
    |   interfacepropertydeclaration
    ->	^(InterfaceMemberDeclaration interfacepropertydeclaration)
    |   interfaceeventdeclaration
    ->	^(InterfaceMemberDeclaration interfaceeventdeclaration)
    |   interfaceindexerdeclaration
    ->	^(InterfaceMemberDeclaration interfaceindexerdeclaration)
    ;

interfacemethoddeclaration returns [String signature]
@init {
	String formalParams = "";
	String typeParams = "";
}
@after {
	tokenNameMap.put($interfacemethoddeclaration.tree, $signature);
}
    :   attributes? nEW? returntype identifier
    	(typeparameterlist {typeParams = $typeparameterlist.signature;})?
    	lPAREN
    	(formalparameterlist {formalParams = $formalparameterlist.signature;})?
    	rPAREN typeparameterconstraintsclauses? sEMICOLON
    	{$signature = $identifier.content + typeParams + '(' + formalParams + ')';}
	-> ^(InterfaceMethod attributes? ^(Modifiers nEW)? returntype identifier typeparameterlist?
    		^(ParameterList lPAREN formalparameterlist? rPAREN) typeparameterconstraintsclauses? sEMICOLON)
    ;

interfacepropertydeclaration returns [String name]
@after {
	tokenNameMap.put($interfacepropertydeclaration.tree, $name);
}
    :   attributes? nEW? type identifier lBRACE interfaceaccessors rBRACE
    	{$name = $identifier.content;}
    ->	^(InterfaceProperty attributes? ^(Modifiers nEW)? type identifier
    	^(AccessorDeclarations lBRACE interfaceaccessors rBRACE))
    ;

interfaceaccessors
    :   attributes? gET sEMICOLON (attributes? sET sEMICOLON)?
    ->	^(GetAccessor attributes? gET sEMICOLON) (^(SetAccessor attributes? sET sEMICOLON))?
    |   attributes? sET sEMICOLON (attributes? gET sEMICOLON)?
    -> 	^(SetAccessor attributes? sET sEMICOLON) (^(GetAccessor attributes? gET sEMICOLON))?
    ;

interfaceeventdeclaration returns [String name]
@after {
	tokenNameMap.put($interfaceeventdeclaration.tree, $name);
}
    :   attributes? nEW? eVENT type identifier sEMICOLON
    	{$name = $identifier.content;}
    ->	^(InterfaceEvent attributes? ^(Modifiers nEW)? eVENT type identifier sEMICOLON)
    ;

interfaceindexerdeclaration returns [String signature]
@after {
	tokenNameMap.put($interfaceindexerdeclaration.tree, $signature);
}
    :   attributes? nEW? type tHIS lBRACKET formalparameterlist rBRACKET lBRACE interfaceaccessors rBRACE
    	{$signature = "this" + '[' + $formalparameterlist.signature + ']';}
    ->	^(InterfaceIndexer attributes? ^(Modifiers nEW)? type tHIS
    	^(ParameterList lBRACKET formalparameterlist rBRACKET)
    	^(AccessorDeclarations lBRACE interfaceaccessors rBRACE))
    ;


//A.2.10 Enums
enumdeclaration returns [String name]
@after {
	tokenNameMap.put($enumdeclaration.tree, $name);
}
    :   attributes? enummodifiers? eNUM identifier enumbase? enumbody sEMICOLON?
    	{$name = $identifier.content;}
    ->  ^(Enum attributes? enummodifiers? eNUM identifier enumbase? enumbody sEMICOLON?)
    ;

enumbase
    :   cOLON integralType
    ;

enumbody
    :   lBRACE enummemberdeclarations? rBRACE
    ->	^(Body lBRACE enummemberdeclarations? rBRACE)
    |   lBRACE enummemberdeclarations cOMMA rBRACE
    ->  ^(Body lBRACE enummemberdeclarations cOMMA rBRACE)
    ;

enummodifiers //left recursion removed
    :   enummodifier+
    -> ^(Modifiers enummodifier+)
    ;

enummodifier
    :   nEW
    |    pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    ;

enummemberdeclarations //left recursion removed
    :   enummemberdeclaration (cOMMA enummemberdeclaration)*
    ;

enummemberdeclaration
    :	attributes? identifier aSSIGN constantexpression
    ->	^(EnumMemberDeclaration attributes? identifier aSSIGN constantexpression)
	|	attributes? identifier
    ->	^(EnumMemberDeclaration attributes? identifier)
    ;

//A.2.11 Delegates
delegatedeclaration returns [String name]
@after {
	tokenNameMap.put($delegatedeclaration.tree, $name);
}
    :   attributes? delegatemodifiers? dELEGATE returntype identifier typeparameterlist?
    		lPAREN formalparameterlist? rPAREN typeparameterconstraintsclauses? sEMICOLON
    	{$name = $identifier.content;}
    ->  ^(Delegate attributes? delegatemodifiers? dELEGATE returntype identifier typeparameterlist?
    		lPAREN formalparameterlist? rPAREN typeparameterconstraintsclauses? sEMICOLON)
    ;

delegatemodifiers //left recursion removed
    :   delegatemodifier+
    -> ^(Modifiers delegatemodifier+)
    ;

delegatemodifier
    :   nEW
    |    pUBLIC
    |   pROTECTED
    |   iNTERNAL
    |   pRIVATE
    ;

//A.2.12 Attributes
globalattributes
    :   globalattributesection+
    ->	^(GlobalAttributes globalattributesection+)
    ;



globalattributesection
    :   lBRACKET globalattributetargetspecifier attributelist rBRACKET
    ->	^(GlobalAttributeSection lBRACKET globalattributetargetspecifier attributelist rBRACKET)
    |   lBRACKET globalattributetargetspecifier attributelist cOMMA rBRACKET
    ->	^(GlobalAttributeSection lBRACKET globalattributetargetspecifier attributelist cOMMA rBRACKET)
    ;

globalattributetargetspecifier
    :   globalattributetarget cOLON
    ->	^(GlobalAttributeTargetSpecifier globalattributetarget cOLON)
    ;

globalattributetarget
    :   identifier
    |   keyword
    ;

attributes
    :   attributesections
    ->	^(Attributes attributesections)
    ;

attributesections //left recursion removed
    :   attributesection+
    ;

attributesection
    :   lBRACKET attributetargetspecifier? attributelist cOMMA? rBRACKET
	->	^(AttributeSection lBRACKET attributetargetspecifier? attributelist cOMMA? rBRACKET)
    ;

attributetargetspecifier
    :   attributetarget cOLON
    ->	^(AttributeTargetSpecifier attributetarget cOLON)
    ;

attributetarget
    :   identifier
    |   keyword
    ;

attributelist //left recursion removed
    :   attribute (cOMMA attribute)*
    ;

attribute
    :   attributename attributearguments?
    ->	^(Attribute attributename attributearguments?)
    ;

attributename
    :   typename
    ;

attributearguments
    :   lPAREN positionalargumentlist? rPAREN
    ->	^(AttributeArguments lPAREN positionalargumentlist? rPAREN)
    |   lPAREN positionalargumentlist cOMMA namedargumentlist rPAREN
    ->	^(AttributeArguments lPAREN positionalargumentlist cOMMA namedargumentlist rPAREN)
    |   lPAREN namedargumentlist rPAREN
    ->	^(AttributeArguments lPAREN namedargumentlist rPAREN)
    ;

positionalargumentlist //left recursion removed
    :   positionalargument (cOMMA positionalargument)*
    ;

positionalargument
    :   attributeargumentexpression
    ;

namedargumentlist //left recursion removed
    :   namedargument (cOMMA namedargument)*
    ;

namedargument
    :   identifier aSSIGN attributeargumentexpression
    ->	^(NamedArgument identifier aSSIGN attributeargumentexpression)
    ;

attributeargumentexpression
    :	expression
    ;


//A.2.13 Generics
typeparameterlist returns [String signature]
    :   lT typeparameters gT
    	{$signature = '<' + $typeparameters.signature + '>';}
    -> ^(TypeParameterList lT typeparameters gT)
    ;

typeparameters returns [String signature] //left recursion removed
@init {
	StringBuilder sb = new StringBuilder();
}
    :   t1=typeparameter_attributed {sb.append($t1.signature);}
    	(cOMMA t2=typeparameter_attributed {sb.append(',').append($t2.signature);})*
    	{$signature = sb.toString();}
    ;

typeparameter returns [String name]
    :   identifier
    	{$name = $identifier.content;}
    ->	^(TypeParameter identifier)
    ;

/**
 * Newly introduced rule for simpler tree construction in rule typeparameters
 */
typeparameter_attributed returns [String signature]
	:	attributes? identifier
		{$signature = $identifier.content;}
	->	^(TypeParameter attributes? identifier)
	;

typeargumentlist
    :   lT typearguments gT
    ->	^(TypeArgumentList lT typearguments gT)
    ;

typearguments //left recursion removed
    :   typeargument (cOMMA typeargument)*
    ;

typeargument
    :   type
    ;

typeparameterconstraintsclauses //left recursion removed
    :   typeparameterconstraintsclause+
    -> ^(TypeParameterConstraintsClauses typeparameterconstraintsclause)
    ;

typeparameterconstraintsclause
    :   wHERE typeparameter cOLON typeparameterconstraints
    -> ^(TypeParameterConstraintsClause wHERE typeparameter cOLON typeparameterconstraints)
    ;

typeparameterconstraints
    :   primaryconstraint cOMMA secondaryconstraints cOMMA constructorconstraint
    ->	^(TypeParameterConstraints primaryconstraint cOMMA secondaryconstraints cOMMA constructorconstraint)
    |   primaryconstraint cOMMA secondaryconstraints
    ->	^(TypeParameterConstraints primaryconstraint cOMMA secondaryconstraints)
    |   primaryconstraint cOMMA constructorconstraint
    ->	^(TypeParameterConstraints primaryconstraint cOMMA constructorconstraint)
//	this one will always be matched by primaryconstraint cOMMA constructorconstraint
//    |   secondaryconstraints cOMMA constructorconstraint
    |	primaryconstraint
    ->	^(TypeParameterConstraints primaryconstraint)
//this one will always be matched by primaryconstraint or primaryconstraint cOMMA secondaryconstraints
//    |   secondaryconstraints
    |   constructorconstraint
    ->	^(TypeParameterConstraints constructorconstraint)
    ;

primaryconstraint
    :   classtype
    ->	^(PrimaryConstraint classtype)
    |   cLASS
    ->	^(PrimaryConstraint cLASS)
    |   sTRUCT
    ->	^(PrimaryConstraint sTRUCT)
    ;

secondaryconstraints
    :   interfacetype secondaryconstraintsrest
    ->	^(SecondaryConstraints interfacetype secondaryconstraintsrest)
	|	typeparameter secondaryconstraintsrest
	->	^(SecondaryConstraints typeparameter secondaryconstraintsrest)
    ;

secondaryconstraintsrest
	:	(cOMMA (interfacetype | typeparameter))*
	;

constructorconstraint
    :   nEW lPAREN rPAREN
    ->	^(ConstructorConstraint nEW lPAREN rPAREN)
    ;


//A.1.8 Literals
literal
    :   booleanliteral
    |   integerliteral
    |   realliteral
    |   characterliteral
    |   stringliteral
    |   nULL
    ;

booleanliteral
    :   tRUE
    |   fALSE
    ;


/**
 * Lexing parser starts here
 */
ignoredtail 
options {memoize=true;}
	: (Whitespace
	| Newline
	| Delimitedcomment 
	| Singlelinecomment 
	| Preprocessordirective)+
	;


lBRACE              : LBRACE (ignoredtail!)?;
rBRACE              : RBRACE (ignoredtail!)?;
lBRACKET            : LBRACKET (ignoredtail!)?;
rBRACKET            : RBRACKET (ignoredtail!)?;
lPAREN              : LPAREN (ignoredtail!)?;
rPAREN              : RPAREN (ignoredtail!)?;
dOT                 : DOT (ignoredtail!)?;
cOMMA               : COMMA (ignoredtail!)?;
cOLON               : COLON (ignoredtail!)?;
sEMICOLON           : SEMICOLON (ignoredtail!)?;
pLUS                : PLUS (ignoredtail!)?;
mINUS               : MINUS (ignoredtail!)?;
mUL                 : MUL (ignoredtail!)?;
dIV                 : DIV (ignoredtail!)?;
mOD                 : MOD (ignoredtail!)?;
aMPERSAND           : AMPERSAND (ignoredtail!)?;
bITWISEOR           : BITWISEOR (ignoredtail!)?;
bITWISEXOR          : BITWISEXOR (ignoredtail!)?;
eXCLAM              : EXCLAM (ignoredtail!)?;
tILDE               : TILDE (ignoredtail!)?;
aSSIGN              : ASSIGN (ignoredtail!)?;
lT                  : LT (ignoredtail!)?;
qUESTION            : QUESTION (ignoredtail!)?;
dOUBLEQUESTION      : DOUBLEQUESTION (ignoredtail!)?;
dOUBLECOLON         : DOUBLECOLON (ignoredtail!)?;
iNCREMENT           : INCREMENT (ignoredtail!)?;
dECREMENT           : DECREMENT (ignoredtail!)?;
lOGICALAND          : LOGICALAND (ignoredtail!)?;
lOGICALOR           : LOGICALOR (ignoredtail!)?;
aRROW               : ARROW (ignoredtail!)?;
eQUALS              : EQUALS (ignoredtail!)?;
nOTEQUALS           : NOTEQUALS (ignoredtail!)?;
lE                  : LE (ignoredtail!)?;
aDDASSIGN           : ADDASSIGN (ignoredtail!)?;
sUBASSIGN           : SUBASSIGN (ignoredtail!)?;
mULASSIGN           : MULASSIGN (ignoredtail!)?;
dIVASSIGN           : DIVASSIGN (ignoredtail!)?;
mODASSIGN           : MODASSIGN (ignoredtail!)?;
bITWISEANDASSIGN    : BITWISEANDASSIGN (ignoredtail!)?;
bITWISEORASSIGN     : BITWISEORASSIGN (ignoredtail!)?;
bITWISEXORASSIGN    : BITWISEXORASSIGN (ignoredtail!)?;
lEFTSHIFT           : LEFTSHIFT (ignoredtail!)?;
lEFTSHIFTASSIGN     : LEFTSHIFTASSIGN (ignoredtail!)?;

rIGHTSHIFTASSIGN 	: gt1=GT GT ASSIGN ignoredtail? -> RIGHTSHIFTASSIGN[$gt1, ">>="];
rIGHTSHIFT			: gt1=GT GT ignoredtail? -> RIGHTSHIFT[$gt1, ">>"];
gE                  : GT ASSIGN ignoredtail? -> GE[$GT, ">="];
gT                  : GT (ignoredtail!)?;



aBSTRACT 	: (ABSTRACT) => ABSTRACT (ignoredtail!)?;
aS          : (AS) => AS (ignoredtail!)?;
bASE        : (BASE) => BASE (ignoredtail!)?;
bOOL        : (BOOL) => BOOL (ignoredtail!)?;
bREAK       : (BREAK) => BREAK (ignoredtail!)?;
bYTE        : (BYTE) => BYTE (ignoredtail!)?;
cASE        : (CASE) => CASE (ignoredtail!)?;
cATCH       : (CATCH) => CATCH (ignoredtail!)?;
cHAR        : (CHAR) => CHAR (ignoredtail!)?;
cHECKED     : (CHECKED) => CHECKED (ignoredtail!)?;
cLASS       : (CLASS) => CLASS (ignoredtail!)?;
cONST       : (CONST) => CONST (ignoredtail!)?;
cONTINUE    : (CONTINUE) => CONTINUE (ignoredtail!)?;
dECIMAL     : (DECIMAL) => DECIMAL (ignoredtail!)?;
dEFAULT     : (DEFAULT) => DEFAULT (ignoredtail!)?;
dELEGATE    : (DELEGATE) => DELEGATE (ignoredtail!)?;
dO          : (DO) => DO (ignoredtail!)?;
dOUBLE      : (DOUBLE) => DOUBLE (ignoredtail!)?;
eLSE        : (ELSE) => ELSE (ignoredtail!)?;
eNUM        : (ENUM) => ENUM (ignoredtail!)?;
eVENT       : (EVENT) => EVENT (ignoredtail!)?;
eXPLICIT    : (EXPLICIT) => EXPLICIT (ignoredtail!)?;
eXTERN      : (EXTERN) => EXTERN (ignoredtail!)?;
fALSE       : (FALSE) => FALSE (ignoredtail!)?;
fINALLY     : (FINALLY) => FINALLY (ignoredtail!)?;
fIXED      	: (FIXED) =>  FIXED (ignoredtail!)?;
fLOAT       : (FLOAT) => FLOAT (ignoredtail!)?;
fOR         : (FOR) => FOR (ignoredtail!)?;
fOREACH     : (FOREACH) => FOREACH (ignoredtail!)?;
gOTO        : (GOTO) => GOTO (ignoredtail!)?;
iF          : (IF) => IF (ignoredtail!)?;
iMPLICIT    : (IMPLICIT) => IMPLICIT (ignoredtail!)?;
iN          : (IN) => IN (ignoredtail!)?;
iNT         : (INT) => INT (ignoredtail!)?;
iNTERFACE   : (INTERFACE) => INTERFACE (ignoredtail!)?;
iNTERNAL    : (INTERNAL) => INTERNAL (ignoredtail!)?;
iS          : (IS) => IS (ignoredtail!)?;
lOCK        : (LOCK) => LOCK (ignoredtail!)?;
lONG        : (LONG) => LONG (ignoredtail!)?;
nAMESPACE   : (NAMESPACE) => NAMESPACE (ignoredtail!)?;
nEW         : (NEW) => NEW (ignoredtail!)?;
nULL        : (NULL) => NULL (ignoredtail!)?;
oBJECT      : (OBJECT) => OBJECT (ignoredtail!)?;
oPERATOR    : (OPERATOR) => OPERATOR (ignoredtail!)?;
oUT         : (OUT) => OUT (ignoredtail!)?;
oVERRIDE    : (OVERRIDE) => OVERRIDE (ignoredtail!)?;
pARAMS      : (PARAMS) => PARAMS (ignoredtail!)?;
pRIVATE     : (PRIVATE) => PRIVATE (ignoredtail!)?;
pROTECTED   : (PROTECTED) => PROTECTED (ignoredtail!)?;
pUBLIC      : (PUBLIC) => PUBLIC (ignoredtail!)?;
rEADONLY    : (READONLY) => READONLY (ignoredtail!)?;
rEF         : (REF) => REF (ignoredtail!)?;
rETURN      : (RETURN) => RETURN (ignoredtail!)?;
sBYTE       : (SBYTE) => SBYTE (ignoredtail!)?;
sEALED      : (SEALED) => SEALED (ignoredtail!)?;
sHORT       : (SHORT) => SHORT (ignoredtail!)?;
sIZEOF      : (SIZEOF) => SIZEOF (ignoredtail!)?;
sTACKALLOC  : (STACKALLOC) => STACKALLOC (ignoredtail!)?;
sTATIC      : (STATIC) => STATIC (ignoredtail!)?;
sTRING      : (STRING) => STRING (ignoredtail!)?;
sTRUCT      : (STRUCT) => STRUCT (ignoredtail!)?;
sWITCH      : (SWITCH) => SWITCH (ignoredtail!)?;
tHIS        : (THIS) => THIS (ignoredtail!)?;
tHROW       : (THROW) => THROW (ignoredtail!)?;
tRUE        : (TRUE) => TRUE (ignoredtail!)?;
tRY         : (TRY) => TRY (ignoredtail!)?;
tYPEOF      : (TYPEOF) => TYPEOF (ignoredtail!)?;
uINT        : (UINT) => UINT (ignoredtail!)?;
uLONG       : (ULONG) => ULONG (ignoredtail!)?;
uNCHECKED   : (UNCHECKED) => UNCHECKED (ignoredtail!)?;
uNSAFE      : (UNSAFE) => UNSAFE (ignoredtail!)?;
uSHORT      : (USHORT) => USHORT (ignoredtail!)?;
uSING       : (USING) => USING (ignoredtail!)?;
vIRTUAL     : (VIRTUAL) => VIRTUAL (ignoredtail!)?;
vOID        : (VOID) => VOID (ignoredtail!)?;
vOLATILE    : (VOLATILE) => VOLATILE (ignoredtail!)?;
wHILE       : (WHILE) => WHILE (ignoredtail!)?;

aDD         : (ADD) => ADD (ignoredtail!)?;
aLIAS       : (ALIAS) => ALIAS (ignoredtail!)?;
gET         : (GET) => GET (ignoredtail!)?;
pARTIAL     : (PARTIAL) => PARTIAL (ignoredtail!)?;
rEMOVE      : (REMOVE) => REMOVE (ignoredtail!)?;
sET         : (SET) => SET (ignoredtail!)?;
wHERE       : (WHERE) => WHERE (ignoredtail!)?;
yIELD       : (YIELD) => YIELD (ignoredtail!)?;


ident 				: (Ident) => Ident (ignoredtail!)?; 
integerliteral		: (Integerliteral) => Integerliteral (ignoredtail!)?;
realliteral			: (Realliteral) => Realliteral (ignoredtail!)?;
characterliteral	: (Characterliteral) => Characterliteral (ignoredtail!)?;
stringliteral		: (Stringliteral) => Stringliteral (ignoredtail!)?;

LBRACE  : '{' ;
RBRACE  : '}' ;
LBRACKET  : '[' ;
RBRACKET  : ']' ;
LPAREN  : '(' ;
RPAREN  : ')' ;
DOT : '.' ;
COMMA : ',' ;
COLON : ':' ;
SEMICOLON : ';' ;
PLUS : '+' ;
MINUS : '-' ;
MUL : '*' ;
DIV : '/' ;
MOD : '%' ;
AMPERSAND : '&' ;
BITWISEOR : '|' ;
BITWISEXOR : '^' ;
EXCLAM : '!' ;
TILDE : '~' ;
ASSIGN : '=' ;
LT : '<' ;
GT : '>' ;
QUESTION : '?' ;
DOUBLEQUESTION : '??' ;
DOUBLECOLON : '::' ;
INCREMENT : '++' ;
DECREMENT : '--' ;
LOGICALAND : '&&' ;
LOGICALOR : '||' ;
ARROW : '->' ;
EQUALS : '==' ;
NOTEQUALS : '!=' ;
LE : '<=' ;
ADDASSIGN : '+=' ;
SUBASSIGN : '-=' ;
MULASSIGN : '*=' ;
DIVASSIGN : '/=' ;
MODASSIGN : '%=' ;
BITWISEANDASSIGN : '&=' ;
BITWISEORASSIGN : '|=' ;
BITWISEXORASSIGN : '^=' ;
LEFTSHIFT : '<<' ;
LEFTSHIFTASSIGN : '<<=' ;
//RIGHTSHIFT : '>>' ; interferes with sth like List<List<A>>
//RIGHTSHIFTASSIGN : '>>=' ;

//A.1.9 Keywords
ABSTRACT : 'abstract' ;
AS : 'as' ;
BASE : 'base' ;
BOOL : 'bool' ;
BREAK : 'break' ;
BYTE : 'byte' ;
CASE : 'case' ;
CATCH : 'catch' ;
CHAR  : 'char ' ;
CHECKED : 'checked' ;
CLASS : 'class' ;
CONST : 'const' ;
CONTINUE : 'continue' ;
DECIMAL : 'decimal' ;
DEFAULT : 'default' ;
DELEGATE : 'delegate' ;
DO : 'do' ;
DOUBLE : 'double' ;
ELSE : 'else' ;
ENUM : 'enum' ;
EVENT : 'event' ;
EXPLICIT : 'explicit' ;
EXTERN : 'extern' ;
FALSE : 'false' ;
FINALLY : 'finally' ;
FIXED : 'fixed' ;
FLOAT : 'float' ;
FOR : 'for' ;
FOREACH : 'foreach' ;
GOTO : 'goto' ;
IF : 'if' ;
IMPLICIT : 'implicit' ;
IN : 'in' ;
INT : 'int' ;
INTERFACE : 'interface' ;
INTERNAL : 'internal' ;
IS : 'is' ;
LOCK : 'lock' ;
LONG : 'long' ;
NAMESPACE : 'namespace' ;
NEW : 'new' ;
NULL : 'null' ;
OBJECT : 'object' ;
OPERATOR : 'operator' ;
OUT : 'out' ;
OVERRIDE : 'override' ;
PARAMS : 'params' ;
PRIVATE : 'private' ;
PROTECTED : 'protected' ;
PUBLIC : 'public' ;
READONLY : 'readonly' ;
REF : 'ref' ;
RETURN : 'return' ;
SBYTE : 'sbyte' ;
SEALED : 'sealed' ;
SHORT : 'short' ;
SIZEOF : 'sizeof' ;
STACKALLOC : 'stackalloc' ;
STATIC : 'static' ;
STRING : 'string' ;
STRUCT : 'struct' ;
SWITCH : 'switch' ;
THIS : 'this' ;
THROW : 'throw' ;
TRUE : 'true' ;
TRY : 'try' ;
TYPEOF : 'typeof' ;
UINT : 'uint' ;
ULONG : 'ulong' ;
UNCHECKED : 'unchecked' ;
UNSAFE : 'unsafe' ;
USHORT : 'ushort' ;
USING : 'using' ;
VIRTUAL : 'virtual' ;
VOID : 'void' ;
VOLATILE : 'volatile' ;
WHILE : 'while' ;

ADD : 'add' ;
ALIAS : 'alias' ;
GET : 'get' ;
PARTIAL : 'partial' ;
REMOVE : 'remove' ;
SET : 'set' ;
WHERE : 'where' ;
YIELD : 'yield' ;

//A.1.1 Line terminators
//fragment
Newline
    :   Newlinecharacter 	//{$channel=HIDDEN;}
    ;


fragment
Newlinecharacter
    :   '\r\n'					//Windows linebreak (not in specification, but we don't want to match 2 linebreaks)
    |	'\r'					//Mac linebreak
    |   '\n'	                //Unix linebreak
    |   '\u0085'                //Next line character
    |   '\u2028'                //Line separator character
    |   '\u2029'                //Paragraph separator character
    ;



//A.1.2 White space
//fragment
Whitespace
    :   Whitespacecharacter //{$channel=HIDDEN;}
    ;

fragment
Whitespacecharacter
    :   '\u0009'    //Horizontal tab character
    |   '\u000B'    //Vertical tab character
    |   '\u000C'    //Form feed character
    //Any character with Unicode cLASS Zs
    |   '\u0020'      //SPACE
    |   '\u00A0'     //NOBREAK SPACE
    |   '\u1680'     //OGHAM SPACE MARK
    |   '\u180E'     //MONGOLIAN VOWEL SEPARATOR
    |   '\u2000'     //EN QUAD
    |   '\u2001'     //EM QUAD
    |   '\u2002'     //EN SPACE
    |   '\u2003'     //EM SPACE
    |   '\u2004'     //THREEPEREM SPACE
    |   '\u2005'     //FOURPEREM SPACE
    |   '\u2006'     //SIXPEREM SPACE
    |   '\u2007'     //FIGURE SPACE
    |   '\u2008'     //PUNCTUATION SPACE
    |   '\u2009'     //THIN SPACE
    |   '\u200A'     //HAIR SPACE
    |   '\u202F'     //NARROW NOBREAK SPACE
    |   '\u205F'     //MEDIUM MATHEMATICAL SPACE
    |   '\u3000'     //IDEOGRAPHIC SPACE
    ;


/*WS  :  (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;}
    ;*/
//fragment
Delimitedcomment
    :   '/*' ( options {greedy=false;} : . )* '*/' //{$channel=HIDDEN;}
    ;
//fragment
Singlelinecomment
    : 	'//' Inputcharacter* //{$channel=HIDDEN;}
    ;
    
//fragment
Preprocessordirective
	:	'#' Inputcharacter* //{$channel=HIDDEN;}
	;    

fragment
Inputcharacter
	:	~Newlinecharacter
	;






//A.1.5 Unicode escape sequences
fragment
Unicodeescapesequence
    :   '\\u' Hexdigit Hexdigit Hexdigit Hexdigit
    |   '\\U' Hexdigit Hexdigit Hexdigit Hexdigit Hexdigit Hexdigit Hexdigit Hexdigit
    ;

//A.1.6 Identifiers
Ident
    :   Identifierorkeyword
    |   '@' Identifierorkeyword
    ;


fragment
Identifierorkeyword
    :   Identifierstartcharacter Identifierpartcharacter*
    ;

fragment
Identifierstartcharacter
    :   Lettercharacter
    |   '_'
    ;

fragment
Identifierpartcharacter
    :   Lettercharacter
    |   Decimaldigitcharacter
    |   Connectingcharacter
    |   Combiningcharacter
    |   Formattingcharacter
    ;

fragment
Lettercharacter    //A Unicode character of classes Lu, Ll, lT, Lm, Lo, or Nl
    :   '\u0041'..'\u005a'
    |   '\u0061'..'\u007a'
    |   '\u00aa'
    |   '\u00b5'
    |   '\u00ba'
    |   '\u00c0'..'\u00d6'
    |   '\u00d8'..'\u00f6'
    |   '\u00f8'..'\u0236'
    |   '\u0250'..'\u02c1'
    |   '\u02c6'..'\u02d1'
    |   '\u02e0'..'\u02e4'
    |   '\u02ee'
    |   '\u037a'
    |   '\u0386'
    |   '\u0388'..'\u038a'
    |   '\u038c'
    |   '\u038e'..'\u03a1'
    |   '\u03a3'..'\u03ce'
    |   '\u03d0'..'\u03f5'
    |   '\u03f7'..'\u03fb'
    |   '\u0400'..'\u0481'
    |   '\u048a'..'\u04ce'
    |   '\u04d0'..'\u04f5'
    |   '\u04f8'..'\u04f9'
    |   '\u0500'..'\u050f'
    |   '\u0531'..'\u0556'
    |   '\u0559'
    |   '\u0561'..'\u0587'
    |   '\u05d0'..'\u05ea'
    |   '\u05f0'..'\u05f2'
    |   '\u0621'..'\u063a'
    |   '\u0640'..'\u064a'
    |   '\u066e'..'\u066f'
    |   '\u0671'..'\u06d3'
    |   '\u06d5'
    |   '\u06e5'..'\u06e6'
    |   '\u06ee'..'\u06ef'
    |   '\u06fa'..'\u06fc'
    |   '\u06ff'
    |   '\u0710'
    |   '\u0712'..'\u072f'
    |   '\u074d'..'\u074f'
    |   '\u0780'..'\u07a5'
    |   '\u07b1'
    |   '\u0904'..'\u0939'
    |   '\u093d'
    |   '\u0950'
    |   '\u0958'..'\u0961'
    |   '\u0985'..'\u098c'
    |   '\u098f'..'\u0990'
    |   '\u0993'..'\u09a8'
    |   '\u09aa'..'\u09b0'
    |   '\u09b2'
    |   '\u09b6'..'\u09b9'
    |   '\u09bd'
    |   '\u09dc'..'\u09dd'
    |   '\u09df'..'\u09e1'
    |   '\u09f0'..'\u09f1'
    |   '\u0a05'..'\u0a0a'
    |   '\u0a0f'..'\u0a10'
    |   '\u0a13'..'\u0a28'
    |   '\u0a2a'..'\u0a30'
    |   '\u0a32'..'\u0a33'
    |   '\u0a35'..'\u0a36'
    |   '\u0a38'..'\u0a39'
    |   '\u0a59'..'\u0a5c'
    |   '\u0a5e'
    |   '\u0a72'..'\u0a74'
    |   '\u0a85'..'\u0a8d'
    |   '\u0a8f'..'\u0a91'
    |   '\u0a93'..'\u0aa8'
    |   '\u0aaa'..'\u0ab0'
    |   '\u0ab2'..'\u0ab3'
    |   '\u0ab5'..'\u0ab9'
    |   '\u0abd'
    |   '\u0ad0'
    |   '\u0ae0'..'\u0ae1'
    |   '\u0b05'..'\u0b0c'
    |   '\u0b0f'..'\u0b10'
    |   '\u0b13'..'\u0b28'
    |   '\u0b2a'..'\u0b30'
    |   '\u0b32'..'\u0b33'
    |   '\u0b35'..'\u0b39'
    |   '\u0b3d'
    |   '\u0b5c'..'\u0b5d'
    |   '\u0b5f'..'\u0b61'
    |   '\u0b71'
    |   '\u0b83'
    |   '\u0b85'..'\u0b8a'
    |   '\u0b8e'..'\u0b90'
    |   '\u0b92'..'\u0b95'
    |   '\u0b99'..'\u0b9a'
    |   '\u0b9c'
    |   '\u0b9e'..'\u0b9f'
    |   '\u0ba3'..'\u0ba4'
    |   '\u0ba8'..'\u0baa'
    |   '\u0bae'..'\u0bb5'
    |   '\u0bb7'..'\u0bb9'
    |   '\u0c05'..'\u0c0c'
    |   '\u0c0e'..'\u0c10'
    |   '\u0c12'..'\u0c28'
    |   '\u0c2a'..'\u0c33'
    |   '\u0c35'..'\u0c39'
    |   '\u0c60'..'\u0c61'
    |   '\u0c85'..'\u0c8c'
    |   '\u0c8e'..'\u0c90'
    |   '\u0c92'..'\u0ca8'
    |   '\u0caa'..'\u0cb3'
    |   '\u0cb5'..'\u0cb9'
    |   '\u0cbd'
    |   '\u0cde'
    |   '\u0ce0'..'\u0ce1'
    |   '\u0d05'..'\u0d0c'
    |   '\u0d0e'..'\u0d10'
    |   '\u0d12'..'\u0d28'
    |   '\u0d2a'..'\u0d39'
    |   '\u0d60'..'\u0d61'
    |   '\u0d85'..'\u0d96'
    |   '\u0d9a'..'\u0db1'
    |   '\u0db3'..'\u0dbb'
    |   '\u0dbd'
    |   '\u0dc0'..'\u0dc6'
    |   '\u0e01'..'\u0e30'
    |   '\u0e32'..'\u0e33'
    |   '\u0e40'..'\u0e46'
    |   '\u0e81'..'\u0e82'
    |   '\u0e84'
    |   '\u0e87'..'\u0e88'
    |   '\u0e8a'
    |   '\u0e8d'
    |   '\u0e94'..'\u0e97'
    |   '\u0e99'..'\u0e9f'
    |   '\u0ea1'..'\u0ea3'
    |   '\u0ea5'
    |   '\u0ea7'
    |   '\u0eaa'..'\u0eab'
    |   '\u0ead'..'\u0eb0'
    |   '\u0eb2'..'\u0eb3'
    |   '\u0ebd'
    |   '\u0ec0'..'\u0ec4'
    |   '\u0ec6'
    |   '\u0edc'..'\u0edd'
    |   '\u0f00'
    |   '\u0f40'..'\u0f47'
    |   '\u0f49'..'\u0f6a'
    |   '\u0f88'..'\u0f8b'
    |   '\u1000'..'\u1021'
    |   '\u1023'..'\u1027'
    |   '\u1029'..'\u102a'
    |   '\u1050'..'\u1055'
    |   '\u10a0'..'\u10c5'
    |   '\u10d0'..'\u10f8'
    |   '\u1100'..'\u1159'
    |   '\u115f'..'\u11a2'
    |   '\u11a8'..'\u11f9'
    |   '\u1200'..'\u1206'
    |   '\u1208'..'\u1246'
    |   '\u1248'
    |   '\u124a'..'\u124d'
    |   '\u1250'..'\u1256'
    |   '\u1258'
    |   '\u125a'..'\u125d'
    |   '\u1260'..'\u1286'
    |   '\u1288'
    |   '\u128a'..'\u128d'
    |   '\u1290'..'\u12ae'
    |   '\u12b0'
    |   '\u12b2'..'\u12b5'
    |   '\u12b8'..'\u12be'
    |   '\u12c0'
    |   '\u12c2'..'\u12c5'
    |   '\u12c8'..'\u12ce'
    |   '\u12d0'..'\u12d6'
    |   '\u12d8'..'\u12ee'
    |   '\u12f0'..'\u130e'
    |   '\u1310'
    |   '\u1312'..'\u1315'
    |   '\u1318'..'\u131e'
    |   '\u1320'..'\u1346'
    |   '\u1348'..'\u135a'
    |   '\u13a0'..'\u13f4'
    |   '\u1401'..'\u166c'
    |   '\u166f'..'\u1676'
    |   '\u1681'..'\u169a'
    |   '\u16a0'..'\u16ea'
    |   '\u16ee'..'\u16f0'
    |   '\u1700'..'\u170c'
    |   '\u170e'..'\u1711'
    |   '\u1720'..'\u1731'
    |   '\u1740'..'\u1751'
    |   '\u1760'..'\u176c'
    |   '\u176e'..'\u1770'
    |   '\u1780'..'\u17b3'
    |   '\u17d7'
    |   '\u17dc'
    |   '\u1820'..'\u1877'
    |   '\u1880'..'\u18a8'
    |   '\u1900'..'\u191c'
    |   '\u1950'..'\u196d'
    |   '\u1970'..'\u1974'
    |   '\u1d00'..'\u1d6b'
    |   '\u1e00'..'\u1e9b'
    |   '\u1ea0'..'\u1ef9'
    |   '\u1f00'..'\u1f15'
    |   '\u1f18'..'\u1f1d'
    |   '\u1f20'..'\u1f45'
    |   '\u1f48'..'\u1f4d'
    |   '\u1f50'..'\u1f57'
    |   '\u1f59'
    |   '\u1f5b'
    |   '\u1f5d'
    |   '\u1f5f'..'\u1f7d'
    |   '\u1f80'..'\u1fb4'
    |   '\u1fb6'..'\u1fbc'
    |   '\u1fbe'
    |   '\u1fc2'..'\u1fc4'
    |   '\u1fc6'..'\u1fcc'
    |   '\u1fd0'..'\u1fd3'
    |   '\u1fd6'..'\u1fdb'
    |   '\u1fe0'..'\u1fec'
    |   '\u1ff2'..'\u1ff4'
    |   '\u1ff6'..'\u1ffc'
    |   '\u2071'
    |   '\u207f'
    |   '\u2102'
    |   '\u2107'
    |   '\u210a'..'\u2113'
    |   '\u2115'
    |   '\u2119'..'\u211d'
    |   '\u2124'
    |   '\u2126'
    |   '\u2128'
    |   '\u212a'..'\u212d'
    |   '\u212f'..'\u2131'
    |   '\u2133'..'\u2139'
    |   '\u213d'..'\u213f'
    |   '\u2145'..'\u2149'
    |   '\u2160'..'\u2183'
    |   '\u3005'..'\u3007'
    |   '\u3021'..'\u3029'
    |   '\u3031'..'\u3035'
    |   '\u3038'..'\u303c'
    |   '\u3041'..'\u3096'
    |   '\u309d'..'\u309f'
    |   '\u30a1'..'\u30fa'
    |   '\u30fc'..'\u30ff'
    |   '\u3105'..'\u312c'
    |   '\u3131'..'\u318e'
    |   '\u31a0'..'\u31b7'
    |   '\u31f0'..'\u31ff'
    |   '\u3400'..'\u4db5'
    |   '\u4e00'..'\u9fa5'
    |   '\ua000'..'\ua48c'
    |   '\uac00'..'\ud7a3'
    |   '\uf900'..'\ufa2d'
    |   '\ufa30'..'\ufa6a'
    |   '\ufb00'..'\ufb06'
    |   '\ufb13'..'\ufb17'
    |   '\ufb1d'
    |   '\ufb1f'..'\ufb28'
    |   '\ufb2a'..'\ufb36'
    |   '\ufb38'..'\ufb3c'
    |   '\ufb3e'
    |   '\ufb40'..'\ufb41'
    |   '\ufb43'..'\ufb44'
    |   '\ufb46'..'\ufbb1'
    |   '\ufbd3'..'\ufd3d'
    |   '\ufd50'..'\ufd8f'
    |   '\ufd92'..'\ufdc7'
    |   '\ufdf0'..'\ufdfb'
    |   '\ufe70'..'\ufe74'
    |   '\ufe76'..'\ufefc'
    |   '\uff21'..'\uff3a'
    |   '\uff41'..'\uff5a'
    |   '\uff66'..'\uffbe'
    |   '\uffc2'..'\uffc7'
    |   '\uffca'..'\uffcf'
    |   '\uffd2'..'\uffd7'
    |   '\uffda'..'\uffdc'
    ;

fragment
Combiningcharacter //A Unicode character of classes Mn or Mc
    :   '\u0300'..'\u0357'
    |   '\u035d'..'\u036f'
    |   '\u0483'..'\u0486'
    |   '\u0591'..'\u05a1'
    |   '\u05a3'..'\u05b9'
    |   '\u05bb'..'\u05bd'
    |   '\u05bf'
    |   '\u05c1'..'\u05c2'
    |   '\u05c4'
    |   '\u0610'..'\u0615'
    |   '\u064b'..'\u0658'
    |   '\u0670'
    |   '\u06d6'..'\u06dc'
    |   '\u06df'..'\u06e4'
    |   '\u06e7'..'\u06e8'
    |   '\u06ea'..'\u06ed'
    |   '\u0711'
    |   '\u0730'..'\u074a'
    |   '\u07a6'..'\u07b0'
    |   '\u0901'..'\u0903'
    |   '\u093c'
    |   '\u093e'..'\u094d'
    |   '\u0951'..'\u0954'
    |   '\u0962'..'\u0963'
    |   '\u0981'..'\u0983'
    |   '\u09bc'
    |   '\u09be'..'\u09c4'
    |   '\u09c7'..'\u09c8'
    |   '\u09cb'..'\u09cd'
    |   '\u09d7'
    |   '\u09e2'..'\u09e3'
    |   '\u0a01'..'\u0a03'
    |   '\u0a3c'
    |   '\u0a3e'..'\u0a42'
    |   '\u0a47'..'\u0a48'
    |   '\u0a4b'..'\u0a4d'
    |   '\u0a70'..'\u0a71'
    |   '\u0a81'..'\u0a83'
    |   '\u0abc'
    |   '\u0abe'..'\u0ac5'
    |   '\u0ac7'..'\u0ac9'
    |   '\u0acb'..'\u0acd'
    |   '\u0ae2'..'\u0ae3'
    |   '\u0b01'..'\u0b03'
    |   '\u0b3c'
    |   '\u0b3e'..'\u0b43'
    |   '\u0b47'..'\u0b48'
    |   '\u0b4b'..'\u0b4d'
    |   '\u0b56'..'\u0b57'
    |   '\u0b82'
    |   '\u0bbe'..'\u0bc2'
    |   '\u0bc6'..'\u0bc8'
    |   '\u0bca'..'\u0bcd'
    |   '\u0bd7'
    |   '\u0c01'..'\u0c03'
    |   '\u0c3e'..'\u0c44'
    |   '\u0c46'..'\u0c48'
    |   '\u0c4a'..'\u0c4d'
    |   '\u0c55'..'\u0c56'
    |   '\u0c82'..'\u0c83'
    |   '\u0cbc'
    |   '\u0cbe'..'\u0cc4'
    |   '\u0cc6'..'\u0cc8'
    |   '\u0cca'..'\u0ccd'
    |   '\u0cd5'..'\u0cd6'
    |   '\u0d02'..'\u0d03'
    |   '\u0d3e'..'\u0d43'
    |   '\u0d46'..'\u0d48'
    |   '\u0d4a'..'\u0d4d'
    |   '\u0d57'
    |   '\u0d82'..'\u0d83'
    |   '\u0dca'
    |   '\u0dcf'..'\u0dd4'
    |   '\u0dd6'
    |   '\u0dd8'..'\u0ddf'
    |   '\u0df2'..'\u0df3'
    |   '\u0e31'
    |   '\u0e34'..'\u0e3a'
    |   '\u0e47'..'\u0e4e'
    |   '\u0eb1'
    |   '\u0eb4'..'\u0eb9'
    |   '\u0ebb'..'\u0ebc'
    |   '\u0ec8'..'\u0ecd'
    |   '\u0f18'..'\u0f19'
    |   '\u0f35'
    |   '\u0f37'
    |   '\u0f39'
    |   '\u0f3e'..'\u0f3f'
    |   '\u0f71'..'\u0f84'
    |   '\u0f86'..'\u0f87'
    |   '\u0f90'..'\u0f97'
    |   '\u0f99'..'\u0fbc'
    |   '\u0fc6'
    |   '\u102c'..'\u1032'
    |   '\u1036'..'\u1039'
    |   '\u1056'..'\u1059'
    |   '\u1712'..'\u1714'
    |   '\u1732'..'\u1734'
    |   '\u1752'..'\u1753'
    |   '\u1772'..'\u1773'
    |   '\u17b6'..'\u17d3'
    |   '\u17dd'
    |   '\u180b'..'\u180d'
    |   '\u18a9'
    |   '\u1920'..'\u192b'
    |   '\u1930'..'\u193b'
    |   '\u20d0'..'\u20dc'
    |   '\u20e1'
    |   '\u20e5'..'\u20ea'
    |   '\u302a'..'\u302f'
    |   '\u3099'..'\u309a'
    |   '\ufb1e'
    |   '\ufe00'..'\ufe0f'
    |   '\ufe20'..'\ufe23'
    ;

fragment
Decimaldigitcharacter //A Unicode character of the class Nd
    :   '\u0030'..'\u0039'
    |   '\u0660'..'\u0669'
    |   '\u06f0'..'\u06f9'
    |   '\u0966'..'\u096f'
    |   '\u09e6'..'\u09ef'
    |   '\u0a66'..'\u0a6f'
    |   '\u0ae6'..'\u0aef'
    |   '\u0b66'..'\u0b6f'
    |   '\u0be7'..'\u0bef'
    |   '\u0c66'..'\u0c6f'
    |   '\u0ce6'..'\u0cef'
    |   '\u0d66'..'\u0d6f'
    |   '\u0e50'..'\u0e59'
    |   '\u0ed0'..'\u0ed9'
    |   '\u0f20'..'\u0f29'
    |   '\u1040'..'\u1049'
    |   '\u1369'..'\u1371'
    |   '\u17e0'..'\u17e9'
    |   '\u1810'..'\u1819'
    |   '\u1946'..'\u194f'
    |   '\uff10'..'\uff19'
    ;

fragment
Connectingcharacter    //A Unicode character of the class Pc
    :   '\u005f'
    |   '\u203f'..'\u2040'
    |   '\u2054'
    |   '\u30fb'
    |   '\ufe33'..'\ufe34'
    |   '\ufe4d'..'\ufe4f'
    |   '\uff3f'
    |   '\uff65'
    ;

fragment
Formattingcharacter    //A Unicode character of the cLASSCf
    :    '\u00ad'
    |   '\u0600'..'\u0603'
    |   '\u06dd'
    |   '\u070f'
    |   '\u17b4'..'\u17b5'
    |   '\u200c'..'\u200f'
    |   '\u202a'..'\u202e'
    |   '\u2060'..'\u2063'
    |   '\u206a'..'\u206f'
    |   '\ufeff'
    |   '\ufff9'..'\ufffb'
    ;


Integerliteral
	:	Decimalintegerliteral
	|	Hexadecimalintegerliteral
	;


fragment
Decimalintegerliteral
    :   ('0'..'9')+ Integertypesuffix?
    ;

fragment
Integertypesuffix
    : 'U' | 'u' | 'L' | 'l' | 'UL' | 'Ul' | 'uL' | 'ul' | 'LU' | 'Lu' | 'lU' | 'lu'
    ;

fragment
Hexadecimalintegerliteral
    : '0x' Hexdigit+ Integertypesuffix?
    | '0X' Hexdigit+ Integertypesuffix?
    ;

fragment
Hexdigit
    : ('0'..'9') | ('A'..'F') | ('a'..'f')
    ;


Realliteral
    :   ('0'..'9')+ '.' ('0'..'9')+ Exponentpart? RealTypesuffix?
    |   '.' ('0'..'9')+ Exponentpart? RealTypesuffix?
    |   ('0'..'9')+ Exponentpart RealTypesuffix?
    |   ('0'..'9')+ RealTypesuffix
    ;

fragment
Exponentpart
    :   ('e' | 'E') ('+' | '-')? ('0'..'9')+
    ;

fragment
RealTypesuffix
    : 'F' | 'f' | 'D' | 'd' | 'M' | 'm'
    ;

Characterliteral
    :   '\'' Character '\''
    ;

fragment
Character
    :   Singlecharacter
    |   Simpleescapesequence
    |   Hexadecimalescapesequence
    |   Unicodeescapesequence
    ;

fragment
Singlecharacter
//    :   ~('\u0027' | '\u005c' | Newlinecharacter)
	:	~('\u0027' | '\u005c' | '\r' | '\n')
    ;

fragment
Simpleescapesequence
    :   '\\' ('\'' | '\"' | '\\' | '0' | 'a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v')
    ;

fragment
Hexadecimalescapesequence
    :   '\\x' Hexdigit
    |    '\\x' Hexdigit Hexdigit
    |    '\\x' Hexdigit Hexdigit Hexdigit
    |    '\\x' Hexdigit Hexdigit Hexdigit Hexdigit
    ;

Stringliteral
    :   Regularstringliteral
    |   Verbatimstringliteral
    ;

fragment
Regularstringliteral
    :   '\"'  Regularstringliteralcharacter* '\"'
    ;

fragment
Regularstringliteralcharacter
    :   Singleregularstringliteralcharacter
    |   Simpleescapesequence
    |   Hexadecimalescapesequence
    |   Unicodeescapesequence
    ;

fragment
Singleregularstringliteralcharacter
    :   ~('\u0022' | '\u005c' | Newlinecharacter)
    ;

fragment
Verbatimstringliteral
    :   '@' '\"' Verbatimstringliteralcharacter* '\"'
    ;


fragment
Verbatimstringliteralcharacter
    :   ~'\"'
    |   '\"' '\"'
    ;



