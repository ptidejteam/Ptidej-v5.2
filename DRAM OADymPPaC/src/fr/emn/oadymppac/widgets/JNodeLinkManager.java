package fr.emn.oadymppac.widgets;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.InputEvent;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.Vector;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JSlider;
import javax.swing.WindowConstants;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import att.grappa.Edge;
import att.grappa.Element;
import att.grappa.Graph;
import att.grappa.Grappa;
import att.grappa.GrappaAdapter;
import att.grappa.GrappaBox;
import att.grappa.GrappaConstants;
import att.grappa.GrappaPanel;
import att.grappa.GrappaPoint;
import att.grappa.GrappaSupport;
import att.grappa.Node;
import att.grappa.Parser;
import att.grappa.Subgraph;

/**
 * A node-link visualization relying on AT&T graph layout 
 * programs such as neato, dot and twopi.
 * 
 * @version $Revision: 1.2 $
 * @author Jean-Daniel Fekete & Mohammad Ghoniem
 */
public class JNodeLinkManager extends GrappaPanel {
	/**
	 * This inner class is intended to handle more events 
	 * than those already handled by a GrappaAdapter, such 
	 * as those generated by buttons, sliders, and other 
	 * components. This makes it possible to customize the
	 * node-link diagram displayed by Grapa through user 
	 * interaction with a control panel.
	 */
	class MyGrappaListener extends GrappaAdapter implements ItemListener,
			ChangeListener {
		//public void grappaPressed(Subgraph subg, Element elem, GrappaPoint pt, int modifiers, GrappaPanel panel){}

		//		    public String grappaTip(Subgraph subg, Element elem, GrappaPoint pt, int modifiers, GrappaPanel panel) {}
		public void actionPerformed(final ActionEvent aev) {
			super.actionPerformed(aev);

			if (aev.getActionCommand().equals("switchMode")) {
				JNodeLinkManager.this.mode = 1 - JNodeLinkManager.this.mode;
				if (JNodeLinkManager.this.hideEdgesWhileBuilding
						& !JNodeLinkManager.this.hideEdges) {
					JNodeLinkManager.this.hideEdges =
						!JNodeLinkManager.this.hideEdges;
					JNodeLinkManager.this.putStyle(
						"invis",
						"" + JNodeLinkManager.this.hideEdges,
						JNodeLinkManager.this.edgeStyleTable);
					JNodeLinkManager.this
						.getGraph()
						.setEdgeAttribute(
							GrappaConstants.STYLE_ATTR,
							JNodeLinkManager.this
								.getStyleString(JNodeLinkManager.this.edgeStyleTable));
					JNodeLinkManager.this.getGraph().repaint();
				}
				return;
			}
			if (aev.getActionCommand().equals("hideNodes")) {
				JNodeLinkManager.this.hideNodes =
					!JNodeLinkManager.this.hideNodes;
				JNodeLinkManager.this.putStyle(
					"invis",
					"" + JNodeLinkManager.this.hideNodes,
					JNodeLinkManager.this.nodeStyleTable);
				JNodeLinkManager.this.getGraph().setNodeAttribute(
					GrappaConstants.STYLE_ATTR,
					JNodeLinkManager.this
						.getStyleString(JNodeLinkManager.this.nodeStyleTable));
			}
			else if (aev.getActionCommand().equals("hideEdges")) {
				JNodeLinkManager.this.hideEdges =
					!JNodeLinkManager.this.hideEdges;
				JNodeLinkManager.this.putStyle(
					"invis",
					"" + JNodeLinkManager.this.hideEdges,
					JNodeLinkManager.this.edgeStyleTable);
				JNodeLinkManager.this.getGraph().setEdgeAttribute(
					GrappaConstants.STYLE_ATTR,
					JNodeLinkManager.this
						.getStyleString(JNodeLinkManager.this.edgeStyleTable));
			}
			else if (aev.getActionCommand().equals("hide/show arrow")) {
				JNodeLinkManager.this.hideArrowHead =
					!JNodeLinkManager.this.hideArrowHead;
				System.out.println("hidden arrow heads : "
						+ JNodeLinkManager.this.hideArrowHead);
				JNodeLinkManager.this.getGraph().setEdgeAttribute(
					"arrowhead",
					JNodeLinkManager.this.hideArrowHead ? "none" : "normal");
				//					Enumeration e = getGraph().edgeElements();
				//					Edge edge = null;
				//					while (e.hasMoreElements()){
				//						edge = (Edge)e.nextElement();
				//						edge.setAttribute("arrowhead", hideArrowHead?"none":"normal");
				//						edge.getGrappaNexus().rebuild();
				//						//edge.buildShape();
				//					}
				JNodeLinkManager.this
					.computeLayout(JNodeLinkManager.this.script);
				//getGraph().buildShapes();
				//getGraph().resync();
				//printAllAttributes();
			}
			JNodeLinkManager.this.getGraph().repaint();
		}

		//public void grappaDragged(Subgraph subg, GrappaPoint currentPt, int currentModifiers, Element pressedElem, GrappaPoint pressedPt, int pressedModifiers, GrappaBox outline, GrappaPanel panel) {}

		public void grappaClicked(
			final Subgraph subg,
			final Element elem,
			final GrappaPoint pt,
			final int modifiers,
			final int clickCount,
			final GrappaPanel panel) {
			if (JNodeLinkManager.this.mode == JNodeLinkManager.NORMAL) {
				super.grappaClicked(
					subg,
					elem,
					pt,
					modifiers,
					clickCount,
					panel);
			}
			else if (clickCount == 1) {
				if (subg.getGraph().isSelectable()) {
					if (modifiers == InputEvent.BUTTON1_MASK) {
						// select element
						if (elem != null) {
							subg.currentSelection = elem;
							JNodeLinkManager.this.addToPath(elem);
							//subg.getGraph().repaint();
						}
					}
					else if (modifiers == (InputEvent.BUTTON1_MASK | InputEvent.CTRL_MASK)) {
						// adjust selection
						if (elem != null) {
							if ((elem.highlight & GrappaConstants.SELECTION_MASK) == GrappaConstants.SELECTION_MASK) {
								// unselect element
								elem.highlight &=
									~GrappaConstants.SELECTION_MASK;
								if (subg.currentSelection == null) {
									// something got messed up somewhere
									throw new InternalError(
										"currentSelection improperly maintained");
								}
								else if (subg.currentSelection instanceof Element) {
									if ((Element) subg.currentSelection != elem) {
										// something got messed up somewhere
										throw new InternalError(
											"currentSelection improperly maintained");
									}
									subg.currentSelection = null;
								}
								else {
									final Vector vec =
										(Vector) subg.currentSelection;
									boolean problem = true;
									for (int i = 0; i < vec.size(); i++) {
										if ((Element) vec.elementAt(i) == elem) {
											vec.removeElementAt(i);
											problem = false;
											break;
										}
									}
									if (problem) {
										// something got messed up somewhere
										throw new InternalError(
											"currentSelection improperly maintained");
									}
								}
							}
							else {
								// select element
								//elem.highlight |= SELECTION_MASK;
								if (subg.currentSelection == null) {
									subg.currentSelection = elem;
								}
								else if (subg.currentSelection instanceof Element) {
									final Object obj = subg.currentSelection;
									subg.currentSelection = new Vector();
									((Vector) subg.currentSelection).add(obj);
									((Vector) subg.currentSelection).add(elem);
								}
								else {
									((Vector) subg.currentSelection).add(elem);
								}
							}
							subg.getGraph().repaint();
						}
					}
				}
			}
		}

		public void grappaReleased(
			final Subgraph subg,
			final Element elem,
			final GrappaPoint pt,
			final int modifiers,
			final Element pressedElem,
			final GrappaPoint pressedPt,
			final int pressedModifiers,
			final GrappaBox outline,
			final GrappaPanel panel) {
		}
		public void itemStateChanged(final ItemEvent ie) {

			final String color = (String) ie.getItem();
			final String iecommand =
				((JComboBox) ie.getSource()).getActionCommand();

			if (iecommand.equals("nodeColor")) {
				JNodeLinkManager.this.getGraph().setNodeAttribute(
					GrappaConstants.COLOR_ATTR,
					color);
			}
			else if (iecommand.equals("edgeColor")) {
				JNodeLinkManager.this.getGraph().setEdgeAttribute(
					GrappaConstants.COLOR_ATTR,
					color);
			}
			JNodeLinkManager.this.getGraph().repaint();
		}
		public void stateChanged(final ChangeEvent cev) {
			JSlider slider = null;
			if (cev.getSource() instanceof JSlider) {
				slider = (JSlider) cev.getSource();
				if (slider.getName().endsWith("linewidthSlider")) {
					if (slider.getName().startsWith("nodes")) {
						JNodeLinkManager.this.putStyle(
							"lineWidth",
							String.valueOf(slider.getValue()),
							JNodeLinkManager.this.nodeStyleTable);
						JNodeLinkManager.this
							.getGraph()
							.setNodeAttribute(
								GrappaConstants.STYLE_ATTR,
								JNodeLinkManager.this
									.getStyleString(JNodeLinkManager.this.nodeStyleTable));
					}
					else if (slider.getName().startsWith("edges")) {
						JNodeLinkManager.this.putStyle(
							"lineWidth",
							String.valueOf(slider.getValue()),
							JNodeLinkManager.this.edgeStyleTable);
						JNodeLinkManager.this
							.getGraph()
							.setEdgeAttribute(
								GrappaConstants.STYLE_ATTR,
								JNodeLinkManager.this
									.getStyleString(JNodeLinkManager.this.edgeStyleTable));
					}
				}
				else if (slider.getName().equals("nodewidthSlider")
						&& !slider.getValueIsAdjusting()) {
					JNodeLinkManager.this.setScaleToFit(false);
					System.out.println("adjusting node size to "
							+ slider.getValue());
					//putStyle("width", String.valueOf(slider.getValue()), nodeStyleTable);
					//putStyle("height", String.valueOf(slider.getValue()), nodeStyleTable);
					JNodeLinkManager.this.getGraph().setNodeAttribute(
						"width",
						String.valueOf(slider.getValue()));
					JNodeLinkManager.this.getGraph().setNodeAttribute(
						"height",
						String.valueOf(slider.getValue()));
					JNodeLinkManager.this
						.computeLayout(JNodeLinkManager.this.script);
					//getGraph().resync();
				}
				JNodeLinkManager.this.getGraph().repaint();
			}
		}
	}
	/**
	 * 
	 */
	private static final long serialVersionUID = 2344222070906952797L;
	public static final String PGM_DOT = "dot";
	public static final String PGM_NEATO = "neato";
	public static final String PGM_TWOPI = "twopi";
	public static final String PGM_EXPORT = "export";

	public static final String PGM_DEFAULT = JNodeLinkManager.PGM_NEATO;
	public static void main(final String[] args) {
		final JFrame frame = new JFrame("node link diagram");
		frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
		final File dotfile =
			new File("D:\\eclipse\\workspace\\oadymppac\\traces\\pndra10_1.dot");
		final JNodeLinkManager man = new JNodeLinkManager(dotfile);
		man.setPreferredSize(new Dimension(300, 300));
		man.setMinimumSize(new Dimension(300, 300));
		man.setMaximumSize(new Dimension(300, 300));
		frame.getContentPane().add(man);
		frame.pack();
		frame.setVisible(true);
	}
	boolean hideNodes = false;

	boolean hideEdges = false;

	boolean hideArrowHead = false;
	// this boolean is intended to make it possible for the user to decide 
	// whether edges should be hidden during path building or not
	boolean hideEdgesWhileBuilding = true;

	static final int PATH_BUILDING = 0;
	static final int NORMAL = 1;
	//	static final int SELECT_NODES = 2;
	//	static final int SELECT_EDGES = 4;

	int mode = JNodeLinkManager.NORMAL;

	int selectableTypes = 0;

	// This table is used to maintain the style of the edges
	// maybe costly if only a few styles are customized
	Hashtable edgeStyleTable = new Hashtable();

	// This table is used to maintain the style of the edges
	// maybe costly if only a few styles are customized
	Hashtable nodeStyleTable = new Hashtable();

	String styleString = "";

	// This set is used to maintain the selected edges
	// while building one or several path(s) in the graph
	LinkedList pathElements = new LinkedList();

	String script = "";

	MyGrappaListener listener = new MyGrappaListener();

	JNodeLinkManager() {
		super(new Graph("Constraint Graph"));
		this.setScaleToFit(true);
		this.getGraph().setEdgeAttribute("arrowsize", "0.5");
		//getGraph().setEdgeAttribute("len", "1.2"); // hack
		this.getGraph().setEdgeAttribute("arrowhead", "normal");
		this.getGraph().setNodeAttribute("label", "");
		this.getGraph().setNodeAttribute("fixedsize", "true");
		this.getGraph().setNodeAttribute("width", "0.1");
		this.getGraph().setNodeAttribute("height", "0.1");

		this.addGrappaListener(this.listener);
	}

	/**
	 * This constructor builds the graph from the passed dot file.
	 * 
	 * @param dotfile
	 */
	JNodeLinkManager(final File dotfile) {
		this();
		this.loadGraph(dotfile);
	}

	/**
	 * Adds an edge between the passed vertices.
	 */
	public void addEdge(final String from, final String to) {
		final Subgraph sub = this.getSubgraph();
		final Node fromNode = this.findNode(from);
		final Node toNode = this.findNode(to);
		this.getGraph().addEdge(new Edge(sub, fromNode, toNode));
	}

	/**
	 * Adds an edge between the passed vertices
	 * with the given weight.
	 */
	public void addEdge(final String from, final String to, final double weight) {
		final Subgraph sub = this.getSubgraph();
		final Node fromNode = this.findNode(from);
		final Node toNode = this.findNode(to);
		final Edge edge = new Edge(sub, fromNode, toNode);
		edge.setAttribute("weight", new Double(weight));
		this.getGraph().addEdge(edge);

	}

	private void addToPath(final Element elem) {
		Edge tmp = null;
		if (elem instanceof Node) {
			if (this.pathElements.size() == 0) {
				elem.highlight = GrappaConstants.SELECTION_MASK;
				this.pathElements.add(elem);
				this.showIncidentEdges((Node) elem, false);
				return;
			}
			if (this.pathElements.getLast() instanceof Node) {
				// Modification the 26 October 2011 by Sébastien Colladon (INF6306) for compatibility with java 1.6
				final Enumeration anEnumeration =
					Edge.findEdgesByEnds(
						(Node) this.pathElements.getLast(),
						(Node) elem);
				if (anEnumeration != null) {
					System.err.println("given nodes are connected.");
					// the enumeration sould contain 1 element at most
					/*int count = 0;
					
					while (enum.hasMoreElements()){
						tmp = (Edge)(enum.nextElement());
						count++;
					}
					System.err.println("number of edges = "+count);	    */
					if (anEnumeration.hasMoreElements()) {
						tmp = (Edge) anEnumeration.nextElement();
					}
					else {
						tmp = null;
					}
				}
				if (tmp != null) {
					tmp.highlight = GrappaConstants.SELECTION_MASK;
					this.pathElements.add(tmp);
					System.out.println("Added element: " + tmp.toString());
				}
				else {
					System.err
						.println("There are no links between these nodes.");
				}
			}
			else {
				System.err
					.println("Something went wrong while building the path.");
			}
			if (!this.inpath(elem)) {
				elem.highlight = GrappaConstants.SELECTION_MASK;
				this.pathElements.add(elem);
			}
			else if (this.pathElements.getLast() != elem) {
				// here we allow a node to appear several times in the path
				// but not several times in a row
				this.pathElements.add(elem);
			}
			this.showIncidentEdges((Node) elem, false);
			this.showIncidentEdges(this.nodeBeforeLast(), true);
			System.out.println("Added element: " + elem.toString());
			this.getGraph().repaint();
		}
		else {
			System.err.println("edges are not added manually!");
		}
		System.out.println("number of elements in path = "
				+ this.pathElements.size());
	}

	/**
	 * Compute the layout of the graph using DOT or NEATO and reload it
	 *
	 * @param the graph layout program to call
	 */
	public void computeLayout(final String SCRIPT) {
		this.script = SCRIPT;
		final Graph graph = this.getGraph();
		Object connector = null;

		try {
			if (this.script != JNodeLinkManager.PGM_EXPORT) {
				connector = Runtime.getRuntime().exec(SCRIPT);
			}
		}
		catch (final Exception ex) {
			System.err.println("Exception while setting up Process: "
					+ ex.getMessage() + "\nTrying URLConnection...");
			connector = null;
		}

		if (connector == null) {
			try {
				connector =
					new URL(
						"http://www.research.att.com/~john/cgi-bin/format-graph")
						.openConnection();

				final URLConnection urlConn = (URLConnection) connector;
				urlConn.setDoInput(true);
				urlConn.setDoOutput(true);
				urlConn.setUseCaches(false);
				urlConn.setRequestProperty(
					"Content-Type",
					"application/x-www-form-urlencoded");
			}
			catch (final Exception ex) {
				System.err.println("Exception while setting up URLConnection: "
						+ ex.getMessage() + "\nLayout not performed.");
				connector = null;
			}
		}

		if (connector != null) {
			synchronized (graph) {
				if (!GrappaSupport.filterGraph(graph, connector)) {
					System.err.println("ERROR: somewhere in filterGraph");
				}

				if (connector instanceof Process) {
					try {
						final int code = ((Process) connector).waitFor();

						if (code != 0) {
							System.err.println("WARNING: proc exit code is: "
									+ code);
						}
					}
					catch (final InterruptedException ex) {
						System.err
							.println("Exception while closing down proc: "
									+ ex.getMessage());
						ex.printStackTrace(System.err);
					}
				}

				connector = null;
			}
		}

		graph.repaint();
	}
	public void exportFile(final String filename) {
		final Graph graph = this.getGraph();
		try {
			final FileOutputStream out = new FileOutputStream(filename);
			graph.printGraph(out);
		}
		catch (final FileNotFoundException ex) {
			ex.printStackTrace();
		}
	}

	/**
	 * Returns the node having the passed name
	 * and creates it if necessary.
	 */
	public Node findNode(final String name) {
		Node node = this.getSubgraph().findNodeByName(name);
		if (node == null) {
			node = new Node(this.getSubgraph(), name);
		}
		return node;
	}
	/**
	 * DOCUMENT ME!
	 * 
	 * @return DOCUMENT ME!
	 */
	public Graph getGraph() {
		return this.getSubgraph().getGraph();
	}
	public MyGrappaListener getGrappaListener() {
		return this.listener;
	}
	private String getStyleString(final Hashtable t) {
		final Enumeration e = t.keys();
		this.styleString = "";
		String key;
		while (e.hasMoreElements()) {
			key = (String) e.nextElement();
			this.styleString += key + "(" + (String) t.get(key) + "),";
		}
		//System.out.println("style is: "+styleString);
		return this.styleString;
	}
	private boolean inpath(final Element elem) {
		//System.out.println("number of elements in path: "+pathElements.size());
		return this.pathElements.contains(elem);
	}
	public boolean isTypeSelectable(final int elementType) {
		return (Grappa.elementSelection & elementType) == elementType;
	}
	public void loadGraph(final File dotfile) {
		try {
			final FileInputStream fis = new FileInputStream(dotfile);
			final Parser parser =
				new Parser(new InputStreamReader(fis), new PrintWriter(
					System.out), this.getGraph());
			parser.parse();
		}
		catch (final FileNotFoundException fex) {
			fex.printStackTrace();
		}
		catch (final Exception e) {
			e.printStackTrace();
		}

	}

	//	private void printAttributes(int type) {
	//		Enumeration enum;
	//		switch (type) {
	//			case Grappa.NODE :
	//				enum = getGraph().getNodeAttributePairs();
	//				break;
	//			case Grappa.EDGE :
	//				enum = getGraph().getEdgeAttributePairs();
	//				break;
	//			case Grappa.SUBGRAPH :
	//				enum = getGraph().getAttributePairs();
	//				break;
	//			default :
	//				enum = null;
	//		}
	//		if (enum == null)
	//			return;
	//		while (enum.hasMoreElements()) {
	//			System.out.println(enum.nextElement().toString());
	//		}
	//	}
	//	private void printAllAttributes() {
	//		printAttributes(Grappa.NODE);
	//		printAttributes(Grappa.EDGE);
	//		printAttributes(Grappa.SUBGRAPH);
	//	}
	public void makeTypeSelectable(
		final boolean selectable,
		final int elementType) {
		if ((elementType & (GrappaConstants.NODE | GrappaConstants.EDGE)) != elementType) {
			return;
		}
		if (selectable) {
			Grappa.elementSelection |= elementType;
		}
		else {
			Grappa.elementSelection -= elementType;
		}
	}

	private Node nodeBeforeLast() {
		final Element elem =
			(Element) this.pathElements.get(this.pathElements.size() - 2);
		if (elem instanceof Node) {
			return (Node) elem;
		}
		else {
			return (Node) this.pathElements.get(this.pathElements.size() - 3);
		}
	}

	private void putStyle(
		final String keyword,
		final String value,
		final Hashtable t) {
		t.put(keyword, value);
	}

	//	private void removeFromPath(Element elem) {
	//		elem.highlight &= ~HIGHLIGHT_MASK;
	//		pathElements.remove(elem);
	//		getGraph().repaint();
	//	}
	//	private void clearPath() {
	//		Element elem;
	//		for (Iterator i = pathElements.iterator(); i.hasNext();) {
	//			elem = (Element) i.next();
	//			elem.highlight &= ~HIGHLIGHT_MASK;
	//			if (elem instanceof Edge) {
	//				elem.setAttribute(GrappaConstants.STYLE_ATTR, "invis(true)");
	//			}
	//		}
	//		pathElements.clear();
	//		getGraph().repaint();
	//	}
	private void showIncidentEdges(final Node n, final boolean invisible) {
		final Enumeration edges = n.edgeElements();
		Edge tmp = null;
		while (edges.hasMoreElements()) {
			tmp = (Edge) edges.nextElement();
			if (!this.inpath(tmp)) {
				tmp.setAttribute(GrappaConstants.STYLE_ATTR, "invis("
						+ invisible + ")");
			}
		}
		this.getGraph().repaint();
	}
}