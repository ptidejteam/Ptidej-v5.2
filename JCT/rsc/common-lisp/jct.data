#|
Licensed under 3-clause BSD License:
Copyright © 2009, Mathieu Lemoine
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
 * Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
 * Neither the name of Mathieu Lemoine nor the
   names of contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mathieu Lemoine ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mathieu Lemoine BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
\(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION\) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\(INCLUDING NEGLIGENCE OR OTHERWISE\) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
|#

#+(or) (progn
         (require :meta-model-generator)
         (require :transformations-generator)
         (use-package :alexandria)
         (use-package :license-generation)
         (use-package :code-generation) 
         (progn
           (shadowing-import 'meta-model-generation:flatten)
           (use-package :meta-model-generation))
         (use-package :transformations-generation)
         (use-package :transformations)
         (use-package :license-generation))

(cl:eval-when (:compile-toplevel :load-toplevel :execute)
  (cl:when (cl:not (cl:find-package :jct-data))
    (cl:defpackage #:jct-data
      (:use #:cl #:restricted-list)
      (:import-from #:xt-pattern
                    #:match)
      (:import-from #:alexandria
                    #:conjoin #:disjoin #:curry #:compose #:when-let))))

(cl:in-package #:jct-data)

(defmacro when-package (package-names &body body)
  (when
      (if (listp package-names)
          (every #'find-package package-names)
          (find-package package-names))
    `(progn
       ,@body)))

(eval-when (:compile-toplevel :load-toplevel :execute)
  (macrolet ((use-if-existing (&rest package-names)
               `(progn
                  ,@(mapcar (lambda (package-name)
                              `(when-package ,package-name
                                 (use-package ,package-name)))
                            package-names))))
    (use-if-existing :code-generation :meta-model-generation :transformations
                     :transformations-generation :xsd-dtd-transformations)))

(when-package (#:code-generation #:meta-model-generation)
  (defMMfun generate-constituent-class-name (name)
    (format nil "IJCT~A"
            (generate-programmatic-name name)))

  (defMMfun get-constituent-field-class (field &optional (bare-type-p t))
    (with-accessors ((type mm-field-type)
                     (flags mm-field-flags))
        field
      (let ((container-p (member :container flags))
            (nullable-p  (member :nullable  flags)))
        (if (not (constituent-p type))
            type
            (let* ((class (resolve-type-name (mm-type->java-type type) t))
                   (class (if (member :selector flags)
                              (format nil "IJCTSelector<~A>" class)
                              class)))
              #T("jct.kernel"
                 (if (or bare-type-p (not container-p))
                     class
                     (format nil "~:[Not~;~]NullableReference<~A>" nullable-p class))))))))

  (defMMfun generate-atom-field-initialization (field)
    (with-accessors ((flags mm-field-flags)) field
      (or (mm-field-default field)
          (when (member :nullable flags)
            (if (member :container flags)
                (generate-method-call "this" () nil "createNullableInternalReference")
                "null")))))

  (defMMfun generate-list-field-initialization (field)
    (or (mm-field-default field)
        (when (member :container (mm-field-flags field))
          (generate-method-call "this" () nil "createInternalList"))))

  (defMMfun generate-set-field-initialization (field)
    (or (mm-field-default field)
        (when (member :container (mm-field-flags field))
          (generate-method-call "this" () nil "createInternalSet"))))

  (defMMfun generate-create-arguments-from-constructor (constructor-arguments)
    (rest constructor-arguments))

  (defMMfun generate-in-create-constructor-agruments (constructor-arguments)
    `(,(get-member "original root node")
       ,@(mapcar #'second (rest constructor-arguments))))

  (defMMfun generate-constituent-interface-imports (constituent)
    (remove-duplicates
     (append
      (let ((get-source-code-method (car (member "getSourceCode" (mm-constituent-methods constituent)
                                                 :key (compose #'java-method-name #'java-method-signature)
                                                 :test #'string=))))
        (when (and
               get-source-code-method
               (not (member :impl-only
                            (java-method-flags (java-method-signature get-source-code-method)))))
          '(nil "java.io.Writer" "java.io.IOException")))
      (when (remove-if (compose
                        (disjoin (compose #'not (curry #'member :set))
                                 (curry #'member :no-accessor)
                                 (curry #'member :implementation-only-accessor))
                        #'mm-field-flags)
                       (mm-constituent-fields constituent))
        '(nil "java.util.Set"))
      (when (remove-if (compose
                        (disjoin (compose #'not (curry #'member :list))
                                 (curry #'member :no-accessor)
                                 (curry #'member :implementation-only-accessor))
                        #'mm-field-flags)
                       (mm-constituent-fields constituent))
        '(nil "java.util.List")))
     :test (lambda (a b) (when (string= a b) a))))

  (defMMfun generate-constituent-implementation-imports (constituent)
    (with-accessors ((name   mm-constituent-name)
                     (fields mm-constituent-fields)
                     (flags  mm-constituent-flags)) constituent
      (remove-duplicates
       (append
        (when (member name '("Arithmetic Binary Operator" "Array Type" "Class" "Class Type"
                             "Compilation Unit" "Conditional Operator" "Intersection Type"
                             "Method" "New Array" "Root Node" "String Literal")
                      :test #'string=)
          '("jct.kernel.Constants"))
        (unless (member name '("Path" "Root Node" "Path Part Builder" "File Offset Path")
                        :test #'string=)
          '("jct.kernel.IJCTRootNode"))
        (unless (or
                 (member :abstract flags)
                 (string-equal name "File Offset Path"))
          '("jct.kernel.JCTKind"))
        (unless (or
                 (member :abstract flags)
                 (member name '("Path" "Path Part" "Path Part Builder" "File Offset Path")
                         :test #'string=))
          '("jct.kernel.IJCTVisitor"))
        nil
        (mapcar (lambda (field)
                  (with-accessors ((type mm-field-type)) field
                    (when (constituent-p type)
                      (generate-type-FQN (mm-type->java-type type)))))
                fields)
        (when (and (mm-constituent-name constituent)
                   (not (string= "Element" name))
                   (member "getSourceCode" (mm-constituent-methods constituent)
                           :key (compose #'java-method-name #'java-method-signature)
                           :test #'string=))
          '(nil "java.io.Writer" "java.io.IOException"))
        (when (remove-if (compose #'not (curry #'member :set) #'mm-field-flags) fields)
          '(nil "java.util.Set" "java.util.Collections"))
        (when (remove-if (compose #'not (curry #'member :list) #'mm-field-flags) fields)
          '(nil "java.util.List" "java.util.Collections"))
        (when (>= (length
                   (remove-if (compose (disjoin (compose #'not (curry #'member :container))
                                                (curry #'member :intrf-only))
                                        #'mm-field-flags)
                              fields))
                  2)
          '(nil "util.collection.IndirectCollection"))
        (let ((atom-container-fields (remove-if (compose
                                                 (disjoin (compose #'not (curry #'member :container))
                                                          (curry #'member :list)
                                                          (curry #'member :set))
                                                 #'mm-field-flags)
                                                fields)))
          (when atom-container-fields
            (append
             (when (remove-if (compose #'not (curry #'member :nullable) #'mm-field-flags)
                              atom-container-fields)
               '(nil "util.reference.NullableReference"))
             (when (remove-if (compose (curry #'member :nullable) #'mm-field-flags)
                              atom-container-fields)
               '(nil "util.reference.NotNullableReference"))))))
       :test (lambda (a b) (when (string= a b) a)))))

  (defMMfun generate-factory-create-method-body (constituent-name class-name constructor-arguments)
    (if (member constituent-name '("Class Type" "Primitive Type" "Array Type" "Intersection Type")
                :test #'string=)
        `(,(format nil "return new ~A(~{~A~^, ~});" class-name constructor-arguments))
        `(,(format nil "final ~A result = new ~@*~A(~{~A~^, ~});" class-name constructor-arguments)
           ,(format nil "~A;"
                    (generate-method-call (get-member "original root node")
                                          '("result") nil
                                          "addOrphan" '(("IJCTElement" "element"))))
           "return result;"))))


(when-package #:meta-model-generation
  (deftype-list-of mm-type)
  (deftype-list-of java-comment)

  (declaim (ftype (function (string string string (or mm-type null)
                                    (list-of mm-type)
                                    (list-of java-comment)
                                    java-method)
                            (values mm-constituent &optional))
                  generate-sub-constituent-spec))
  (defun generate-sub-constituent-spec (name date author extends super-implements description constructor)
    (create-mm-constituent name () extends super-implements () () date author description () `(,constructor)))

  (declaim (ftype (function (mm-type string &rest string)
                            (values string &optional))
                  generate-backpatch-call))
  (defun generate-backpatch-call (type arg1 &rest args)
    (let ((args (if (null args)
                    arg1
                    (format nil "new IndirectCollection<~A>(~{~A~^, ~})"
                            (java-type-name (mm-type->java-type type))
                            (cons arg1 args)))))
      (format nil "~A;"
              (generate-method-call "super" `(,args) nil
                                    "backpatchElements" '(("Collection" "c")))))))

(when-package #:code-generation
  (defvar *enums*)
  (defvar *interfaces*)
  (defvar *visitor*)
  (defvar *factory*))

(when-package #:meta-model-generation
  (defparameter *model-symbol* 'jct)
  (defparameter *model-package* "jct.kernel"))

(when-package #:transformations
  (defparameter *default-transformation*
    (create-default-mm-transformation "Transformation" "2009-06-02 (火)" "Mathieu Lemoine"))

  (defparameter *base-transformation-interface*
    (create-java-type "ptntt.transformation.kernel" "ITransformation"))
  (defparameter *base-transformation-interface-need-model* t)

  (defparameter *base-transformation-implementation*
    (create-java-type "ptntt.transformation.kernel.impl" "AbstractTransformation"))
  (defparameter *base-transformation-implementation-need-model* t)

  (defparameter *model-class*
    #T("jct.transformation.util" "TransformableRootNode"))

  (defparameter *model-path-class*
    #T('jct "Path"))

  (defparameter *model-kind-class*
    (create-java-type "jct.kernel" "JCTKind"))

  (defparameter *generate-create-path-to-root-node*
    "new jct.kernel.impl.JCTPath()")

  (defparameter *transformation-factory*
    (create-mm-factory
     "Factory" ()
     '("java.io.File"
       nil "jct.kernel.IJCTRootNode" "jct.kernel.IJCTPath"
       "jct.kernel.IJCTClassMember" "jct.kernel.IJCTIdentifiable" "jct.kernel.JCTModifiers"
       nil "jct.transformation.util.TransformableRootNode")
     '("java.io.File"
       nil "jct.kernel.IJCTRootNode" "jct.kernel.IJCTPath"
       "jct.kernel.IJCTClassMember" "jct.kernel.IJCTIdentifiable" "jct.kernel.JCTModifiers"
       nil "jct.transformation.util.TransformableRootNode")
     "2009-05-08 (金)" "Mathieu Lemoine"
     '("This interface is a factory for creating transformations on JCT instances.")))

  (defparameter *transformation-visitor*
    (create-mm-visitor
     "Visitor" ()
     '("jct.kernel.IJCTIdentifiable" "jct.kernel.IJCTClassMember")
     "2009-06-01 (月)" "Mathieu Lemoine"
     '("This interface is a default for a Visiting facility")))
  
  (defparameter *transformation-with-origin-interface*
    (create-java-type "jct.transformation.util" "IWithOriginTransformation"))

  (defparameter *transformation-with-origin-interface-need-model* nil)

  (defparameter *transformation-with-destination-interface*
    (create-java-type "jct.transformation.util" "IWithDestinationTransformation"))

  (defparameter *transformation-with-destination-interface-need-model* nil))

(when-package #:xsd-dtd-transformations
  (defparameter *xmlns*
    "http://www-etud.iro.umontreal.ca/maitrise/xsd/jct-transformations.xsd")

  (defparameter *xmlns-prefix*
    "jct-trans")

  (defparameter *descriptions-lines*
    '("This XML-Schema defines the format of JCT transformations XMLs."))

  (defparameter *imports* nil))

(when-package #:meta-model-generation
  (let ((*print-pretty* nil)
        (+author+ "Mathieu Lemoine")
        (*path-to-helpers* "/home/swoog/docs/boulot/UdeM/Maitrise/JCT/rsc/file-helpers/"))
    #+ (or) (defparameter *constituents*
              (flet ((test (n)
                       (create-mm-constituent
                        (format nil "test ~A" n)
                        () nil () () ()
                        "2008-12-03 (水)"
                        +author+
                        `(,(format nil "W00~A" (+ 6 n)))
                        (list
                         (create-mm-field "00 Atom Int 00"            "int")
                         (create-mm-field "01 Atom Const 01"          '(jct "01"))
                         (create-mm-field "02 Atom Null Const 02"     '(jct "02") :nullable)
                         (create-mm-field "03 Atom Container 03"      '(jct "03") :container)
                         (create-mm-field "04 Atom Null Container 04" '(jct "04") :nullable :container)

                         (create-mm-field "05 List Int 05"            "int"       :list)
                         (create-mm-field "06 List Const 06"          '(jct "06") :list)
                         (create-mm-field "07 List Container 07"      '(jct "07") :list :container)

                         (create-mm-field "08 Set Int 08"             "int"       :set)
                         (create-mm-field "09 Set Const 09"           '(jct "09") :set)
                         (create-mm-field "10 Set Container 10"       '(jct "10") :set :container)

                         (create-mm-field-w/default "11 Atom Default Int 11" "int" "11"))
                        ())))
                (list (test 1) #+(or)(test 2))))

    #+ (and) (defparameter *constituents*
               (append
                (list
                 (create-mm-constituent-full
                  "Element" () '(("Component" "extends IJCTElement"))
                  #T("jct.util" "AbstractJCTContainer" '(("Component")))
                  ()
                  nil
                  '("java.io.StringWriter" "java.io.IOException"
                    nil
                    "java.util.Iterator" "java.util.Collection"
                    "java.util.List" "java.util.LinkedList"
                    nil
                    "java.lang.ref.SoftReference"
                    nil nil
                    "jct.util.AbstractJCTContainer" "jct.kernel.IJCTVisitor")
                  "2008-08-16 (土)" +author+
                  '("Basic interface representing an element of a JCT (JavaC bound abstract syntax Tree)")
                  (list
                   (create-mm-field "Enclosing Element" #T("jct.kernel.impl" "JCTElementContainer" '(("?"))) :no-accessor)
                   (create-mm-field "Root Node"         #T('jct "root node") :no-accessor :final)
                   (create-mm-field "Name"              #T(nil "String")     :implementation-only-accessor :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTElement" '(("IJCTRootNode" "aRootNode")))
                    '("this(aRootNode, null);")
                    '("Non-Identifiable constructor"))
                   (create-whole-java-method
                    (() nil "JCTElement" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    '("this.rootNode = null == aRootNode && this instanceof IJCTRootNode ? (IJCTRootNode) this : aRootNode;"
                      "this.name = name;")
                    '("Identifiable constructor"))
                   (create-whole-java-method
                    ('(:public) #J(nil "JCTKind") "getKind")
                    :abstract
                    '("Returns the kind of the element"))
                   (create-whole-java-method
                    ('(:public) #J(nil "R") "accept" '(("IJCTVisitor<R, P>" "v") ("P" "p")) (mapcar #'create-java-generic '("R" "P")))
                    :abstract
                    '("Accepts a visitor (calls the appropriate visit* Method)"))
                   (create-whole-java-method
                    ('(:public) #J(nil "R") "accept" '(("IJCTVisitor<R, P>" "v")) (mapcar #'create-java-generic '("R" "P")))
                    '("return this.accept(v, null);")
                    '("Accepts a visitor, using using {@code null} as additional parameter."))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTElement") "getEnclosingElement")
                    (list (format nil "return ~A;" (get-member "Enclosing Element")))
                    '("Returns the enclosing element"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTRootNode") "getRootNode")
                    `(,(format nil "return ~A;" (get-member "Root Node")))
                    '("Returns the RootNode of the model this element is refering to."
                      "Invariant: {@code this.getRootNode() == this.getRootNode().getRootNode()}"))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getID")
                    '("return super.toString();")
                    '("Returns a unique ID for this element."))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getSourceCode")
                    `("try"
                      "{"
                      ,(format nil "    return ~A;" (generate-method-call
                                                     (generate-method-call
                                                      "this" '("new StringWriter()") nil
                                                      "getSourceCode" '(("Writer" "w"))) () nil
                                                     "toString"))
                      "}"
                      "catch(final IOException e) { throw new RuntimeException(e); }")
                    '("Returns the textual representation of the expression as if it was within the source code"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "w")) () '("IOException"))
                    :abstract
                    '("Writes the textual representation in the stream."))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "toString")
                    :abstract
                    '("Returns string representation of the path to this constituent"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPath") "getPath")
                    :abstract
                    '("Returns the path to this element"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Collection" `(,(create-java-generic "Component"))) "getEnclosedElements" () () () :impl-only)
                    '("throw new UnsupportedOperationException(\"It is impossible to extract enclosed elements from a leaf.\");")
                    '("Unsupported Operation because the interface does not specify it.")))
                  "jct.kernel.impl.JCTElement.java"
                  :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Element Container" '(("Element" "extends IJCTElement"))
                  #T('jct "Element" '(("Element")))
                  `(,#T('jct "Element"))
                  ()
                  '("java.util.List" "java.util.ListIterator"
                    "java.util.Set" "java.util.AbstractSet" "java.util.HashSet"
                    "java.util.Iterator" "java.util.Collection" "java.util.Collections"
                    nil "util.collection.ListOfUnique" "jct.util.ListOfElements"
                    "util.reference.StrongReference" "util.reference.NullableReference"
                    "util.reference.NotNullableReference"
                    nil "java.lang.reflect.Field" "java.io.Serializable"
                    nil "jct.kernel.IJCTElement" "jct.kernel.JCTKind")
                  "2008-09-30 (火)" +author+
                  '("This class represents the composite role of the composite DP"
                    "It is strongly recommended that the implementations of this interface implements also {@link jct.util.IJCTContainer}")
                  (list (create-mm-field "elements" #T("java.util" "Collection" '(("Element"))) :protected :no-accessor :final))
                  (list
                   (create-whole-java-method
                    (() nil "JCTElementContainer" '(("IJCTRootNode"        "aRootNode")
                                                    ("String"              "name")
                                                    ("Collection<Element>" "elements")))
                    `("super(aRootNode, name);"
                      ,(format nil "~A = elements;" (get-member "element" t)))
                    '("Identifiable contructor"))
                   (create-whole-java-method
                    (() nil "JCTElementContainer" '(("IJCTRootNode"        "aRootNode")
                                                    ("Collection<Element>" "elements")))
                    '("super(aRootNode);"
                      "this.elements = elements;")
                    '("Non-Identifiable constructor"))
                   (create-whole-java-method
                    (() nil "JCTElementContainer" '(("IJCTRootNode"        "aRootNode")
                                                    ("String"              "name")))
                    '("this(aRootNode, name, null);")
                    '("Identifiable contructor with backpatch enclosed elements"))
                   (create-whole-java-method
                    (() nil "JCTElementContainer" '(("IJCTRootNode"        "aRootNode")))
                    '("this(aRootNode, (Collection<Element>)null);")
                    '("Non-Identifiable constructor with backpatch enclosed elements"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Collection" `(,(create-java-generic "Element"))) "getEnclosedElements" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call "Collections"
                                                     `(,(format nil "null == ~A ? new HashSet<Element>() : ~@*~A"
                                                                (get-member "element" t)))
                                                     nil
                                                     "unmodifiableCollection" '(("Collection" "aColllection")))))
                    '("Returns an unmodifiable Collection of enclosed elements."))
                   (create-whole-java-method
                    ('(:protected) #J(nil "ListOfElements" `(,(create-java-generic "T"))) "seeNextPathStep" '(("JCTKind" "aKind")) `(,(create-java-generic "T" "extends IJCTElement")))
                    `("final ListOfElements<T> result = new ListOfElements<T>();"
                      ,(format nil "for(final Element e : ~A)"
                               (generate-method-call "this" () nil "getEnclosedElements"))
                      ,(format nil "    if(null != e && aKind == ~A)"
                               (generate-method-call "e" () nil "getKind"))
                      ,(format nil "        ~A;"
                               (generate-method-call "result" '("e") t "add" '(("T" "element"))))
                      "return result;")
                    '("Returns the List of elements potentialy designated by a next path part on this kind.")))
                  "jct.kernel.impl.JCTElementContainer.java"
                  :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Root Node" ()
                  #T('jct "Element Container" '(("IJCTPackage")))
                  `(,#T('jct "Element Container" '(("IJCTPackage"))))
                  ()
                  '("java.lang.ref.SoftReference" "java.lang.ref.WeakReference" "java.lang.reflect.Field"
                    nil "util.equiv.Identity"
                    nil "java.io.StringWriter" "java.io.Serializable"
                    nil "jct.util.ListOfElements" "util.collection.ListOfUnique" "util.collection.IndirectCollection"
                    nil "java.util.Map" "java.util.HashMap" "java.util.Iterator" "java.util.Collection" "java.util.HashSet" "java.util.ListIterator"
                    nil "jct.kernel.IJCTFactory" "jct.kernel.IJCTClass" "jct.kernel.IJCTPath"
                    "jct.kernel.IJCTType" "jct.kernel.IJCTPrimitiveType" "jct.kernel.IJCTArrayType"
                    "jct.kernel.IJCTIntersectionType" "jct.kernel.IJCTClassType"
                    "jct.kernel.JCTPrimitiveTypes")
                  "2008-12-02 (火)" +author+
                  '("This class represents the root node of the tree")
                  (list
                   (create-mm-field "package" #T('jct "package")              :container :set)
                   (create-mm-field "factory" #T("java.lang.ref" "SoftReference" '(("IJCTFactory"))) :no-accessor :transient)
                   (create-mm-field-w/default "orphan" #T('jct "Element") "ListOfElements.decorateList(new OrphanList())" :list :no-transformation)
                   (create-mm-field-w/default "initialized" #T(nil "boolean") "false" :no-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTRootNode" '(("String" "name")))
                    `("super(null, name, null);"
                      ,(format nil "~A = new SoftReference<IJCTFactory>(null);" (get-member "factory"))
                      ,(generate-backpatch-call #T('jct "Package") (get-member "package" t)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTElement") "walk" '(("IJCTPath" "aPath")))
                    `(,(format nil "return ~A;"
                               (generate-method-call "aPath" '("this") nil
                                                     "walk" '(("IJCTRootNode" "aRootNode")))))
                    '("Returns the element within the model."
                      "There is a difference between knowing the path and walking the path..."
                      "Equivalent to {@code aPath.walk(this);}."))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTFactory") "getFactory")
                    `(,(format nil "IJCTFactory f = ~A;"
                               (generate-method-call (get-member "factory") () nil "get"))
                       ""
                       "if(null == f)"
                       ,(format nil "    ~A = new SoftReference<IJCTFactory>(f = new JCTFactory(this));"
                                (get-member "factory"))
                       "return f;")
                    '("Returns the Factory associated to this JCT"))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getName")
                    :abstract
                    '("Returns the name of the JCT."
                      "This data is purely informative"))
                   (create-whole-java-method
                    ('(:public) #J(nil "T") "getType" '(("String" "path") ("Class<T>" "typeClass")) `(,(create-java-generic "T" "extends IJCTType")))
                    :abstract
                    '("Returns the intersection of the types")
                    ()
                    "null iff the type can not be found")
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getType" '(("IJCTType..." "types")))
                    :abstract
                    '("Returns the intersection of the types")
                    ()
                    "null iff the type can not be found")
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTArrayType") "registerArrayType" '(("IJCTType" "underlyingType")))
                    `(,(format nil "return ~A;"
                               (generate-method-call "this"
                                                     '("underlyingType" "null") nil
                                                     "registerArrayType" '(("IJCTType" "underlyingType")
                                                                           ("String" "underlyingTypeName")))))
                    '("Roughly equivalent to {@code this.registerArrayType(underlyingType, null);}."))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTArrayType") "registerArrayType" '(("IJCTType" "underlyingType") ("String" "underlyingTypeName")))
                    :abstract
                    '("Register a new array type, if it does not exists already.")
                    '("underlyingTypeName the name used to register the array type, if null, {@code underlyingType.getTypeName()} will be used.")
                    "the associated array type.")
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPrimitiveType") "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))
                    `(,(format nil "IJCTPrimitiveType t = ~A;"
                               (generate-method-call (get-member "Primitive Type" t)
                                                     '("aPrimitiveTypeConstant") nil
                                                     "get" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant"))))
                       ""
                       "if(null == t)"
                       ,(format nil "    ~A;"
                                (generate-method-call (get-member "Primitive Type" t)
                                                      `("aPrimitiveTypeConstant"
                                                        ,(format nil "t = new JCTPrimitiveType(this, aPrimitiveTypeConstant)"))
                                                      nil "put" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")
                                                                  ("IJCTPrimitiveType" "aPrimitiveType"))))
                       ""
                       "return t;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getSourceCode")
                    :abstract
                    '("Returns the textual representation."
                      "0x1D (Group Separator) Unicode Character is used to separate packages."))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException"))
                    `(,(format nil "for(final IJCTPackage p : ~A)"
                               (generate-method-call "this" () nil "getPackages"))
                       ,(format nil "    ~A;"
                                (generate-method-call "p" '("aWriter") nil
                                                      "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       "return aWriter;")
                    '("Writes the textual representation in the stream,"
                      "the separators are not wrote in the writer."))
                   (create-whole-java-method
                    ('(:protected :final) #J(nil "JCTPathPartBuilder") "createPathPart")
                    '("return super.createPathPart().setKind(null);")
                    '("Returns the path to the root node."))
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isInitialized")
                    '("return this.initialized;")
                    '("Returns wether this root node has been initialized or not"))
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "assumeInitialized")
                    '("this.initialized = true;")
                    '("From now, this root node will assume that is has been initialized")))
                  "jct.kernel.impl.JCTRootNode.java"
                  :no-create/delete-transformation :root-node)
                 (create-mm-constituent-w/impl-file-helper
                  "Renamed Root Node" () nil
                  `(,#T('jct "Root Node") ,#T('jct "Container" '(("IJCTPackage"))))
                  ()
                  '("java.lang.ref.SoftReference"
                    nil "java.util.Collection" "java.util.Set" "java.util.List"
                    nil "jct.util.IJCTContainer"
                    nil "jct.kernel.IJCTPackage" "jct.kernel.IJCTFactory" "jct.kernel.IJCTElement"
                    "jct.kernel.IJCTPath" "jct.kernel.IJCTArrayType"
                    "jct.kernel.IJCTType" "jct.kernel.IJCTPrimitiveType" "jct.kernel.JCTPrimitiveTypes")
                  "2008-10-15 (水)" +author+
                  '("Implementation of a renamed {@link jct.kernel.IJCTRootNode}"
                    ""
                    "Implemented as a Decorator.")
                  (list
                   (create-mm-field "original" #T('jct "Root Node") :final :no-accessor)
                   (create-mm-field "name"     #T(nil "String")           :final :no-accessor)
                   (create-mm-field "factory"  #T("java.lang.ref" "SoftReference<IJCTFactory>") :no-accessor :transient))
                  (append
                   (list
                    (create-whole-java-method
                     (() nil "JCTRenamedRootNode" '(("IJCTRootNode" "originalRootNode") ("String" "name")))
                     `(,(format nil "~A = ~A;"
                                (get-member "original")
                                (generate-method-call "originalRootNode" () nil "getRootNode"))
                        ,(format nil "~A = name;" (get-member "name"))
                        ,(format nil "~A = new SoftReference<IJCTFactory>(null);"
                                 (get-member "factory")))
                     ())
                    (create-whole-java-method
                     ('(:public) #J(nil "IJCTFactory") "getFactory")
                     `(,(format nil "IJCTFactory f = ~A;"
                                (generate-method-call (get-member "factory") () nil "get"))
                        ""
                        "if(null == f)"
                        ,(format nil "    ~A = new SoftReference<IJCTFactory>(f = new JCTFactory(this));"
                                 (get-member "factory"))
                        "return f;")
                     '("Returns the Factory associated to this JCT"))
                    (create-whole-java-method
                     ('(:public) #J(nil "String") "getName")
                     `(,(format nil "return ~A;" (get-member "name")))
                     '("Returns the name of the JCT."
                       "This data is purely informative"))
                    (create-whole-java-method
                     ('(:public) #J(nil "boolean") "equals" '(("Object" "o")))
                     `("return (o instanceof IJCTRootNode)"
                       ,(format nil "       && ~A;"
                                (generate-method-call
                                 (generate-method-call "((IJCTRootNode)o)" () nil "getRootNode")
                                 `(,(generate-method-call "this" () nil "getRootNode"))
                                 nil "equals" '(("Object" "o")))))
                     ())
                    (create-whole-java-method
                    ('(:public) #J(nil "R") "accept" '(("IJCTVisitor<R, P>" "v")) (mapcar #'create-java-generic '("R" "P")))
                    '("return this.accept(v, null);")
                    '("Accepts a visitor, using using {@code null} as additional parameter.")))
                   (mapcar (curry #'apply
                                  (lambda (return-type name
                                           &optional arguments generics throws
                                           description-lines)
                                    (create-whole-java-method
                                     ('(:public) #J(nil return-type) name arguments generics throws)
                                     `(,(format nil "~:[return ~;~]~A;"
                                                (string= "void" return-type)
                                                (generate-method-call (get-member "original")
                                                                      (mapcar #'second arguments) nil
                                                                      name arguments)))
                                     description-lines)))
                           `(("IJCTPrimitiveType" "getType"       (("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))
                             ("IJCTType"          "getType"       (("IJCTType..." "types")))
                             ("T"                 "getType"       (("String" "path") ("Class<T>" "typeClass")) (,(create-java-generic "T" "extends IJCTType")))
                             ("IJCTElement"       "getEnclosingElement")
                             ("R"                 "accept"        (("IJCTVisitor<R, P>" "aVisitor") ("P" "p")) ,(mapcar #'create-java-generic '("R" "P")))
                             ("JCTKind"           "getKind")
                             ("IJCTRootNode"      "getRootNode")
                             ("boolean"           "isInitialized")
                             ("void"              "assumeInitialized")
                             ("void"              "addPackage"    (("IJCTPackage" "aPackage")))
                             ("void"              "removePackage" (("IJCTPackage" "aPackage")))
                             ("Set<IJCTPackage>"  "getPackages")
                             ("void"              "addOrphan"    (("int" "anIndex") ("IJCTElement" "orphan")))
                             ("void"              "addOrphan"    (("IJCTElement" "orphan")))
                             ("void"              "removeOrphan" (("IJCTElement" "orphan")))
                             ("void"              "removeOrphan" (("int" "anIndex")))
                             ("List<IJCTElement>"  "getOrphans")
                             ("IJCTPath"          "getPath")
                             ("String"            "getID")
                             ("IJCTElement"       "walk"         (("IJCTPath" "aPath")))
                             ("int"               "hashCode")
                             ("String"            "getSourceCode")
                             ("Writer"            "getSourceCode" (("Writer" "aWriter")) () ("IOException"))
                             ("IJCTArrayType"     "registerArrayType" (("IJCTType" "underlyingType")))
                             ("IJCTArrayType"     "registerArrayType" (("IJCTType" "underlyingType") ("String" "underlyingTypeName")))))
                   (mapcar (curry #'apply
                                  (lambda (return-type name
                                           &optional arguments generics throws
                                           description-lines)
                                    (create-whole-java-method
                                     ('(:public) #J(nil return-type) name arguments generics throws)
                                     `(,(format nil "~:[return ~;~]~A;"
                                                (string= "void" return-type)
                                                (generate-method-call (format nil "((IJCTContainer)~A)" (get-member "original"))
                                                                      (mapcar #'second arguments) nil
                                                                      name arguments)))
                                     description-lines)))
                           `(("Collection<IJCTPackage>" "getEnclosedElements")
                             ("Collection<T>" "getEnclosedElements" (("Class<T>" "elementType")) (,(create-java-generic "T" "extends IJCTPackage")))
                             ("Collection<? extends IJCTPackage>" "getAllEnclosedElements")
                             ("Collection<T>" "getAllEnclosedElements" (("JCTKind" "aKind") ("Class<T>" "elementType") ("boolean" "first_layer_only")) (,(create-java-generic "T" "extends IJCTElement"))))))
                  "jct.kernel.impl.JCTRenamedRootNode.java"
                  :impl-only :no-create/delete-transformation :root-node)
                 (create-mm-constituent-full
                  "Source Code Part" () '(("Element" "extends IJCTElement"))
                  #T('jct "Element Container" '(("Element")))
                  `(,#T('jct "Element"))
                  ()
                  '("java.util.LinkedList" "java.util.Collection" nil "jct.kernel.IJCTElement" "jct.kernel.JCTKind")
                  "2009-03-09 (月)" +author+
                  '("This class represents a element which is (indirectly) enclosed in"
                    "a {@link jct.kernel.IJCTCompilationUnit compilation unit}.")
                  (list
                   (create-mm-field "Enclosing Compilation Unit" #T('jct "compilation unit") :final :intrf-only :nullable :no-transformation)
                   (create-mm-field "Stored Source Code"         #T(nil  "String")  :nullable :intrf-only :no-transformation)
                   (create-mm-field "Stored Source Code Offset"  #T(nil  "Integer") :nullable :interface-only-accessor :no-transformation)
                   (create-mm-field "Stored Source Code Length"  #T(nil  "Integer") :nullable :interface-only-accessor :no-transformation)
                   (create-mm-field-w/default "Comment"          #T('jct "comment") "new LinkedList<IJCTComment>()" :list :no-transformation))
                  (list
                   (create-whole-java-method
                    (() nil "JCTSourceCodePart" '(("IJCTRootNode"        "aRootNode")
                                                  ("String"              "name")
                                                  ("Collection<Element>" "elements")))
                    '("super(aRootNode, name, elements);")
                    '("Identifiable contructor"))
                   (create-whole-java-method
                    (() nil "JCTSourceCodePart" '(("IJCTRootNode"        "aRootNode")
                                                  ("Collection<Element>" "elements")))
                    '("super(aRootNode, elements);")
                    '("Non-Identifiable constructor"))
                   (create-whole-java-method
                    (() nil "JCTSourceCodePart" '(("IJCTRootNode"        "aRootNode")
                                                  ("String"              "name")))
                    '("super(aRootNode, name);")
                    '("Identifiable contructor with backpatch enclosed elements"))
                   (create-whole-java-method
                    (() nil "JCTSourceCodePart" '(("IJCTRootNode"        "aRootNode")))
                    '("super(aRootNode);")
                    '("Non-Identifiable constructor with backpatch enclosed elements"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Integer") "getStoredSourceCodeOffset" '(("IJCTSourceCodePart" "enclosing")))
                    :abstract
                    '("Returns the offset of the stored source code representation of"
                      "this element, within its direct enclosing element's.")
                    nil
                    "null iff not (indirectly) enclosed in a {@link jct.kernel.IJCTCompilationUnit Compilation Unit} which has a stored source code."))
                  "jct.kernel.impl.JCTSourceCodePart.java"
                  :abstract)
                 (create-mm-constituent
                  "Identifiable" () #T('jct "Element") `(,#T('jct "Element")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents an identifiable constituent")
                  (list (create-mm-field "name" #T(nil "String") :intrf-only)) ()
                  :abstract :intrf-only)
                 (create-mm-constituent
                  "Importable" () #T('jct "Identifiable") `(,#T('jct "Identifiable")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents an importable constituent")
                  () () :abstract :intrf-only)
                 (create-mm-constituent
                  "Statement" () #T('jct "Source Code Part") `(,#T('jct "Source Code Part")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a statement")
                  () () :abstract :intrf-only)
                 (create-mm-constituent
                  "Expression" () #T('jct "Source Code Part") `(,#T('jct "Source Code Part")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents an expression")
                  ()
                  (list
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    :abstract
                    '("Returns the type of the expression")
                    ()
                    "null iff the type of the expression can not be resolved"))
                  :abstract :intrf-only)
                 (create-mm-constituent-w/impl-only-generics
                  "Type" () '(("Component" "extends IJCTElement"))
                  #T('jct "Element Container" '(("Component")))
                  `(,#T('jct "Element"))
                  ()
                  '("jct.kernel.IJCTElement")
                  "2009-01-08 (木)" +author+
                  '("This class represens a type")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTType" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getTypeName")
                    :abstract
                    '("Returns the type name"))
                   (create-whole-java-method
                    ('(:public) #J(nil "JCTPathPartBuilder") "createPathPart" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "super" () nil "createPathPart")
                                `(,(generate-method-call "this" () nil "getTypeName"))
                                nil "setData" '(("String" "data")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "equals" '(("Object" "o")) () () :impl-only)
                    `("if(!(o instanceof IJCTType))"
                      "    return false;"
                      ""
                      ,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getTypeName")
                                `(,(generate-method-call "((IJCTType)o)" () nil "getTypeName"))
                                nil "equals" '(("Object" "o")))))
                    ()))
                  :abstract)
                 (create-mm-constituent
                  "Primitive Type" () #T('jct "Type") `(,#T('jct "Type")) ()
                  '("jct.kernel.JCTPrimitiveTypes")
                  "2009-01-08 (木)" +author+
                  '("This class represents a primitive type")
                  (list (create-mm-field "type" #T("jct.kernel" "JCTPrimitiveTypes") :final))
                  (list
                   (create-whole-java-method
                    (() nil "JCTPrimitiveType" '(("IJCTRootNode" "aRootNode") ("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))
                    `("super(aRootNode);"
                      ,(format nil "~A = aPrimitiveTypeConstant;" (get-member "type")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getTypeName" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getType")
                                () nil "getTypeName")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                "aWriter"
                                `(,(generate-method-call
                                    (generate-method-call "this" () nil "getType")
                                    () nil "getSourceCode"))
                                nil "append" '(("String" "str")))))
                    ()))
                  :no-transformation)
                 (create-mm-constituent-full
                  "Non Primitive Type" () '(("Component" "extends IJCTElement"))
                  #T('jct "Type" '(("Component"))) `(,#T('jct "Type"))
                  '("java.util.Set")
                  '("java.util.Set" "java.util.HashSet" "java.util.Collections"
                    nil "jct.kernel.IJCTElement")
                  "2009-03-04 (水)" +author+
                  '("This class represents a non primitive type")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTNonPrimitiveType" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Set<IJCTNonPrimitiveType>") "getDirectSuperClasses")
                    :abstract
                    '("Returns the set of directly extended classes and directly implemented interfaces"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Set<IJCTNonPrimitiveType>") "getAllSuperClasses")
                    :abstract
                    '("Returns the set of all super classes or interfaces"))
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isExtendingOrImplementing" '(("IJCTNonPrimitiveType" "aNonPrimitiveType")))
                    `("return this == aNonPrimitiveType"
                      ,(format nil "      || ~A;"
                               (generate-method-call
                                (generate-method-call "aNonPrimitiveType" () nil "getAllSuperClasses")
                                '("this") nil "contains" '(("IJCTNonPrimitiveType" "aNonPrimitiveType")))))
                    '("Checks whether or not this class extends or implements type."
                      "If type is not a class, return false")))
                  "jct.kernel.impl.JCTNonPrimitiveType.java"
                  :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Array Type" ()
                  #T('jct "Non Primitive Type" '(("IJCTClassMember")))
                  `(,#T('jct "Non Primitive Type"))
                  ()
                  '("java.util.Set" "java.util.HashSet"
                    nil "jct.kernel.IJCTNonPrimitiveType" "jct.kernel.JCTPrimitiveTypes"
                    "jct.kernel.IJCTClassMember" "jct.kernel.IJCTClassType"
                    "jct.kernel.IJCTFactory" "jct.kernel.JCTModifiers")
                  "2009-01-08 (木)" +author+
                  '("This class represents an Array Type")
                  (list
                   (create-mm-field "underlying type" #T('jct "type"))
                   (create-mm-field "clone method"    #T('jct "method") :final :container)
                   (create-mm-field "length field"    #T('jct "field") :final :container)
                   (create-mm-field "underlying type name" #T(nil "String") :nullable :no-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTArrayType" '(("IJCTRootNode" "aRootNode") ("IJCTType" "underlyingType")
                                             ("String" "registeredUnderlyingTypeName")))
                    `("super(aRootNode);"
                      ,(format nil "~A = registeredUnderlyingTypeName;" (get-member "underlying type name"))
                      ,(format nil "~A = underlyingType;" (get-member "underlying type"))
                      ,(format nil "~A = ~A;"
                               (get-member "length field")
                               (generate-method-call
                                "this"
                                `(,(generate-method-call
                                    "JCTArrayType" '("this") nil
                                    "createLength" '(("JCTArrayType" "anArrayType"))))
                                nil "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "clone method")
                               (generate-method-call
                                "this"
                                `(,(generate-method-call
                                    "JCTArrayType" '("this") nil
                                    "createClone" '(("JCTArrayType" "anArrayType"))))
                                nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Class Member")
                                                (get-member "length field")
                                                (get-member "clone method")))
                    ())
                   (create-whole-java-method
                    (() nil "JCTArrayType" '(("IJCTRootNode" "aRootNode") ("IJCTType" "underlyingType")))
                    '("this(aRootNode, underlyingType, null);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getTypeName" () () () :impl-only)
                    `(,(format nil "return Constants.ARRAY_MARKER + ~A;"
                               (generate-method-call "this" () nil "getUnderlyingTypeName")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getUnderlyingType")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                '("\"[]\"") nil "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Set<IJCTNonPrimitiveType>") "getDirectSuperClasses" () () () :impl-only)
                    `("final Set<IJCTNonPrimitiveType> result = new HashSet<IJCTNonPrimitiveType>();"
                      ,(format nil "final IJCTClassType object = ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("Constants.CLASSPATH_OBJECT" "IJCTClassType.class") nil
                                "getType" '(("String" "TypeName") ("Class<T>" "aClass"))))
                      ,(format nil "if(null != ~A)"
                               (generate-method-call
                                (generate-method-call "object" () nil "getSelector")
                                () nil "getElement"))
                      ,(format nil "    ~A;"
                               (generate-method-call "result" '("object") nil
                                                     "add" '(("IJCTNonPrimitiveType" "aNonPrimitiveType"))))
                      "return result;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setUnderlyingType" '(("IJCTType" "underlyingType") ("String" "registeredUnderlyingTypeName")))
                    `(,(format nil "~A;"
                               (generate-method-call "this"
                                                     '("underlyingType") nil
                                                     "setUnderlyingType" '(("IJCTType" "underlyingType"))))
                       ,(format nil "~A = registeredUnderlyingTypeName;" (get-member "underlying type name")))
                    '("Modifies the underlying type, set also the registered type name."))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getUnderlyingTypeName")
                    `(,(format nil "return null == ~A" (get-member "underlying type name"))
                       ,(format nil "       ? ~A"
                                (generate-method-call (get-member "underlying type")
                                                      () nil "getTypeName"))
                       ,(format nil "       : ~A;" (get-member "underlying type name")))
                    '("Returns the (registered) underlying type's name."))
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "clearRegisteredTypeName")
                    `(,(format nil "~A = null;" (get-member "underlying type name")))
                    '("Clears the registered underlying type name."
                      "Post-condition: {@code this.getUnderlyingTypeName().equals(this.getUnderlyingType().getTypeName())} returns true;")))
                  "jct.kernel.impl.JCTArrayType.java"
                  :no-transformation)
                 (create-mm-constituent-w/impl-file-helper
                  "Class Type" ()
                  #T('jct "Non Primitive Type" '(("IJCTSelector<IJCTClass>")))
                  `(,#T('jct "Non Primitive Type"))
                  '("java.util.Set")
                  '("java.util.Set" "java.util.HashSet" "java.util.Collections" "java.util.Deque" "java.util.LinkedList"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "jct.kernel.IJCTSelector" "jct.kernel.IJCTNonPrimitiveType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a Class Type.<br>"
                    "All methods but {@link #getSelector} and {@link #setSelector},"
                    "may throw NullPointerException if the element is unresolved."
                    "<br><br>"
                    "TODO : separate class and interface")
                  (list (create-mm-field "class declaration" #T('jct "class") :container :selector :no-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTClassType" '(("IJCTRootNode" "aRootNode") ("IJCTSelector<IJCTClass>" "classDeclaration")))
                    `("super(aRootNode);"
                      "if(aRootNode instanceof JCTRootNode)"
                      ,(format nil "    ~A;"
                               (generate-method-call "((JCTRootNode)aRootNode)"
                                                     '("this") nil
                                                     "registerClassType" '(("IJCTClassType" "aClassType"))))
                      ,(format nil "~A = this.createInternalReference(classDeclaration);"
                               (get-member "class declaration"))
                      ,(generate-backpatch-call #T('jct "Selector" '(("IJCTClass")))
                                                (get-member "class declaration")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTSelector" `(,(create-java-generic "IJCTClass"))) "getSelector")
                    `(,(format nil "return ~A;"
                               (generate-method-call (get-member "class declaration") () nil "get")))
                    '("Returns the declared class represented by this type")
                    ()
                    "null iff the element is unresolved")
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setSelector" '(("IJCTSelector<IJCTClass>" "classSelector")))
                    `(,(format nil "if(null != ~A)"
                               (generate-method-call
                                (generate-method-call "this" () nil "getSelector")
                                () nil "getElement"))
                       "throw new IllegalStateException(\"Can not change the selector unless it was previously erroneous\");"
                       ""
                       ,(format nil "~A;"
                                (generate-method-call (get-member "class declaration")
                                                      '("classSelector") nil
                                                      "set" '(("IJCTSelector<IJCTClass>" "classSelector")))))
                    '("Modifies the declared class represented by this type.")
                    ()
                    nil
                    '("IllegalStateException unless the element was previously not resolved"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Set" `(,(create-java-generic "IJCTNonPrimitiveType"))) "getDirectSuperClasses")
                    `(,(format nil "final IJCTClass clazz = ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getSelector")
                                () nil "getElement"))
                       "final Set<IJCTNonPrimitiveType> result = new HashSet<IJCTNonPrimitiveType>();"
                       ""
                       ,(format nil "final IJCTClassType extended = ~A;"
                                (generate-method-call "clazz" () nil "getDirectSuperClass"))
                       "if(null != extended"
                       ,(format nil "   && ~A != ~A)"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getSelector")
                                 () nil "getElement")
                                (generate-method-call
                                 (generate-method-call "extended" () nil "getSelector")
                                 () nil "getElement"))
                       ,(format nil "    ~A;"
                                (generate-method-call "result"
                                                      '("extended") nil
                                                      "add" '(("IJCTNonPrimitiveType" "aNonPrimitiveType"))))
                       ""
                       ,(format nil "for(final IJCTClassType implemented : ~A)"
                                (generate-method-call "clazz" ()  nil
                                                      "getDirectlyImplementedInterfaces"))
                       ,(format nil "    ~A;"
                                (generate-method-call "result"
                                                      '("implemented") nil
                                                      "add" '(("IJCTNonPrimitiveType" "aNonPrimitiveType"))))
                       ""
                       ,(format nil "return ~A;"
                                (generate-method-call "Collections"
                                                      '("result") nil
                                                      "unmodifiableSet" '(("Set" "s"))))
                       )
                    '("Returns the set of directly extended classes and directly implemented interfaces")))
                  "jct.kernel.impl.JCTClassType.java"
                  :no-transformation)
                 (create-mm-constituent
                  "Intersection Type" () #T('jct "Type") `(,#T('jct "Type"))
                  '("java.util.Set")
                  '("java.util.HashSet" "java.util.Arrays" "java.util.ListIterator" "java.util.List")
                  "2009-01-08 (木)" +author+
                  '("This class represents an intersection of types")
                  (list (create-mm-field "type" #T('jct "type") :set :no-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTIntersectionType" '(("IJCTRootNode" "aRootNode") ("IJCTType..." "types")))
                    `("super(aRootNode);"
                      "if(types.length <= 1)"
                      "    throw new IllegalArgumentException(\"To create the intersection of 0 types, use JCTPrimitiveTypes.VOID, and to create the intersection type of a sole type, use the type itself.\");"

                      ,(format nil "~A = new HashSet<IJCTType>();" (get-member "type" t))
                      ""
                      ,(format nil "final List<IJCTType> lTypes = ~A;"
                               (generate-method-call "Arrays"
                                                     '("types") nil
                                                     "asList" '(("Object..." "array"))))
                      ,(format nil "final ListIterator<IJCTType> it = ~A;"
                               (generate-method-call "lTypes" () nil "listIterator"))
                      ,(format nil "while(~A)"
                               (generate-method-call "it" () nil "hasNext"))
                      "{"
                      ,(format nil "    final IJCTType type = ~A;"
                               (generate-method-call "it" () nil "next"))
                      "    if(type instanceof IJCTIntersectionType)"
                      "    {"
                      ,(format nil "        ~A;"
                               (generate-method-call "it" () nil "remove"))
                      ,(format nil "        for(final IJCTType t : ~A)"
                               (generate-method-call "((IJCTIntersectionType)type)" () nil "getTypes"))
                      "        {"
                      ,(format nil "            ~A;"
                               (generate-method-call "it" '("t") nil "add" '(("IJCTType" "aType"))))
                      ,(format nil "            ~A;"
                               (generate-method-call "it" () nil "previous"))
                      "        }"
                      "    }"
                      "}")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Set" `(,(create-java-generic "IJCTType"))) "getTypes")
                    `(,(format nil "return ~A;"
                               (generate-method-call "Collections"
                                                     `(,(get-member "type" t)) nil
                                                     "unmodifiableSet" '(("Set" "s")))))
                    '("Returns the set of types composing this intersection types"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    '("throw new IllegalStateException(\"An Intersection Type should never appear in source code.\");")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getTypeName" () () () :impl-only)
                    `("final StringBuilder typeName = new StringBuilder(Constants.INTERSECTION_MARKER);"
                      ,(format nil "for(final IJCTType type : ~A)"
                               (generate-method-call "this" () nil "getTypes"))
                      ,(format nil "    ~A;"
                               (generate-method-call
                                (generate-method-call "typeName"
                                                      `(,(generate-method-call "type" () nil "getTypeName")) nil
                                                      "append" '(("String" "str")))
                                '("Constants.INTERSECTION_SEPARATOR") nil
                                "append" '(("String" "str"))))
                      ""
                      ,(format nil "return ~A;"
                               (generate-method-call "typeName" () nil "toString")))
                    ()))
                  :no-transformation)
                 (create-mm-constituent-w/impl-file-helper
                  "Package" ()
                  #T('jct "Element Container" '(("IJCTCompilationUnit")))
                  `(,#T('jct "Importable") ,#T('jct "Element Container" '(("IJCTCompilationUnit"))))
                  ()
                  '("java.util.Iterator" "java.util.Collection"
                    nil "java.io.StringWriter"
                    nil "jct.util.ListOfElements"
                    nil "jct.kernel.IJCTElement" "jct.kernel.IJCTClass")
                  "2008-12-02 (火)" +author+
                  '("This class represents a package")
                  (list
                   (create-mm-field "package declaration" #T('jct "compilation unit") :container :nullable :interface-only-accessor)
                   (create-mm-field "compilation unit"    #T('jct "compilation unit") :container :list)
                   (create-mm-field "is Ghost"            #T(nil "boolean")))
                  (list
                   (create-whole-java-method
                    (() nil "JCTPackage" '(("IJCTRootNode" "aRootNode") ("String" "name") ("boolean" "isGhost")))
                    '("this(aRootNode, name, null, isGhost);")
                    ())
                   (create-whole-java-method
                    (() nil "JCTPackage" '(("IJCTRootNode" "aRootNode") ("String" "name") ("IJCTCompilationUnit" "packageDeclaration")
                                           ("boolean" "isGhost")))
                    `("super(aRootNode, name);"
                      ,(generate-backpatch-call #T('jct "Compilation Unit")
                                                (get-member "package declaration")
                                                (get-member "compilation unit" t))
                      ,(format nil "~A = isGhost;"
                               (get-member "is ghost"))
                      ,(format nil "~A;"
                               (generate-method-call (get-member "package declaration")
                                                     '("packageDeclaration") nil
                                                     "set" '(("IJCTCompilationUnit" "packageDeclaration")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTCompilationUnit") "getPackageDeclaration" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call (get-member "package declaration") () nil "get")))
                    '("Returns the package declaration of this package"))
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setPackageDeclaration" '(("IJCTCompilationUnit" "packageDeclaration")) () () :impl-only)
                    `(,(format nil "if(null != packageDeclaration && !~A)"
                               (generate-method-call "packageDeclaration" () nil "isPackageDeclaration"))
                       "    throw new IllegalArgumentException(\"Compilation Unit must be a package declaration\");"
                       ""
                       ,(format nil "~A;"
                                (generate-method-call (get-member "package declaration")
                                                      '("packageDeclaration") nil
                                                      "set" '(("IJCTCompilationUnit" "packageDeclaration")))))
                    '("Modifies the package declaration of this package"))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getID" () () () :impl-only)
                    `(,(format nil "return ~A + super.getID();"
                               (generate-method-call "this" () nil
                                                     "getName")))
                    '("Returns a unique ID for this element."))
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isUnnamed")
                    `(,(format nil "return null == ~A;" (generate-method-call "this" () nil "getName")))
                    '("Returns whether the package is annonymous or named"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException"))
                    :abstract
                    '("Writes the textual representation in the stream, the name and its separator is not wrote in the writer."))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getSourceCode")
                    :abstract
                    '("Returns the textual representation. 0x1C (File Separator) Unicode Character is used to separate compilation units.")))
                  "jct.kernel.impl.JCTPackage.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Compilation Unit" ()
                  #T('jct "Source Code Part" '(("IJCTSourceCodePart")))
                  `(,#T('jct "Element Container" '(("IJCTSourceCodePart")))
                       ,#T('jct "Source Code Part"))
                  '("java.io.File")
                  '("java.io.File" "java.io.StringWriter"
                    nil "java.util.SortedSet" "java.util.TreeSet" "java.util.Comparator"
                    nil "jct.kernel.IJCTPackage" "jct.kernel.IJCTSourceCodePart")
                  "2009-01-08 (木)" +author+
                  '("This class represents a compilation unit"
                    "(typically, a compilation unit is a Java source file).<br>"
                    "Two compilation units are equals iff they are representing the same file.")
                  (list
                   (create-mm-field "source file" #T("java.io" "File") :interface-only-accessor)
                   (create-mm-field "imported"    #T('jct "import")     :set :container)
                   (create-mm-field "clazz"       #T('jct "class")      :set :container)
                   (create-mm-field "stored source code" #T(nil "StringBuffer") "null" :nullable :no-accessor)
                   (create-mm-field "comment"     #T('jct "comment") :container :list :no-transformation))
                  (list
                   (create-whole-java-method
                    (() nil "JCTCompilationUnit" '(("IJCTRootNode" "aRootNode") ("File" "sourceFile")))
                    `(,(format nil "super(aRootNode, ~A);"
                               (generate-method-call "sourceFile" () nil "getAbsolutePath"))
                       ,(format nil "~A = sourceFile;" (get-member "source file"))
                       ,(generate-backpatch-call #T('jct "Source Code Part")
                                                 (get-member "imported" t)
                                                 (get-member "clazz"    t)
                                                 (get-member "comment"  t)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isPackageDeclaration")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call (get-member "source file") () nil "getName")
                                '("Constants.PACKAGE_DECLARATION_FILENAME") nil
                                "equals" '(("Object" "o")))))
                    '("Returns whether the compilation unit is a {@literal package-info.java} file"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException"))
                    :abstract
                    '("Writes the textual representation in the stream, the name and its separator is not wrote in the writer."))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getSourceCode")
                    :abstract
                    '("Returns the textual representation. 0x00 (NULL) Unicode Character is used to separate name and content. ")))
                  "jct.kernel.impl.JCTCompilationUnit.java")
                 (create-mm-constituent
                  "Comment" ()
                  #T('jct "Source Code Part") `(,#T('jct "Source Code Part")) () ()
                  "2009-07-10 (金)" +author+
                  '("This class represents a comment.")
                  #11=(list
                       (create-mm-field "text" #T('nil "String"))
                       (create-mm-field "is end of line" #T('nil "boolean")))
                  (list
                   (create-whole-java-method
                    (() nil "JCTComment" '(("IJCTRootNode" "aRootNode") ("boolean" "isEndOfLine")
                                           ("String" "text")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name) (generate-variable-name name))))
                                #11#))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    '("return aWriter.append(this.getIsEndOfLine() ? \"//\" : \"/*\")"
                      "              .append(this.getText())"
                      "              .append(this.getIsEndOfLine() ? \"\" : \"*/\");")
                    ()))
                  :no-transformation)
                 (create-mm-constituent-w/impl-file-helper
                  "Import" ()
                  #T('jct "Source Code Part") `(,#T('jct "Source Code Part")) ()
                  '("jct.kernel.IJCTClass" "jct.kernel.IJCTClassMember"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-08 (木)" +author+
                  '("This class represents an import"
                    "Imports respect Java restrictions:"
                    "<ul>"
                    "<li>if an import is on demand and static, the imported element must be a top level class.</li>"
                    "<li>if an import is on demand but not static, the imported element must be a package</li>"
                    "<li>if an import is static but not on demand, the imported element must be a static class member</li>"
                    "<li>if an import is neither static nor on demand, the imported element must be a class</li>"
                    "</ul>")
                  #1=(list
                      (create-mm-field "imported element"     #T('jct "importable") :interface-only-accessor)
                      (create-mm-field "is static"            #T(nil "boolean") :interface-only-accessor)
                      (create-mm-field "is on demand"         #T(nil "boolean") :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTImport" '(("IJCTRootNode" "aRootNode") ("IJCTImportable" "importedElement")
                                          ("boolean" "isStatic") ("boolean" "isOnDemand")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name) (generate-variable-name name))))
                                #1#)
                      ,(format nil "~A;"
                               (generate-method-call "this" () nil "check")))
                    ()))
                  "jct.kernel.impl.JCTImport.java")
                 (create-mm-constituent-full
                  "Class Member" () '(("Component" "extends IJCTElement"))
                  #T('jct "Source Code Part" '(("Component")))
                  `(,#T('jct "Importable") ,#T('jct "Source Code Part"))
                  ()
                  '("java.util.Collection" "java.util.TreeSet"
                    nil "jct.kernel.JCTModifiers" "jct.kernel.JCTKind"
                    "jct.kernel.IJCTClass" "jct.kernel.IJCTElement" "jct.kernel.IJCTNonPrimitiveType"
                    "jct.kernel.IJCTArrayType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a class member"
                    "Two imports are equals iff they have the same textual representation")
                  (list
                   (create-mm-field "modifier" #T("jct.kernel" "JCTModifiers") :set :intrf-only))
                  (list
                   (create-whole-java-method
                    (() nil "JCTClassMember" '(("IJCTRootNode" "aRootNode") ("String" "name") ("Collection<Component>" "elements")))
                    `("super(aRootNode, name, elements);")
                    ())
                   (create-whole-java-method
                    (() nil "JCTClassMember" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    '("this(aRootNode, name, null);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Boolean") "isStatic")
                    :abstract
                    '("Returns whether this member is static.")
                    ()
                    "null iff the member is not enclosed directly in a class")
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isMemberOf" '(("IJCTNonPrimitiveType" "aNonPrimitiveType")))
                    :abstract
                    '("Returns whether this member is a member of aClassType or of any super class of aClassType"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTClass") "getDirectEnclosingClass")
                    :abstract
                    '("Returns the closest nesting class"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTClass") "getTopLevelEnclosingClass")
                    :abstract
                    '("Returns the top level enclosing class."
                      "That is: the enclosing class which is not nested itself")))
                  "jct.kernel.impl.JCTClassMember.java"
                  :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Class" ()
                  #T('jct "Class Member" '(("IJCTClassMember")))
                  `(,#T('jct "Class Member") ,#T('jct "Element Container" '(("IJCTClassMember"))))
                  '("java.util.Collection")
                  '("java.util.Collection" "java.util.LinkedList" "java.util.Arrays" "java.util.SortedSet" "java.util.TreeSet" "java.util.Comparator"
                    "java.util.HashSet" "java.util.Map" "java.util.HashMap" "java.util.Iterator"
                    nil "util.collection.IndirectCollection"
                    nil "java.io.Writer" "java.io.IOException" "java.lang.ref.SoftReference"
                    nil "jct.kernel.IJCTField" "jct.kernel.IJCTFactory" "jct.kernel.IJCTElement"
                    "jct.kernel.JCTModifiers" "jct.kernel.IJCTPackage" "jct.kernel.IJCTMethod")
                  "2009-01-08 (木)" +author+
                  '("This class represents a (declaration of a) class"
                    "An enum is a class."
                    "The class members are indexed, the indexes are globals for all class members, static or not."
                    ""
                    "Every class has three variable members: this, super and class (static), modifying them result in undefined behaviour."
                    "Their respectives indexes are undefined but they <strong>must</strong> be the three first members."
                    "Every class must have a super class. Only java.lang.Object and interfaces may have {@code null} as super class (possibly itself for Object)."
                    "Two classes are equals iff they have the same FQN")
                  (list
                   (create-mm-field "direct super class"             #T('jct "class type") :interface-only-accessor)
                   (create-mm-field "is interface"                   #T(nil "boolean") :interface-only-accessor)
                   (create-mm-field "declared member"                #T('jct "class member") :list :container)
                   (create-mm-field "special members"                #T(nil "IJCTField[]") :no-accessor :final)
                   (create-mm-field "is ghost"                       #T(nil "boolean"))
                   (create-mm-field-w/default "directly implemented interface" #T('jct "class type") "new HashSet<IJCTClassType>()" :set :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTClass" '(("IJCTRootNode" "aRootNode") ("String" "name")
                                         ("boolean" "isInterface") ("boolean" "isGhost")))
                    `("super(aRootNode, name);"
                      ,(format nil "~A;"
                               (generate-method-call "this" '("isInterface") nil "setIsInterface" '(("boolean" "isInterface"))))
                      ,(format nil "~A;"
                               (generate-method-call "this" '("isGhost") nil "setIsGhost" '(("boolean" "isGhost"))))
                      ,(format nil "~A = ~A;"
                               (get-member "special member" t)
                               (generate-method-call "this" () nil "createSpecialMembers"))
                      ,(generate-backpatch-call #T('jct "Class Member")
                                                (generate-method-call
                                                 "Collections"
                                                 `(,(generate-method-call "Arrays"
                                                                          `(,(get-member "special member" t))
                                                                          nil "asList" '(("Object[]" "array"))))
                                                 nil "unmodifiableCollection" '(("Collection" "c")))
                                                (get-member "declared member" t)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getFQN")
                    :abstract
                    '("Returns the Fully Qualified Name of the class"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTClassType") "createClassType")
                    :abstract
                    '("Returns a new IJCTClassType on this class."
                      "Roughly equivalent to {@code this.getRootNode().getFactory().createClassType(this.getRootNode().getFactory().createSimpleSelector(this))}"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTField") "getThisField")
                    `(,(format nil "return ~A[0];"
                               (get-member "special member" t)))
                    '("Returns the field representing the variable {@code this} of this class."
                      "Included in the enclosed elements"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTField") "getSuperField")
                    `(,(format nil "return ~A[1];"
                               (get-member "special member" t)))
                    '("Returns the field representing the variable {@code super} of this class."
                      "Included in the enclosed elements"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTField") "getClassField")
                    `(,(format nil "return ~A[2];"
                               (get-member "special member" t)))
                    '("Returns the field representing the static variable {@code class} of this class."
                      "Included in the enclosed elements"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Collection" `(,(create-java-generic "IJCTClass"))) "getNestedClasses" '(("Boolean" "staticOnly")))
                    :abstract
                    '("Returns the list of nested class")
                    '("staticOnly whether you want only the static or only the non-static ones, if null, returns both of them"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Collection" `(,(create-java-generic "IJCTField"))) "getFields" '(("Boolean" "staticOnly") ("boolean" "includeSpecials")))
                    :abstract
                    '("Returns the list of fields")
                    '("staticOnly whether you want only the static or only the non-static ones, if null, returns both of them"
                      "includeSpecials whether you want the three special fields: this, super and class"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Collection" `(,(create-java-generic "IJCTMethod"))) "getMethods" '(("Boolean" "staticOnly")))
                    :abstract
                    '("Returns the list of methods")
                    '("staticOnly whether you want only the static or only the non-static ones, if null, returns both of them"))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getID" () () () :impl-only)
                    `(,(format nil "return (null == ~A ? ~A : ~A) + super.getID();"
                               (generate-method-call "this" () nil
                                                     "isStatic")
                               (generate-method-call "this" () nil
                                                     "getFQN")
                               (generate-method-call "this" () nil
                                                     "getName")))
                    '("Returns a unique ID for this element.")))
                  "jct.kernel.impl.JCTClass.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Method" ()
                  #T('jct "Class Member" '(("IJCTStatement")))
                  `(,#T('jct "Class Member") ,#T('jct "Element Container" '(("IJCTStatement"))))
                  ()
                  '("jct.kernel.IJCTStatement" "jct.kernel.JCTPrimitiveTypes"
                    nil "java.util.Iterator" "jct.kernel.JCTModifiers" "java.io.Writer" "java.util.SortedSet" "java.util.TreeSet" "java.util.Comparator"
                    "java.io.IOException" "java.util.HashSet" "java.util.HashMap" "java.util.Map")
                  "2009-01-08 (木)" +author+
                  '("This clas represents a method")
                  (list
                   (create-mm-field "return type"      #T('jct "type"))
                   (create-mm-field "parameter"        #T('jct "parameter")   :list :container)
                   (create-mm-field "body"             #T('jct "block")      :container)
                   (create-mm-field-w/default "thrown exception" #T('jct "class type") "new HashSet<IJCTClassType>()" :set))
                  (list
                   (create-whole-java-method
                    (() nil "JCTMethod" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    `("super(aRootNode, name);"
                      ,(format nil "~A = ~A;"
                               (get-member "return type")
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("JCTPrimitiveTypes.VOID") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant"))))
                      ,(format nil "~A = ~A;"
                               (get-member "body")
                               (generate-method-call
                                "this"
                                `(,(generate-method-call
                                    (generate-method-call
                                     (generate-method-call "this" () nil "getRootNode")
                                     () nil "getFactory")
                                    () nil "createBlock"))
                                nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Statement")
                                                (get-member "parameter" t)
                                                (get-member "body")))
                    ()))
                  "jct.kernel.impl.JCTMethod.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Method Invocation" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTSelector"
                    "jct.kernel.IJCTType"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "java.util.Iterator")
                  "2008-08-20 (水)" +author+
                  '("This class represents a method invocation")
                  (list
                   (create-mm-field "method selector" #T('jct "method") :container :selector)
                   (create-mm-field "argument"        #T('jct "expression") :list :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTMethodInvocation" '(("IJCTRootNode" "aRootNode") ("IJCTSelector<IJCTMethod>" "methodSelector")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "method selector")
                               (generate-method-call "this"
                                                     '("methodSelector") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression")
                                                (get-member "method selector")
                                                (get-member "argument"  t)))
                    ()))
                  "jct.kernel.impl.JCTMethodInvocation.java") 
                 (create-mm-constituent
                  "Variable" ()
                  #T('jct "variable impl")
                  `(,#T('jct "Statement") ,#T('jct "Identifiable")
                       ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTClassType" "jct.kernel.Constants")
                  "2009-01-08 (木)" +author+
                  '("This class reprensents a variable")
                  (list
                   (create-mm-field "modifier" #T("jct.kernel" "JCTModifiers") :set :intrf-only)
                   (create-mm-field "type"          #T('jct "type") :intrf-only)
                   (create-mm-field "initial value" #T('jct "expression") :container :nullable :intrf-only)
                   (create-mm-field "name"     #T(nil "String") :intrf-only :impl-only))
                  (list
                   (create-whole-java-method
                    (() nil "JCTVariable" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    '("super(aRootNode, name, aRootNode.getType(Constants.CLASS_BINARYNAME_VOID, IJCTClassType.class), JCTKind.VARIABLE);")
                    ())))
                 (create-mm-constituent
                  "Parameter" ()
                  #T('jct "variable impl") `(,#T('jct "variable"))
                  () '("jct.kernel.IJCTClassType" "jct.kernel.Constants")
                  "2009-06-05 (金)" +author+
                  '("This interface represents a method's parameter")
                  (list
                   (create-mm-field "modifier" #T("jct.kernel" "JCTModifiers") :set :intrf-only :impl-only) 
                   (create-mm-field "name"     #T(nil "String") :intrf-only :impl-only)
                   (create-mm-field "type" #T('jct "type") :intrf-only :impl-only))
                  (list
                   (create-whole-java-method
                    (() nil "JCTParameter" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    '("super(aRootNode, name, aRootNode.getType(Constants.CLASS_BINARYNAME_VOID, IJCTClassType.class), JCTKind.PARAMETER);")
                    ())))
                 (create-mm-constituent
                  "Field" ()
                  #T('jct "variable impl") `(,#T('jct "variable") ,#T('jct "class member"))
                  () '("jct.kernel.IJCTClassType" "jct.kernel.Constants")
                  "2009-06-05 (金)" +author+
                  '("This interface represents a class' field")
                  (list
                   (create-mm-field "modifier" #T("jct.kernel" "JCTModifiers") :set :intrf-only :impl-only)
                   (create-mm-field "type"     #T('jct "type") :intrf-only :impl-only)
                   (create-mm-field "name"     #T(nil "String") :intrf-only :impl-only)
                   (create-mm-field "initial value" #T('jct "expression") :container :nullable :intrf-only :impl-only))
                  (list
                   (create-whole-java-method
                    (() nil "JCTField" '(("IJCTRootNode" "aRootNode") ("String" "name")))
                    '("super(aRootNode, name, aRootNode.getType(Constants.CLASS_BINARYNAME_VOID, IJCTClassType.class), JCTKind.FIELD);")
                    ())))
                 (create-mm-constituent
                  "Block" ()
                  #T('jct "Source Code Part" '(("IJCTStatement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTStatement"))))
                  '("java.util.List") ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a block of statements")
                  (list (create-mm-field "statement" #T('jct "statement") :list :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTBlock" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);"
                      ,(generate-backpatch-call #T('jct "Statement")
                                                (get-member "statement" t)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"\\n{\\n\"") nil "append" '(("String" "str"))))
                       ""
                       ,(format nil "for(final IJCTStatement s : ~A)" (generate-method-call "this" () nil "getStatements"))
                       ,(format nil "    ~A;" (generate-method-call "s" '("aWriter") nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       ,(format nil "return ~A;" (generate-method-call "aWriter" '("\"\\n}\\n\"") nil "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent
                  "Assert" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () () 
                  "2009-01-08 (木)" +author+
                  '("This class reprensents an assert statement")
                  (list
                   (create-mm-field "condition" #T('jct "expression") :container)
                   (create-mm-field "detail"    #T('jct "expression") :container :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTAssert" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "condition")
                               (generate-method-call "this" '("condition") nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression")
                                                (get-member "condition")
                                                (get-member "detail")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"assert \"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;" (generate-method-call
                                           (generate-method-call "this" () nil "getCondition")
                                           '("aWriter") nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       ,(format nil "if(null != ~A)" (generate-method-call "this" () nil "getDetail"))
                       ,(format nil "    ~A;" (generate-method-call
                                               (generate-method-call "this" () nil "getDetail")
                                               '("aWriter") nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       ,(format nil "return ~A;" (generate-method-call "aWriter" '("\";\\n\"") nil "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent
                  "Break Continue" () #T('jct "Statement") `(,#T('jct "Statement")) ()
                  '("jct.kernel.IJCTSourceCodePart")
                  "2009-01-08 (木)" +author+
                  '("This class represents a break or a continue statement")
                  (list (create-mm-field "label" #T('jct "label") :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTBreakContinue" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException"))
                    `(,(format nil "~A;" (generate-method-call
                                          "aWriter"
                                          `(,(generate-method-call "this" () nil "getKeyword"))
                                          nil "append" '(("String" "str"))))
                       ""
                       ,(format nil "if(null != ~A)" (generate-method-call "this" () nil "getLabel"))
                       ,(format nil "    ~A;" (generate-method-call
                                               (generate-method-call "aWriter" `("' '") nil
                                                                     "append" '(("String" "str")))
                                               `(,(generate-method-call
                                                   (generate-method-call "this" () nil "getLabel")
                                                   () nil "getName"))
                                               nil "append" '(("String" "str"))))
                       ""
                       ,(format nil "return ~A;" (generate-method-call "aWriter" '("\";\\n\"") nil "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:protected :abstract) #J(nil "String") "getKeyword")
                    :abstract
                    '("Returns either \"break\" or \"continue\""
                      "depending on the actual statement represented by this instance.")))
                  :abstract :impl-only)
                 (create-mm-constituent
                  "Break" () #T('jct "Break Continue") `(,#T('jct "Break Continue"))
                  () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a break statement")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTBreak" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:protected) #J(nil "String") "getKeyword")
                    '("return \"break\";")
                    ())))
                 (create-mm-constituent
                  "Continue" nil #T('jct "Break Continue") `(,#T('jct "Break Continue"))
                  () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a continue statement")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTContinue" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:protected) #J(nil "String") "getKeyword")
                    '("return \"continue\";")
                    ())))
                 (create-mm-constituent
                  "Label" ()
                  #T('jct "Source Code Part" '(("IJCTStatement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTStatement"))))
                  () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a labeled statement")
                  (list
                   (create-mm-field "name"      #T(nil "String") :intrf-only)
                   (create-mm-field "statement" #T('jct "statement") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTLabel" '(("IJCTRootNode" "aRootNode") ("String" "name") ("IJCTStatement" "statement")))
                    `("super(aRootNode, name);"
                      ,(format nil "~A = ~A;"
                               (get-member "statement")
                               (generate-method-call "this" '("statement") nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Statement")
                                                (get-member "statement")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call
                                          (generate-method-call
                                           "aWriter"
                                           `(,(generate-method-call "this" () nil "getName")) nil
                                           "append" '(("String" "str"))) '("\": \"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getStatement")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())))
                 (create-mm-constituent
                  "Do While Impl" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement" "jct.kernel.IJCTElementContainer"
                    "jct.kernel.IJCTSourceCodePart")
                  "2009-01-31 (土)" +author+
                  '("This class implements the Do While and While interfaces")
                  (list
                   (create-mm-field "condition" #T('jct "expression") :container)
                   (create-mm-field "body"      #T('jct "statement")  :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTDoWhileImpl" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "condition")
                               (generate-method-call "this" '("condition") nil "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "body")
                               (generate-method-call
                                "this"
                                `(,(format nil "((IJCTStatement)~A)"
                                           (generate-method-call
                                            (generate-method-call
                                             (generate-method-call "this" () nil "getRootNode")
                                             () nil "getFactory")
                                            () nil "createEmptyStatement")))
                                nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "condition")
                                                (get-member "body")))
                    ()))
                  :abstract :impl-only)
                 (create-mm-constituent
                  "Do While" () #T('jct "Do While Impl") `(,#T('jct "Do While Impl"))
                  ()
                  '("jct.kernel.IJCTExpression")
                  "2009-01-31 (土)" +author+
                  '("This class represents a do while loop")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTDoWhile" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")))
                    '("super(aRootNode, condition);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"do \"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getBody")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\" while(\"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getCondition")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\");\\n\"") nil "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent
                  "While" () #T('jct "Do While Impl") `(,#T('jct "Do While Impl"))
                  ()
                  '("jct.kernel.IJCTExpression")
                  "2009-01-31 (土)" +author+
                  '("This class represents a while loop")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTWhile" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")))
                    '("super(aRootNode, condition);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"while(\"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getCondition")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\") \"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getBody")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())))
                 (create-mm-constituent-w/impl-file-helper
                  "For" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "java.util.Iterator")
                  "2009-01-08 (木)" +author+
                  '("This class represents a for loop")
                  (list
                   (create-mm-field "initializer" #T('jct "statement")  :list :container)
                   (create-mm-field "condition"   #T('jct "expression") :container)
                   (create-mm-field "updater"     #T('jct "expression statement") :list :container)
                   (create-mm-field "body"        #T('jct "statement") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTFor" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")
                                       ("IJCTStatement" "body")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "body")
                               (generate-method-call "this" '("body") nil "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "condition")
                               (generate-method-call "this" '("condition") nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "initializer" t)
                                                (get-member "condition")
                                                (get-member "updater" t)
                                                (get-member "body")))
                    ()))
                  "jct.kernel.impl.JCTFor.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Enhanced For" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-08 (木)" +author+
                  '("This class represents an enhanced for loop")
                  #7=(list
                      (create-mm-field "variable" #T('jct "variable")   :container)
                      (create-mm-field "iterable" #T('jct "expression") :container)
                      (create-mm-field "body"     #T('jct "statement")  :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTEnhancedFor" '(("IJCTRootNode" "aRootNode") ("IJCTVariable" "variable")
                                               ("IJCTExpression" "iterable") ("IJCTStatement" "body")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name)
                                            (generate-method-call "this"
                                                                  `(,(generate-variable-name name)) nil
                                                                  "createInternalReference" '(("Object" "o"))))))
                                #7#)
                      ,(apply (curry #'generate-backpatch-call #T('jct "Element"))
                              (mapcar (compose #'get-member #'mm-field-name) #7#)))
                    ()))
                  "jct.kernel.impl.JCTEnhancedFor.java")
                 (create-mm-constituent
                  "If" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement")
                  "2009-01-08 (木)" +author+
                  '("This class represents an if statement")
                  (list
                   (create-mm-field "condition"      #T('jct "expression") :container)
                   (create-mm-field "then statement" #T('jct "statement")  :container)
                   (create-mm-field "else statement" #T('jct "statement")  :container :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTIf" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")
                                      ("IJCTStatement" "thenStatement")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "condition")
                               (generate-method-call "this" '("condition") nil "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "then statement")
                               (generate-method-call "this" '("thenStatement") nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "condition")
                                                (get-member "then statement")
                                                (get-member "else statement")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"if(\"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getCondition")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\") \"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getThenStatement")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       ,(format nil "if(null != ~A)"
                                (generate-method-call "this" () nil "getElseStatement"))
                       ,(format nil "    ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getElseStatement")
                                 `(,(generate-method-call "aWriter" '("\" else \"") nil "append" '(("String" "str"))))
                                 nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       "return aWriter;")
                    ())))
                 (create-mm-constituent
                  "Return" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a return statement")
                  (list (create-mm-field "returned expression" #T('jct "expression") :container :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTReturn" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);"
                      ,(generate-backpatch-call #T('jct "Element") (get-member "returned expression")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"return\"") nil
                                                               "append" '(("String" "str"))))
                       ""
                       ,(format nil "if(null != ~A)" (generate-method-call "this" () nil "getReturnedExpression"))
                       ,(format nil "    ~A;" (generate-method-call
                                               (generate-method-call "this" () nil "getReturnedExpression")
                                               `(,(generate-method-call "aWriter"
                                                                        '("\" \"") nil
                                                                        "append" '(("String" "aString"))))
                                               nil "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       ,(format nil "return ~A;" (generate-method-call "aWriter" '("\";\\n\"") nil
                                                                       "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent-w/impl-file-helper
                  "Switch" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-08 (木)" +author+
                  '("This class represents a switch block")
                  (list
                   (create-mm-field "expression"   #T('jct "expression") :container)
                   (create-mm-field "case"         #T('jct "case")       :list :container :interface-only-accessor)
                   (create-mm-field "default case" #T('jct "case")       :container :nullable :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTSwitch" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "expression")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "expression")
                               (generate-method-call "this" '("expression") nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "expression")
                                                (get-member "case" t)
                                                (get-member "default case")))
                    ()))
                  "jct.kernel.impl.JCTSwitch.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Case" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Source Code Part") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("java.io.Writer" "java.io.IOException"
                    nil "jct.kernel.IJCTElement")
                  "2009-01-08 (木)" +author+
                  '("This class represents a case")
                  (list
                   (create-mm-field "label"     #T('jct "expression") :container :nullable)
                   (create-mm-field "statement" #T('jct "statement")  :list :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTCase" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);"
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "label")
                                                (get-member "statement" t)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isDefaultCase")
                    `(,(format nil "return null == ~A;"
                               (generate-method-call "this" () nil "getLabel")))
                    '("Returns wheter this case is a default or not.")))
                  "jct.kernel.impl.JCTCase.java")
                 (create-mm-constituent
                  "Synchronized" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement")
                  "2009-01-08 (木)" +author+
                  '("This class represents a synchronized statement")
                  #2=(list
                      (create-mm-field "synchronized object" #T('jct "expression") :container)
                      (create-mm-field "body"                #T('jct "block")      :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTSynchronized" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "synchronizedObject")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "synchronized object")
                               (generate-method-call "this"
                                                     '("synchronizedObject") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "body")
                               (generate-method-call "this"
                                                     `(,(generate-method-call
                                                         (generate-method-call
                                                          (generate-method-call "this" () nil "getRootNode")
                                                          () nil "getFactory")
                                                         () nil "createBlock"))
                                                     nil "createInternalReference" '(("Object" "o"))))
                      ,(apply (curry #'generate-backpatch-call #T('jct "Element"))
                              (mapcar (compose #'get-member #'mm-field-name) #2#)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"synchronized(\"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getSynchronizedObject")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("')'") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getBody")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())))
                 (create-mm-constituent
                  "Throw" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a throw statement")
                  (list (create-mm-field "thrown exception" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTThrow" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "thrownException")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "thrown exception")
                               (generate-method-call "this"
                                                     '("thrownException") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression") (get-member "thrown exception")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;" (generate-method-call "aWriter" '("\"throw \"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getThrownException")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\";\\n\"") nil "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent-w/impl-file-helper
                  "Try" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-08 (木)" +author+
                  '("This class represents a try statement")
                  (list
                   (create-mm-field "try block"    #T('jct "block") :container)
                   (create-mm-field "catch block"   #T('jct "catch") :container :list)
                   (create-mm-field "finally block" #T('jct "block") :container :nullable))
                  (list
                   (create-whole-java-method
                    (() nil "JCTTry" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "try block")
                               (generate-method-call "this"
                                                     `(,(generate-method-call
                                                         (generate-method-call
                                                          (generate-method-call "this" () nil "getRootNode")
                                                          () nil "getFactory")
                                                         () nil "createBlock"))
                                                     nil "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "try block")
                                                (get-member "catch block" t)
                                                (get-member "finally block")))
                    ()))
                  "jct.kernel.impl.JCTTry.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Catch" ()
                  #T('jct "Source Code Part" '(("IJCTStatement")))
                  `(,#T('jct "Source Code Part") ,#T('jct "Element Container" '(("IJCTStatement"))))
                  ()
                  '("jct.kernel.IJCTStatement"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-08 (木)" +author+
                  '("This class represents a catch block")
                  #3=(list
                      (create-mm-field "variable" #T('jct "variable") :container)
                      (create-mm-field "body"     #T('jct "block")    :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTCatch" '(("IJCTRootNode" "aRootNode") ("IJCTVariable" "variable")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "body")
                               (generate-method-call "this"
                                                     `(,(generate-method-call
                                                         (generate-method-call
                                                          (generate-method-call "this" () nil "getRootNode")
                                                          () nil "getFactory")
                                                         () nil "createBlock")) nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "variable")
                               (generate-method-call "this"
                                                     '("variable") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(apply (curry #'generate-backpatch-call #T('jct "Statement"))
                              (mapcar (compose #'get-member #'mm-field-name) #3#)))
                    ()))
                  "jct.kernel.impl.JCTCatch.java")
                 (create-mm-constituent
                  "Array Access" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTType" "jct.kernel.IJCTArrayType")
                  "2009-01-08 (木)" +author+
                  '("This class represents an Array Access Expression")
                  #4=(list
                      (create-mm-field "array" #T('jct "expression") :container)
                      (create-mm-field "index" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTArrayAccess" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "array")
                                               ("IJCTExpression" "index")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name)
                                            (generate-method-call "this"
                                                                  `(,(generate-variable-name name)) nil
                                                                  "createInternalReference" '(("Object" "o"))))))
                                #4#)
                      ,(apply (curry #'generate-backpatch-call #T('jct "Expression"))
                              (mapcar (compose #'get-member #'mm-field-name) #4#)))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getArray")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                '("'['") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getIndex")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("']'") nil "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (format nil "((IJCTArrayType)~A)"
                                        (generate-method-call
                                         (generate-method-call "this" () nil "getArray")
                                         () nil "getTypeResult"))
                                () nil "getUnderlyingType")))
                    ())))
                 (create-mm-constituent
                  "Expression Statement" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Statement") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () () 
                  "2009-01-08 (木)" +author+
                  '("This class represents an Expression, as a statement."
                    "(A \"top-level\" expression)")
                  (list (create-mm-field "expression" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTExpressionStatement" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "expression")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "expression")
                               (generate-method-call "this"
                                                     '("expression") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression") (get-member "expression")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getExpression")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                '("\";\\n\"") nil "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent
                  "Assignment" ()
                  #T('jct "Source Code  Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () '("jct.kernel.IJCTType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a simple assignment expression")
                  #5=(list
                      (create-mm-field "variable" #T('jct "expression") :container)
                      (create-mm-field "value"    #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTAssignment" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "variable")
                                              ("IJCTExpression" "value")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name)
                                            (generate-method-call "this"
                                                                  `(,(generate-variable-name name)) nil
                                                                  "createInternalReference" '(("Object" "o"))))))
                                #5#)
                      ,(apply (curry #'generate-backpatch-call #T('jct "Expression"))
                              (mapcar (compose #'get-member #'mm-field-name) #5#)))
                    ())
                   (create-whole-java-method
                    ('(:protected) #J(nil "String") "getCompoundOperator")
                    '("return \"\";")
                    '("Returns the operator to compose with the \"=\" operator."))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getVariable")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                `(,(format nil "' ' + ~A + \"= \""
                                           (generate-method-call "this" () nil "getCompoundOperator")))
                                nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getValue")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getVariable")
                                () nil "getTypeResult")))
                    ()))))
                (mapcar (curry #'apply
                               (lambda (name operator &optional n)
                                 (let ((name (format nil "~A Assignment" name)))
                                   (create-mm-constituent
                                    name () #T('jct "Assignment") `(,#T('jct "Assignment"))
                                    () '("jct.kernel.IJCTExpression")
                                    "2009-01-08 (木)" +author+
                                    `(,(format nil "This class represents a~:[~;n~] ~A expression"
                                               n (string-downcase name)))
                                    ()
                                    (list
                                     (create-whole-java-method
                                      (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                  ("IJCTExpression" "variable")
                                                                                                  ("IJCTExpression" "value")))
                                      '("super(aRootNode, variable, value);")
                                      ())
                                     (create-whole-java-method
                                      ('(:protected) #J(nil "String") "getCompoundOperator")
                                      `(,(format nil "return \"~A\";" operator))
                                      ()))))))
                        '(("And" "&" t) ("Divide" "/") ("Left Shift" "<<") ("Minus" "-")
                          ("Multiply" "*") ("Or" "|" t) ("Plus" "+") ("Remainder" "%")
                          ("Right Shift" ">>") ("Unsigned Right Shift" ">>>" t) ("Xor" "^" t)))
                `(,(create-mm-constituent
                    "Unary Operator" ()
                    #T('jct "Source Code Part" '(("IJCTExpression")))
                    `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                    ()
                    '("jct.kernel.IJCTType")
                    "2009-01-08 (木)" +author+
                    '("This class represents an unary operator")
                    (list (create-mm-field "operand" #T('jct "expression") :container))
                    (list
                     (create-whole-java-method
                      (() nil "JCTUnaryOperator" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "operand")))
                      `("super(aRootNode);"
                        ,(format nil "~A = ~A;"
                                 (get-member "operand")
                                 (generate-method-call "this"
                                                       '("operand") nil
                                                       "createInternalReference" '(("Object" "o"))))
                        ,(generate-backpatch-call #T('jct "Expression") (get-member "operand")))
                      ())
                     (create-whole-java-method
                      ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                      `(,(format nil "return ~A;"
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getOperand")
                                  () nil "getTypeResult")))
                      ())
                     (create-whole-java-method
                      ('(:protected :abstract) #J(nil "String") "getOperator")
                      :abstract
                      '("Returns the operator")))
                    :abstract))
                (mapcar (curry #'apply
                               (lambda (name &rest get-source-code-body)
                                 (let ((name (format nil "~A Unary Operator" name)))
                                   (create-mm-constituent
                                    name () #T('jct "Unary Operator") `(,#T('jct "Unary Operator"))
                                    () '("jct.kernel.IJCTExpression" "jct.kernel.IJCTUnaryOperator")
                                    "2009-02-23 (月)" +author+
                                    `(,(format nil "This class represents a ~A operator"
                                               (string-downcase name)))
                                    ()
                                    (list
                                     (create-whole-java-method
                                      (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                  ("IJCTExpression" "operand")))
                                      '("super(aRootNode, operand);")
                                      ())
                                     (create-whole-java-method
                                      ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                                      get-source-code-body
                                      ()))
                                    :abstract :impl-only))))
                        `(("Prefixed"
                           ,(format nil "return ~A;"
                                    (generate-method-call
                                     (generate-method-call "this" () nil "getOperand")
                                     `(,(generate-method-call "aWriter"
                                                              `(,(format nil "~A + ' '"
                                                                         (generate-method-call "this" () nil "getOperator")))
                                                              nil "append" '(("String" "aString"))))
                                     nil "getSourceCode" '(("Writer" "aWriter")))))
                          ("Postfixed"
                           ,(format nil "return ~A;"
                                    (generate-method-call
                                     (generate-method-call
                                      (generate-method-call "this" () nil "getOperand")
                                      '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                     `(,(format nil "' ' + ~A"
                                                (generate-method-call "this" () nil "getOperator")))
                                     nil "append" '(("String" "str")))))))
                (mapcar (curry #'apply
                               (lambda (name operator &optional n)
                                 (create-mm-constituent
                                  name () #T('jct "Prefixed Unary Operator") `(,#T('jct "Prefixed Unary Operator"))
                                  () '("jct.kernel.IJCTExpression")
                                  "2009-01-08 (木)" +author+
                                  `(,(format nil "This class represents a~:[~;n~] ~A operator expression"
                                             n (string-downcase name)))
                                  ()
                                  (list
                                   (create-whole-java-method
                                    (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                ("IJCTExpression" "operand")))
                                    '("super(aRootNode, operand);")
                                    ())
                                   (create-whole-java-method
                                    ('(:protected) #J(nil "String") "getOperator")
                                    `(,(format nil "return \"~A\";" operator))
                                    ())))))
                        '(("Bitwise Complement" "~") ("Unary Minus" "-" t) ("Unary Plus" "+" t)
                          ("Prefix Decrement" "--") ("Prefix Increment" "++")))
                (mapcar (curry #'apply
                               (lambda (name operator)
                                 (create-mm-constituent
                                  name () #T('jct "Postfixed Unary Operator") `(,#T('jct "Postfixed Unary Operator"))
                                  () '("jct.kernel.IJCTExpression")
                                  "2009-01-08 (木)" +author+
                                  `(,(format nil "This class represents a ~A operator expression" (string-downcase name)))
                                  ()
                                  (list
                                   (create-whole-java-method
                                    (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                ("IJCTExpression" "operand")))
                                    '("super(aRootNode, operand);")
                                    ())
                                   (create-whole-java-method
                                    ('(:protected) #J(nil "String") "getOperator")
                                    `(,(format nil "return \"~A\";" operator))
                                    ())))))
                        '(("Postfix Decrement" "--") ("Postfix Increment" "++")))
                (list
                 (create-mm-constituent
                  "Logical Complement"  () #T('jct "Prefixed Unary Operator") `(,#T('jct "Prefixed Unary Operator"))
                  () '("jct.kernel.IJCTExpression" "jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes")
                  "2009-01-08 (木)" +author+
                  '("This class represents a logical complement operator expression")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTLogicalComplement" '(("IJCTRootNode" "aRootNode")
                                                     ("IJCTExpression" "operand")))
                    '("super(aRootNode, operand);")
                    ())
                   (create-whole-java-method
                    ('(:protected) #J(nil "String") "getOperator")
                    `(,(format nil "return \"!\";"))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("JCTPrimitiveTypes.BOOLEAN") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                    ())))
                 (create-mm-constituent
                  "Binary Operator" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a binary operator")
                  #6=(list
                      (create-mm-field "left operand"  #T('jct "expression") :container)
                      (create-mm-field "right operand" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTBinaryOperator" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "leftOperand")
                                                  ("IJCTExpression" "rightOperand")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name)
                                            (generate-method-call "this"
                                                                  `(,(generate-variable-name name)) nil
                                                                  "createInternalReference" '(("Object" "o"))))))
                                #6#)
                      ,(apply (curry #'generate-backpatch-call #T('jct "Expression"))
                              (mapcar (compose #'get-member #'mm-field-name) #6#)))
                    ())
                   (create-whole-java-method
                    ('(:protected :abstract) #J(nil "String") "getOperator")
                    :abstract
                    '("Returns the operator"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getLeftOperand") '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                `(,(format nil "\" \" + ~A + \" \""
                                           (generate-method-call "this" () nil "getOperator")))
                                nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getRightOperand")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ()))
                  :abstract)
                 (create-mm-constituent
                  "Logical Binary Operator" () #T('jct "Binary Operator") ()
                  () '("jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes" "jct.kernel.IJCTExpression")
                  "2009-02-28 (土)" +author+
                  '("This class represents a logical binary operator")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTLogicalBinaryOperator" '(("IJCTRootNode" "aRootNode")
                                                         ("IJCTExpression" "leftOperand")
                                                         ("IJCTExpression" "rightOperand")))
                    '("super(aRootNode, leftOperand, rightOperand);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("JCTPrimitiveTypes.BOOLEAN") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                    ()))
                  :impl-only :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Arithmetic Binary Operator" () #T('jct "Binary Operator") ()
                  ()
                  '("jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes" "jct.kernel.IJCTPrimitiveType"
                    "jct.kernel.IJCTIntersectionType" "jct.kernel.IJCTClassType" "jct.kernel.IJCTClass"
                    "jct.kernel.IJCTExpression"
                    nil "java.util.Set" "java.util.HashSet")
                  "2009-02-28 (土)" +author+
                  '("This class represents an arithmetic binary operator")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTArithmeticBinaryOperator" '(("IJCTRootNode" "aRootNode")
                                                            ("IJCTExpression" "leftOperand")
                                                            ("IJCTExpression" "rightOperand")))
                    '("super(aRootNode, leftOperand, rightOperand);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                "JCTArithmeticBinaryOperator"
                                `(,(generate-method-call
                                    (generate-method-call "this" () nil "getLeftOperand")
                                    () nil "getTypeResult")
                                   ,(generate-method-call
                                     (generate-method-call "this" () nil "getRightOperand")
                                     () nil "getTypeResult")) nil
                                "computeTypeResult"
                                '(("IJCTType" "leftOperandType")
                                  ("IJCTType" "rightOperandType")))))
                    ()))
                  "jct.kernel.impl.JCTArithmeticBinaryOperator.java"
                  :impl-only :abstract))
                (mapcar (curry #'apply
                               (lambda (name operator &optional n)
                                 (create-mm-constituent
                                  name () #T('jct "Logical Binary Operator") `(,#T('jct "Binary Operator"))
                                  () '("jct.kernel.IJCTExpression")
                                  "2009-01-08 (木)" +author+
                                  `(,(format nil "This class represents a~:[~;n~] ~A operator expression"
                                             n (string-downcase name)))
                                  ()
                                  (list
                                   (create-whole-java-method
                                    (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                ("IJCTExpression" "leftOperand")
                                                                                                ("IJCTExpression" "rightOperand")))
                                    '("super(aRootNode, leftOperand, rightOperand);")
                                    ())
                                   (create-whole-java-method
                                    ('(:protected) #J(nil "String") "getOperator")
                                    `(,(format nil "return \"~A\";" operator))
                                    ())))))
                        '(("Equal To" "==") ("Not Equal To" "!=") ("Conditional And" "&&")
                          ("Conditional Or" "||") ("Less Than" "<") ("Less Than Or Equal" "<=")
                          ("Greater Than" ">") ("Greater Than Or Equal" ">=")))
                (mapcar (curry #'apply
                               (lambda (name operator &optional n)
                                 (create-mm-constituent
                                  name () #T('jct "Arithmetic Binary Operator") `(,#T('jct "Binary Operator"))
                                  () '("jct.kernel.IJCTExpression")
                                  "2009-01-08 (木)" +author+
                                  `(,(format nil "This class represents a~:[~;n~] ~A operator expression"
                                             n (string-downcase name)))
                                  ()
                                  (list
                                   (create-whole-java-method
                                    (() nil (subseq (generate-constituent-class-name name) 1) '(("IJCTRootNode" "aRootNode")
                                                                                                ("IJCTExpression" "leftOperand")
                                                                                                ("IJCTExpression" "rightOperand")))
                                    '("super(aRootNode, leftOperand, rightOperand);")
                                    ())
                                   (create-whole-java-method
                                    ('(:protected) #J(nil "String") "getOperator")
                                    `(,(format nil "return \"~A\";" operator))
                                    ())))))
                        '(("And" "&" t) ("Divide" "/") ("Left Shift" "<<") ("Minus" "-")
                          ("Multiply" "*") ("Or" "|" t) ("Plus" "+") ("Remainder" "%")
                          ("Right Shift" ">>") ("Unsigned Right Shift" ">>>" t) ("Xor" "^" t)))
                (list
                 (create-mm-constituent-w/impl-file-helper
                  "Conditional Operator" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("java.util.Set" "java.util.HashSet"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes"
                    "jct.kernel.IJCTPrimitiveType" "jct.kernel.IJCTClass" "jct.kernel.IJCTClassType" "jct.kernel.IJCTNonPrimitiveType"
                    "jct.kernel.IJCTIntersectionType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a conditional operator expression")
                  #9=(list
                      (create-mm-field "condition"       #T('jct "expression") :container)
                      (create-mm-field "then expression" #T('jct "expression") :container)
                      (create-mm-field "else expression" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTConditionalOperator" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "condition")
                                                       ("IJCTExpression" "thenExpression") ("IJCTExpression" "elseExpression")))
                    `("super(aRootNode);"
                      ,@(mapcar (lambda (field)
                                  (with-accessors ((name mm-field-name)) field
                                    (format nil "~A = ~A;"
                                            (get-member name)
                                            (generate-method-call "this"
                                                                  `(,(generate-variable-name name)) nil
                                                                  "createInternalReference" '(("Object" "o"))))))
                                #9#)
                      ,(apply (curry #'generate-backpatch-call #T('jct "Expression"))
                              (mapcar (compose #'get-member #'mm-field-name) #9#)))
                    ()))
                  "jct.kernel.impl.JCTConditionalOperator.java")
                 (create-mm-constituent
                  "Instance Of" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.JCTPrimitiveTypes")
                  "2009-01-08 (木)" +author+
                  '("This class represents an instance of expression")
                  (list
                   (create-mm-field "operand" #T('jct "expression") :container)
                   (create-mm-field "type"    #T('jct "type")       :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTInstanceOf" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "operand")
                                              ("IJCTType" "type")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "operand")
                               (generate-method-call "this"
                                                     '("operand") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression") (get-member "operand"))
                      ,(format nil "~A;" (generate-method-call "this"
                                                               '("type") nil
                                                               "setType" '(("IJCTType" "type")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getType" () () () :impl-only)
                    `(,(format nil "return ~A;" (get-member "type")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setType" '(("IJCTType" "aType")) () () :impl-only)
                    `(,(format nil "if(JCTKind.PRIMITIVE_TYPE == ~A)"
                               (generate-method-call "aType" () nil "getKind"))
                       "    throw new IllegalArgumentException(\"instanceof can be used only with an array type or a class type\");"
                       ""
                       ,(format nil "~A = aType;" (get-member "type")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("JCTPrimitiveTypes.BOOLEAN") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call
                                (generate-method-call
                                 (generate-method-call "this" () nil "getOperand")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                '("\" instanceof \"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getType")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())))
                 (create-mm-constituent
                  "Cast" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  () () 
                  "2009-01-08 (木)" +author+
                  '("This class represents a cast expression")
                  (list
                   (create-mm-field "operand" #T('jct "expression") :container)
                   (create-mm-field "type"    #T('jct "type")))
                  (list
                   (create-whole-java-method
                    (() nil "JCTCast" '(("IJCTRootNode" "aRootNode")
                                        ("IJCTType" "type") ("IJCTExpression" "operand")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "operand")
                               (generate-method-call "this"
                                                     '("operand") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression") (get-member "operand"))
                      ,(format nil "~A;" (generate-method-call "this"
                                                               '("type") nil
                                                               "setType" '(("IJCTType" "type")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call "aWriter" '("\"(\"") nil "append" '(("String" "str"))))
                       ,(format nil "~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getType")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\")\"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call "this" () nil "getOperand")
                                 '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;" (get-member "type")))
                    ())))
                 (create-mm-constituent-w/impl-file-helper
                  "New Array" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTArrayType"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "java.util.Iterator")
                  "2009-01-08 (木)" +author+
                  '("This class represents a new array expression")
                  (list
                   (create-mm-field "element type"           #T('jct "type"))
                   (create-mm-field "dimension"              #T('jct "expression") :list :container)
                   (create-mm-field "unspecified dimensions" #T(nil "int"))
                   (create-mm-field "initializer"            #T('jct "expression") :list :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTNewArray" '(("IJCTRootNode" "aRootNode") ("IJCTType" "elementType")))
                    `("super(aRootNode);"
                      ,(format nil "~A = elementType;" (get-member "element type"))
                      ,(generate-backpatch-call #T('jct "Expression")
                                                (get-member "dimension" t)
                                                (get-member "initializer" t)))
                    ()))
                  "jct.kernel.impl.JCTNewArray.java")
                 (create-mm-constituent-w/impl-file-helper
                  "New Class" ()
                  #T('jct "Source Code Part" '(("IJCTElement")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTElement"))))
                  ()
                  '("jct.kernel.IJCTElement" "jct.kernel.IJCTType" "jct.kernel.IJCTClassMember"
                    nil "java.util.Iterator"
                    nil "java.io.Writer" "java.io.IOException")
                  "2009-01-0 8 (木)" +author+
                  '("This class represents a new class expression")
                  (list
                   (create-mm-field "class type"           #T('jct "class type") :interface-only-accessor)
                   (create-mm-field "annonymous class"     #T('jct "class")      :container :nullable :interface-only-accessor)
                   (create-mm-field "selecting expression" #T('jct "expression") :container :nullable)
                   (create-mm-field "argument"             #T('jct "expression") :container :list))
                  (list
                   (create-whole-java-method
                    (() nil "JCTNewClass" '(("IJCTRootNode" "aRootNode") ("IJCTClassType" "classType")))
                    `("super(aRootNode);"
                      ,(format nil "~A = classType;" (get-member "class type"))
                      ,(generate-backpatch-call #T('jct "Element")
                                                (get-member "selecting expression")
                                                (get-member "annonymous class")
                                                (get-member "argument" t)))
                    ()))
                  "jct.kernel.impl.JCTNewClass.java")
                 (create-mm-constituent
                  "Literal" () #T('jct "Expression") `(,#T('jct "Expression")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents a literal expression")
                  () () :abstract :intrf-only))
                (mapcar (curry #'apply
                               (lambda (type java-type)
                                 (let ((name (format nil "~A Literal" type)))
                                   (create-mm-constituent
                                    name () #T('jct "Literal") `(,#T('jct "Literal")) ()
                                    '("jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes")
                                    "2009-01-08 (木)" +author+
                                    `(,(format nil "This class represents a ~A"
                                               (string-downcase name)))
                                    (list (create-mm-field "value" #T(nil java-type)))
                                    (list
                                     (create-whole-java-method
                                      (() nil (subseq (generate-constituent-class-name name) 1)
                                       `(("IJCTRootNode" "aRootNode") (,java-type "value")))
                                      `("super(aRootNode);"
                                        ,(format nil "~A = value;" (get-member "value")))
                                      ())
                                     (create-whole-java-method
                                      ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                                      `(,(format nil "return ~A;"
                                                 (generate-method-call "aWriter"
                                                                       `(,(generate-method-call
                                                                           "String"
                                                                           `(,(get-member "value")) nil
                                                                           "valueOf" '(("Object" "o"))))
                                                                       nil "append" '(("String" "str")))))
                                      ())
                                     (create-whole-java-method
                                      ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                                      `(,(format nil "return ~A;"
                                                 (generate-method-call
                                                  (generate-method-call "this" () nil "getRootNode")
                                                  `(,(format nil "JCTPrimitiveTypes.~A" (string-upcase type))) nil
                                                  "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                                      ()))))))
                        '(("Boolean" "boolean") ("Double" "double") ("Float" "float")
                          ("Integer" "int") ("Long" "long")))
                (list
                 (create-mm-constituent
                  "Character Literal" () #T('jct "Literal") `(,#T('jct "Literal")) ()
                  '("jct.kernel.JCTPrimitiveTypes" "jct.kernel.IJCTType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a character literal")
                  (list (create-mm-field "value" #T(nil "char")))
                  (list
                   (create-whole-java-method
                    (() nil "JCTCharacterLiteral" '(("IJCTRootNode" "aRootNode") ("char" "value")))
                    `("super(aRootNode);"
                      ,(format nil "~A = value;" (get-member "value")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call "aWriter"
                                                     `(,(format nil "\"'\" + ~A + \"'\"" (get-member "value"))) ()
                                                     "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode") '("JCTPrimitiveTypes.CHARACTER") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                    ())))
                 (create-mm-constituent
                  "String Literal" () #T('jct "Expression") `(,#T('jct "Literal")) ()
                  '("jct.kernel.IJCTType" "jct.kernel.IJCTClassType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a string literal")
                  (list (create-mm-field "value" #T(nil "String")))
                  (list
                   (create-whole-java-method
                    (() nil "JCTStringLiteral" '(("IJCTRootNode" "aRootNode") ("String" "value")))
                    `("super(aRootNode);"
                      ,(format nil "~A = value;" (get-member "value")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call "aWriter"
                                                     `(,(format nil "\"\\\"\" + ~A + \"\\\"\""
                                                                (generate-method-call
                                                                 (generate-method-call
                                                                  (get-member "value")
                                                                  '("\"\\\\\"" "\"\\\\\"") nil
                                                                  "replace" '(("String" "old") ("String" "new"))) '("\"\\\"\"" "\"\\\\\\\"\"")
                                                                 nil "replace" '(("String" "old") ("String" "new"))))) ()
                                                     "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("Constants.CLASS_BINARYNAME_STRING" "IJCTClassType.class")
                                nil "getType" '(("String" "classPath") ("Class" "TypeClass")))))
                    ())))
                 (create-mm-constituent
                  "Null Literal" () #T('jct "Literal") `(,#T('jct "Literal")) ()
                  '("jct.kernel.IJCTType" "jct.kernel.JCTPrimitiveTypes")
                  "2009-01-08 (木)" +author+
                  '("This class represents a null literal")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTNullLiteral" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call "aWriter"
                                                     `(,(format nil "\"null\"")) ()
                                                     "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getRootNode")
                                '("JCTPrimitiveTypes.VOID") nil
                                "getType" '(("JCTPrimitiveTypes" "aPrimitiveTypeConstant")))))
                    ())))
                 (create-mm-constituent
                  "Parenthesis" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTType")
                  "2009-01-08 (木)" +author+
                  '("This class represents a parenthesis expression")
                  (list (create-mm-field "expression" #T('jct "expression") :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTParenthesis" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "expression")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "expression")
                               (generate-method-call "this"
                                                     '("expression") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Expression") (get-member "expression")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "~A;"
                               (generate-method-call "aWriter" '("\"(\"") nil "append" '(("String" "str"))))
                       ,(format nil "return ~A;"
                                (generate-method-call
                                 (generate-method-call
                                  (generate-method-call "this" () nil "getExpression")
                                  '("aWriter") nil "getSourceCode" '(("Writer" "aWriter")))
                                 '("\")\"") nil "append" '(("String" "str")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getExpression")
                                () nil "getTypeResult")))
                    ())))
                 (create-mm-constituent
                  "Empty Statement" () #T('jct "Statement") `(,#T('jct "Statement")) () ()
                  "2009-01-08 (木)" +author+
                  '("This class represents an empty statement")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTEmptyStatement" '(("IJCTRootNode" "aRootNode")))
                    `("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call "aWriter"
                                                     '("\";\\n\"") nil
                                                     "append" '(("String" "str")))))
                    ())))
                 (create-mm-constituent-w/impl-only-generics
                  "Selector"
                  '(("Element" "extends IJCTIdentifiable")) '(("Element" "extends IJCTIdentifiable")
                                                              ("Component" "extends IJCTElement"))
                  #T('jct "Source Code Part" '(("Component")))
                  `(,#T('jct "Expression"))
                  ()
                  '("jct.kernel.IJCTIdentifiable" "jct.kernel.IJCTElement")
                  "2008-10-27 (月)" +author+
                  '("Interface representing a selector.")
                  ()
                  (list
                   (create-whole-java-method
                    (() nil "JCTSelector" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Element") "getElement")
                    :abstract
                    '("Returns the element")
                    ()
                    "null iff the element is not resolved, ~
                     which is possible only in case of an erroneous tree")
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setElement" '(("Element" "anElement")))
                    :abstract
                    '("Modifies the resolved element")
                    () ()
                    '("UnsupportedOperationException iff erroneous selector"))
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "equals" '(("Object" "o")))
                    `("if(!(o instanceof IJCTSelector)) return false;"
                      ,(format nil "if(null == ~A && null == ~A) return true;"
                               (generate-method-call "this" () nil "getElement")
                               (generate-method-call "((IJCTSelector)o)" () nil "getElement"))
                      ,(format nil "if(null == ~A || null == ~A) return false;"
                               (generate-method-call "this" () nil "getElement")
                               (generate-method-call "((IJCTSelector)o)" () nil "getElement"))
                      ""
                      ,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "((IJCTSelector)o)" () nil "getElement")
                                `(,(generate-method-call "this" () nil "getElement")) nil
                                "equals" '(("Object" "o")))))
                    '("Returns true iff o is a selector on an equal element"))
                   (create-whole-java-method
                    ('(:public) #J(nil "int") "hashCode")
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getElement")
                                () nil "hashCode")))
                    '("Returns {@code this.getElement().hashCode()}")))
                  :abstract)
                 (create-mm-constituent-w/impl-file-helper
                  "Member Selector" '(("Member" "extends IJCTClassMember"))
                  #T('jct "Selector" '(("Member") ("IJCTExpression")))
                  `(,#T('jct "Selector" '(("Member"))) ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("java.io.Writer" "java.io.IOException" nil
                    "jct.kernel.IJCTClassMember" "jct.kernel.IJCTClass" "jct.kernel.IJCTSelector"
                    "jct.kernel.IJCTClassType" "jct.kernel.IJCTType")
                  "2008-10-06 (月)" +author+
                  '("Interface representing a member select expression ({@code selector.member})"
                    "used <strong>only</strong> (i.e. the methods <strong>must</strong>"
                    "throw an UnsupportedOperationException or an IllegalArgumentException otherwise)"
                    "when a {@link IJCTSimpleSelector} is not usable"
                    "(i.e. when a qualifying expression is required to resolve the element).")
                  #10=(list
                       (create-mm-field "Qualifying Expression" #T('jct "Expression") :container :interface-only-accessor)
                       (create-mm-field "Member Selector" #T('jct "Simple Selector" '(("Member"))) :container :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTMemberSelector" '(("IJCTRootNode" "aRootNode") ("IJCTExpression" "qualifyingExpression")
                                                  ("Member" "member")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "qualifying Expression")
                               (generate-method-call "this" '("qualifyingExpression") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(format nil "~A = ~A;"
                               (get-member "member selector")
                               (generate-method-call "this"
                                                     `(,(generate-method-call
                                                         (generate-method-call
                                                          (generate-method-call "this" () nil "getRootNode")
                                                          () nil "getFactory")
                                                         '("member") nil "createSimpleSelector" '(("Identifiable" "i"))))
                                                     nil "createInternalReference" '(("Object" "o"))))
                      ,(apply (curry #'generate-backpatch-call #T('jct "Expression"))
                              (mapcar (compose #'get-member #'mm-field-name) #10#)))
                    '("TODO : implements verification that there is no misuse of JCTMemberSelector as JCTSimpleSelector"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Member") "getElement")
                    :abstract
                    '("Returns the element")
                    ()
                    "null iff the element is not resolved, ~
                     which is possible only in case of an erroneous tree")
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setElement" '(("Member" "anElement")))
                    :abstract
                    '("Modifies the resolved element")
                    () ()
                    '("UnsupportedOperationException iff erroneous selector")))
                  "jct.kernel.impl.JCTMemberSelector.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Simple Selector" '(("Identifiable" "extends IJCTIdentifiable"))
                  #T('jct "Selector" '(("Identifiable")  ("IJCTElement /*Void*/")))
                  `(,#T('jct "Selector" '(("Identifiable"))))
                  ()
                  '("jct.kernel.IJCTClassMember" "jct.kernel.IJCTMemberSelector" "jct.kernel.IJCTSelector"
                    "jct.kernel.IJCTClass" "jct.kernel.IJCTPrimitiveType" "jct.kernel.IJCTType"
                    "jct.kernel.IJCTVariable" "jct.kernel.IJCTIdentifiable" "jct.kernel.IJCTElement"
                    nil "java.io.Writer"
                    nil "java.io.IOException")
                  "2008-10-27 (月)" +author+
                  '("Interface representing a selector"
                    "(possibly qualified identifier which can be totally resolved just by knowing the element referenced)"
                    "or a simple identifier"
                    "(if the selector is used for a class member not resolvable by itself and as the second part"
                    "of a {@link IJCTMemberSelector})."
                    "E.g.: a simple selector is an expression like:"
                    "<ul>"
                    " <li>[*.]this.foo (TODO : remove this one)</li>"
                    " <li>A reference to a static member of a (raw) class</li>"

                    " <li>A reference to a (raw) class or a package</li>"
                    " <li>A reference to a local variable</li>"
                    " <li>... <em>this list is not exhaustive</em> ...</li>"
                    "</ul>")
                  (list (create-mm-field "element" #T(nil "Identifiable") :interface-only-accessor))
                  (list
                   (create-whole-java-method
                    (() nil "JCTSimpleSelector" '(("IJCTRootNode" "aRootNode") ("Identifiable" "anIdentifiable")))
                    `("super(aRootNode);"
                      ,(format nil "~A = anIdentifiable;" (get-member "element")))
                    ()))
                  "jct.kernel.impl.JCTSimpleSelector.java")
                 (create-mm-constituent-w/impl-file-helper
                  "Erroneous Selector" ()
                  #T('jct "Source Code Part" #+(or)'(("/*IJCTExpression*/")))
                  `(,#T('jct "Selector") ,#T('jct "Member Selector") ,#T('jct "Simple Selector"))
                  ()
                  '("jct.kernel.IJCTExpression" "jct.kernel.IJCTMemberSelector"
                    "jct.kernel.IJCTType" "jct.kernel.IJCTClassMember"
                    nil "java.io.Writer" "java.io.IOException"
                    nil "java.util.Collection")
                  "2008-10-29 (水)" +author+
                  '("Interface representing a not yet or lately resolved selector."
                    "When the selector is resolved, the interface behaves exactly"
                    "like the selector it is resolved to.")
                  (list
                   (create-mm-field "identifier" #T('jct "Selector") :container :final)
                   (create-mm-field "element"    #T('jct "Identifiable") :intrf-only :implementation-only-accessor)
                   (create-mm-field "Member Selector" #T('jct "Simple Selector" '(("Member"))) :container :intrf-only :implementation-only-accessor :no-transformation))
                  (list
                   (create-whole-java-method
                    (() nil "JCTErroneousSelector" '(("IJCTRootNode" "aRootNode") ("String" "anIdentifier")))
                    `("super(aRootNode);"
                      ,(format nil "~A = ~A;"
                               (get-member "identifier")
                               (generate-method-call "this"
                                                     `("new JCTUnresolvedSimpleSelector(aRootNode, anIdentifier)") nil
                                                     "createInternalReference" '(("Object" "o"))))
                      ,(generate-backpatch-call #T('jct "Selector") (get-member "identifier")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "resolveSelector" '(("IJCTSelector" "s")))
                    `(,(format nil "if(JCTKind.ERRONEOUS_SELECTOR != ~A)"
                               (generate-method-call
                                (generate-method-call "this" () nil "getIdentifier ")
                                () nil "getKind"))
                       "    throw new IllegalStateException(\"Selector already resolved\");"
                       ,(format nil "~A;"
                                (generate-method-call (get-member "identifier")
                                                      '("s") nil
                                                      "set" '(("IJCTSelector" "s")))))
                    '("Resolves the selector.")
                    ()
                    ()
                    '("IllegalStateException iff the selector is already resolved.")))
                  "jct.kernel.impl.JCTErroneousSelector.java")
                 (create-mm-constituent
                  "Unresolved Simple Selector" '(("Identifiable" "extends IJCTIdentifiable"))
                  #T('jct "Source Code Part" '(("Identifiable")))
                  `(,#T('jct "Simple Selector" '(("Identifiable"))))
                  ()
                  '("jct.kernel.IJCTIdentifiable" "jct.kernel.IJCTSimpleSelector"
                    "jct.kernel.IJCTType")
                  "2008-10-29 (水)" +author+
                  '("Class representing an unresolved simple selector.")
                  (list (create-mm-field "identifier" #T(nil "String") :final))
                  (list
                   (create-whole-java-method
                    (() nil "JCTUnresolvedSimpleSelector" '(("IJCTRootNode" "aRootNode") ("String" "identifier")))
                    `("super(aRootNode);"
                      ,(format nil "~A = identifier;" (get-member "identifier")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Identifiable") "getElement")
                    '("return null;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "setElement" '(("Identifiable" "anIdentifiable")))
                    '("throw new UnsupportedOperationException(\"to resolve an unresolved selector, you must use the method resolveSelector(IJCTSelector).\");")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException"))
                    `(,(format nil "return ~A;"
                               (generate-method-call "aWriter"
                                                     `(,(get-member "identifier")) nil
                                                     "append" '(("String" "aWriter")))))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "JCTKind") "getKind")
                    '("return JCTKind.ERRONEOUS_SELECTOR;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult")
                    '("return null;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "toString")
                    `(,(format nil "return ~A;"
                               (generate-method-call "this" () nil "getSourceCode")))
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "R") "accept" '(("IJCTVisitor<R, P>" "v") ("P" "p")) (mapcar #'create-java-generic '("R" "P")) () :impl-only)
                    `(,(format nil "return ~A;"
                               (generate-method-call
                                (generate-method-call "this" () nil "getEnclosingElement")
                                '("v" "p") nil
                                "accept" '(("IJCTVisitor<R, P>" "v") ("P" "p")))))
                    ()))
                  :impl-only)
                 (create-mm-constituent
                  "Erroneous Expression" ()
                  #T('jct "Source Code Part" '(("IJCTExpression")))
                  `(,#T('jct "Expression") ,#T('jct "Element Container" '(("IJCTExpression"))))
                  ()
                  '("jct.kernel.IJCTType")
                  "2008-08-18 (月)" +author+
                  '("Interface representing an erroneous expression")
                  (list (create-mm-field "Expression" #T('jct "Expression") :list :container))
                  (list
                   (create-whole-java-method
                    (() nil "JCTErroneousExpression" '(("IJCTRootNode" "aRootNode")))
                    '("super(aRootNode);")
                    `())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTType") "getTypeResult" () () () :impl-only)
                    '("return null;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "Writer") "getSourceCode" '(("Writer" "aWriter")) () '("IOException") :impl-only)
                    `(,(format nil "for(final IJCTExpression expression : ~A)"
                               (generate-method-call "this" () nil "getEnclosedElements"))
                       ,(format nil "    ~A;"
                                (generate-method-call "expression"
                                                      '("aWriter") nil
                                                      "getSourceCode" '(("Writer" "aWriter"))))
                       ""
                       "return aWriter;")
                    ())))
                 (create-mm-constituent-w/impl-file-helper
                  "Path Part" () nil `(,#T(nil "Cloneable") ,#T(nil "Serializable"))
                  '("java.io.Serializable")
                  '("jct.util.IJCTContainer"
                    "java.util.Iterator" "java.util.Collection" "java.util.Arrays"
                    nil "jct.kernel.IJCTElement" "jct.kernel.IJCTElementContainer"
                    "jct.kernel.IJCTPackage")
                  "2008-10-19 (日)" +author+
                  '("Represents a Path Part")
                  (list
                   (create-mm-field "result kind" #T("jct.kernel" "JCTKind")     :final)
                   (create-mm-field "data"        #T(nil "String")      :final)
                   (create-mm-field "index"       #T(nil "Integer")     :final)
                   (create-mm-field "informative data" #T(nil "byte[]") :final)
                   (create-mm-field "next part"   #T(nil "JCTPathPart") :no-accessor :nullable)
                   (create-mm-field "last part"   #T(nil "JCTPathPart") :no-accessor :nullable))
                  (list
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPathPart") "getNextPart")
                    :abstract
                    '("Returns the next part of the path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPathPart") "getLastPart")
                    :abstract
                    '("Returns the last part of the path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "addPart" '(("IJCTPathPart" "part")))
                    :abstract
                    '("Adds a new part at the end of the path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPathPart") "clone")
                    :abstract
                    '("Returns a clone of this path part")))
                  "jct.kernel.impl.JCTPathPart.java"
                  :no-transformation :public)
                 (create-mm-constituent
                  "Path" () #T('jct "Path Part") `(,#T(nil "Cloneable") ,#T(nil "Serializable"))
                  '("java.io.Serializable") '("jct.kernel.IJCTPathPart")
                  "2008-10-20 (月)" +author+
                  '("Interface representing a path from the root node to a specific element of a model")
                  ()
                  (list
                   (create-whole-java-method
                    ('(:public) nil "JCTPath" () () () :impl-only)
                    '("super(JCTKind.ROOT_NODE, null);")
                    ())
                   (create-whole-java-method
                    (() nil "JCTPath" '(("JCTKind" "resultKind") ("Integer" "index")))
                    '("super(resultKind, index);")
                    ())
                   (create-whole-java-method
                    (() nil "JCTPath" '(("JCTKind" "resultKind") ("Integer" "index") ("String" "data")))
                    '("super(resultKind, index, data);")
                    ())
                   (create-whole-java-method
                    (() nil "JCTPath" '(("JCTKind" "resultKind") ("Integer" "index") ("String" "data") ("byte[]" "informativeData")))
                    '("super(resultKind, index, data, informativeData);")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPathPart") "getFirstPart")
                    `(,(format nil "return ~A;"
                               (generate-method-call "super" () nil
                                                     "getNextPart")))
                    '("Returns the first part of this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPathPart") "getLastPart")
                    :abstract
                    '("Returns the last part of this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "void") "addPart" '(("IJCTPathPart" "part")))
                    :abstract
                    '("Adds a new part at the end of the path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTElement") "walk" '(("IJCTRootNode" "model")))
                    :abstract
                    '("Returns the element within the model designated by this path."
                      "There is a difference between knowing the path and walking the path..."))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPath") "getPathToEnclosing")
                    `("final IJCTPath result = new JCTPath();"
                      ,(format nil "~A;"
                               (generate-method-call "result"
                                                     `(,(format nil "null == ~A ? null : ~A"
                                                                (generate-method-call "this" () nil
                                                                                      "getFirstPart")
                                                                (generate-method-call
                                                                 (format nil "((JCTPathPart)~A)"
                                                                         (generate-method-call "this" () nil
                                                                                               "getFirstPart"))
                                                                 () nil
                                                                 "getPathPartToEnclosing")))
                                                     nil "addPart" '(("IJCTPathPart" "part"))))
                      "return result;")
                    '("Returns the path to the enclosing element."))
                   (create-whole-java-method
                    ('(:public) #J(nil "JCTKind") "getResultKind")
                    '("return this == this.getLastPart() ? super.getResultKind() : this.getLastPart().getResultKind();")
                    '("Return the data of the element designated by this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "String") "getData")
                    '("return this == this.getLastPart() ? super.getData() : this.getLastPart().getData();")
                    '("Return the index of the element designated by this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "Integer") "getIndex")
                    '("return this == this.getLastPart() ? super.getIndex() : this.getLastPart().getIndex();")
                    '("Return the kind of the element designated by this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "byte[]") "getInformativeData")
                    '("return this == this.getLastPart() ? super.getInformativeData() : this.getLastPart().getInformativeData();")
                    '("Return the informative data of this path"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPath") "clone" () () () :intrf-only)
                    :abstract
                    '("Returns a clone of this path part"))
                   (create-whole-java-method
                    ('(:public) #J(nil "JCTPath") "clone" () () () :impl-only)
                    '("return (JCTPath)super.clone();")
                    '("Returns a clone of this path part"))
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "equals" '(("Object" "that")) () () :impl-only)
                    '("if(this == that)"
                      "    return true;"
                      ""
                      "if(!(that instanceof IJCTPath))"
                      "    return false;"
                      ""
                      "IJCTPathPart thisPart = this.getFirstPart();"
                      "IJCTPathPart thatPart = ((IJCTPath)that).getFirstPart();"
                      ""
                      "while(null != thisPart)"
                      "    if(!thisPart.equals(thatPart))"
                      "        return false;"
                      "    else"
                      "    {"
                      "        thisPart = thisPart.getNextPart();"
                      "        thatPart = thatPart.getNextPart();"
                      "    }"
                      ""
                      "return null == thatPart;")
                    ())
                   (create-whole-java-method
                    ('(:public) #J(nil "boolean") "isEnclosing" '(("IJCTPath" "that")))
                    '("IJCTPathPart thisPart = this.getFirstPart();"
                      "IJCTPathPart thatPart = that.getFirstPart();"
                      ""
                      "while(null != thisPart)"
                      "    if(!thisPart.equals(thatPart))"
                      "        return false;"
                      "    else"
                      "    {"
                      "        thisPart = thisPart.getNextPart();"
                      "        thatPart = thatPart.getNextPart();"
                      "    }"
                      ""
                      "return true;")
                    '("Returns whether this is designating an (indirect) element of that")))
                  :no-transformation :public)
                 (create-mm-constituent-w/impl-file-helper
                  "Path Part Builder" () () () () ()
                  "2009-03-03 (火)" +author+
                  '("This class builds a {@link JCTPathPart}.")
                  (list
                   (create-mm-field "kind"  #T("jct.kernel" "JCTKind") :no-accessor)
                   (create-mm-field-w/default "index" #T(nil "Integer") "null" :no-accessor)
                   (create-mm-field-w/default "data"  #T(nil "String")  "null" :no-accessor)
                   (create-mm-field-w/default "informative data" #T(nil "byte[]") "null" :no-accessor))
                  ()
                  "jct.kernel.impl.JCTPathPartBuilder.java"
                  :impl-only :no-transformation)
                 (create-mm-constituent-w/impl-file-helper
                  "File Offset Path" () () `(,#T('jct "Path"))
                  ()
                  '("java.io.File" "java.util.Arrays"
                    nil "jct.util.IJCTContainer"
                    nil "jct.kernel.IJCTPathPart" "jct.kernel.IJCTPath" "jct.kernel.IJCTRootNode"
                    "jct.kernel.JCTKind" "jct.kernel.IJCTCompilationUnit"
                    "jct.kernel.IJCTSourceCodePart")
                  "2009-03-10 (火)" +author+
                  '("This path implementation is used to locate a sub tree by the"
                    "file it is in and the offset position."
                    "If the offset is {@literal null}, then the path points to the Compilation Unit.")
                  (list
                   (create-mm-field "informative data" #T(nil "byte[]") :final)
                   (create-mm-field "file" #T("java.io" "File") :final)
                   (create-mm-field "offset" #T(nil "Integer") :final))
                  (list
                   (create-whole-java-method
                    ('(:public) nil "JCTFileOffsetPath" '(("File" "aFile") ("Integer" "offset")))
                    '("this(aFile, offset, null);")
                    '("Simple Constructor"))
                   (create-whole-java-method
                    ('(:public) nil "JCTFileOffsetPath" '(("File" "aFile") ("Integer" "offset") ("byte[]" "informativeData")))
                    `(,(format nil "~A = aFile;"
                               (get-member "file"))
                       ,(format nil "~A = offset;"
                                (get-member "offset"))
                       ,(format nil "~A = informativeData;"
                                (get-member "informative data")))
                    '("Complete Constructor"))
                   (create-whole-java-method
                    ('(:public) nil "JCTFileOffsetPath" '(("File" "aFile")))
                    '("this(aFile, null);")
                    '("Compilation Unit Path Constructor"))
                   (create-whole-java-method
                    ('(:public) #J(nil "IJCTPath") "getPathToEnclosing")
                    '("return null;")
                    '("Always returns null")))
                  "jct.kernel.impl.JCTFileOffsetPath.java"
                  :impl-only :no-transformation :public))))

    (defparameter *factory*
      (create-mm-factory
       "Factory" ()
       '("java.io.File")
       '("java.io.File"
         nil
         "jct.kernel.IJCTRootNode" "jct.kernel.JCTPrimitiveTypes" "jct.kernel.IJCTSelector"
         "jct.kernel.IJCTImportable" "jct.kernel.IJCTType" "jct.kernel.IJCTExpression"
         "jct.kernel.IJCTStatement" "jct.kernel.IJCTClassMember" "jct.kernel.IJCTIdentifiable"
         "jct.kernel.Constants" "jct.kernel.JCTKind" "jct.kernel.IJCTPath" "jct.kernel.IJCTPathPart")
       "2008-08-18 (月)"
       +author+
       '("This interface is a factory for creating the elements of a Javac AST."
         "All the elements of a JCT must be created by its associated factory or a compatible one."
         "The implementation of this interface must provide facilities to create and rename a JCT (IJCTRootNode)."
         "The recommended solution being to have two public static methods :"
         " {@code public static IJCTRootNode createJCT(String name)} and"
         " {@code public static IJCTRootNode renameJCT(IJCTRootNode jct, String new_name)}."
         "The rename method should respect : \"Returns the version of {@literal jct} with the new name."
         "The two JCT use compatible factories. Any modification applied to any of the both"
         "JCT is propagated to the other (as if they were using the same backstore).\"")
       '("Root Node"
         "Array Type" "Intersection Type"
         "Path" "Path Part")
       #8=(list
           (create-mm-field "original root node"   #T('jct "Root Node") :final :no-accessor)
           (create-mm-field "associated root node" #T('jct "Root Node") :final :no-accessor))
       (list
        (create-whole-java-method
         ('(:public :static) #J(nil "IJCTRootNode") "createJCT" '(("String" "name")))
         :abstract
         '("Creates a new JCT"))
        (create-whole-java-method
         ('(:public :static) #J(nil "IJCTRootNode") "renameJCT" '(("IJCTRootNode" "originalRootNode")
                                                                  ("String" "new_name")))
         '("return new JCTRenamedRootNode(originalRootNode, new_name);")
         '("Returns the version of {@literal jct} with the new name."
           "The two JCT use compatible factories. Any modification applied to any of"
           "the both JCT is propagated to the other (as if they were using the same backstore)."))
        (create-whole-java-method
         (() nil "JCTFactory" '(("IJCTRootNode" "originalRootNode")))
         '("this(originalRootNode, null);")
         ())
        (create-whole-java-method
         (() nil "JCTFactory" '(("IJCTRootNode" "originalRootNode") ("IJCTRootNode" "associatedRootNode")))
         (mapcar (lambda (field)
                   (with-accessors ((name mm-field-name)) field
                     (format nil "~A = ~A;"
                             (get-member name)
                             (generate-variable-name name))))
                 #8#)
         ())
        (create-whole-java-method
         ('(:public) #J(nil "IJCTRootNode") "getJCT")
         `(,(format nil "return ~A;" (get-member "associated root node")))
         '("Returns the JCT associated with this factory"))
        (create-whole-java-method
         ('(:public) #J(nil "boolean") "equals" '(("Object" "o")))
         `("if(!(o instanceof JCTFactory))"
           "    return false;"
           ,(format nil "return ~A == ((JCTFactory)o).originalRootNode;" (get-member "original root node")))
         '("Test factory compatibility"))
        (create-whole-java-method
         ('(:public) #J(nil "int") "hashCode")
         `(,(format nil "return ~A;"
                    (generate-method-call (get-member "original root node")
                                          () nil "hashCode")))
         '("Returns the hash code following the strict contract of {@link java.lang.Object#hashCode()}."
           "I.e. : two factories a and b has the same hashcode iff a.equals(b) returns true")))
       "jct.kernel.impl.JCTFactory.java"))

    (defparameter *visitor*
      (create-mm-visitor
       "Visitor" () ()
       "2008-08-18 (月)" +author+
       '("This interface is a defaut for a Visiting facility")
       '("Path" "Path Part")))

    (defparameter *kind-enum*
      (create-java-enum
       "JCTKind" "2008-08-17 (日)" +author+
       '("Enum containing all the kinds of elements in a Javac AST")
       "FIELD" "PARAMETER" "VARIABLE"
       "ERRONEOUS_SELECTOR" "SIMPLE_SELECTOR" "SIMPLE_IDENTIFIER"))

    (defparameter *enums* (list
                           (create-java-enum
                            "JCTModifiers"
                            "2008-08-17 (日)" +author+
                            '("Enum containing all the kinds of modifiers in a Javac AST")
                            "ABSTRACT" "FINAL" "NATIVE" "PRIVATE" "PROTECTED"
                            "PUBLIC" "STATIC" "STRICTFP" "SYNCHRONIZED"
                            "TRANSIENT" "VOLATILE")
                           (create-java-enum
                            "JCTPrimitiveTypes"
                            "2008-08-24 (日)" +author+
                            '("Enum representing primitive types")
                            "BOOLEAN" "BYTE" "CHARACTER" "DOUBLE" "FLOAT"
                            "INTEGER" "LONG" "SHORT" "VOID")))))

(when-package (#:code-generation #:meta-model-generation)
  (defparameter *method-generators* nil)

  (defgenerator accept-generator (constituent)
      ((and
        (not (member :abstract (mm-constituent-flags constituent)))
        (not (member (mm-constituent-name constituent)
                     '("Renamed Root Node"
                       "Erroneous Selector" "Unresolved Simple Selector"
                       "Non Primitive Type"
                       "Field" "Variable" "Parameter"
                       "Path" "Path Part" "Path Part Builder" "File Offset Path")
                     :test #'string-equal))))
    (create-whole-java-method
     ('(:public) #J(nil "R") "accept" '(("IJCTVisitor<R, P>" "visitor") ("P" "aP")) (mapcar #'create-java-generic '("R" "P")) () :impl-only)
     `(,(format nil "return ~A;" (generate-method-call
                                  "visitor" '("this" "aP") nil
                                  (format nil "visit~A" (generate-programmatic-name
                                                         (mm-constituent-name constituent)))
                                  '(("%%CONSTITUENT%%" "constituent") ("P" "aP")))))
     '("Calls the appropriate visit* method on the visitor")))

  (defgenerator get-kind-generator (constituent)
      ((and
        (not (member :abstract (mm-constituent-flags constituent)))
        (not (member (mm-constituent-name constituent)
                     '("Renamed Root Node"
                       "Erroneous Selector" "Simple Selector"
                       "Non Primitive Type"
                       "Field" "Variable" "Parameter"
                       "Path" "Path Part" "Path Part Builder" "File Offset Path"
                       "Unresolved Simple Selector")
                     :test #'string-equal))))
    (with-accessors ((name mm-constituent-name)) constituent
      (let ((constant (get-enum-constant #T('jct name))))
        (when constant
          (create-whole-java-method
           ('(:public) #J(nil "JCTKind") "getKind" () () () :impl-only)
           `(,(format nil "return JCTKind.~A;" constant))
           `(,(format nil "Returns the kind of this constituent (JCTKind.~A)" constant)))))))

  (defMMfun generate-enum-kind-constants (constituents)
    (remove nil
            (mapcar (lambda (constituent)
                      (when (get-kind-generator constituent)
                        (get-enum-constant #T('jct (mm-constituent-name constituent)))))
                    constituents))))

(when-package (#:code-generation #:meta-model-generation #:transformations-generation
                                 #:transformations)
  (defparameter *transformations-method-generators* nil)

  (defTgenerator transformation-accept-generator (transformation) nil
    (create-whole-java-method
     ('(:public) #J(nil "R") "accept" '(("IJCTTVisitor<R, P>" "visitor") ("P" "aP")) (mapcar #'create-java-generic '("R" "P")) () :impl-only)
     `(,(format nil "return ~A;" (generate-method-call
                                  "visitor" '("this" "aP") nil
                                  (generate-variable-name (format nil "Visit ~A" (mm-transformation-name transformation))) 
                                  '(("%%TRANSFORMATION%%" "transformation") ("P" "aP")))))
     '("Calls the appropriate visit* method on the visitor"))))

(when-package (#:code-generation #:meta-model-generation #:transformations)
  (defMMfun mm-transformation-interface-name (transformation)
    (let ((name (etypecase transformation
                  (mm-transformation (mm-transformation-name transformation))
                  (mm-factory (mm-factory-name transformation))
                  (mm-visitor (mm-visitor-name transformation))
                  (default-mm-transformation (default-mm-transformation-name transformation)))))
      (format nil "IJCTT~A" (generate-programmatic-name name))))

  (defMMfun extract-kind (type &optional with-prefix)
    (let ((kind (get-enum-constant type)))
      (when (and kind
                 (member kind (java-enum-constants *kind-enum*)
                         :test #'string=))
        (if with-prefix
            (format nil "JCTKind.~A" kind)
            kind))))

  (defMMfun get-transformation-constituent-field-class (type)
    (if (constituent-p type) *model-path-class* type))

  (defMMfun generate-get-factory (transformable)
    (generate-method-call
     (generate-method-call transformable () nil "getRootNode") () nil "getFactory"))

  (defMMfun generate-walk-to-model (transformable walker-name return-type)
    (format nil "((~A) ~A)"
            (resolve-constituent-class return-type t)
            (generate-method-call transformable
                                  `(,walker-name) nil
                                  "walk" '(("%%PATH%%" "path")))))

  (defMMfun generate-create-selector (transformable value &optional type)
    (declare (ignore type))
    (generate-method-call (generate-get-factory transformable)
                          `(,value) nil
                          "createSimpleSelector" '(("%ELEMENT%" "element"))))

  (defMMfun generate-check-constituent-field-type (type name &optional nullable)
    (when (and
           (constituent-p type)
           (let ((constituent-member (member (mm-type-name type) *constituents*
                                             :key #'mm-constituent-name
                                             :test #'string-equal)))
             (and constituent-member
                  (not (member :abstract
                               (mm-constituent-flags
                                (car constituent-member)))))))
      (let* ((get-result-kind (generate-method-call name () nil "getResultKind"))
             (kind            (extract-kind type))
             (thrower         (format nil "    throw new IllegalArgumentException(\"~A must have ~A as kind\");"
                                      name kind)))
        (when kind
          (if nullable
              (list "{"
                    (format nil "    JCTKind k = ~A;" get-result-kind)
                    (format nil "    if(JCTKind.~A != k && null != k)" kind)
                    (format nil "    ~A" thrower)
                    "}")
              (list (format nil "if(JCTKind.~A != ~A)" kind get-result-kind)
                    thrower))))))

  (defMMfun %generate-transformation-imports (transformation-name)
    (append
     '("jct.transformation.IJCTTVisitor" "jct.kernel.IJCTPath")
     (when (search "Member Selector"   transformation-name) '("jct.kernel.IJCTClassMember"))
     (when (search "Simple Selector"   transformation-name) '("jct.kernel.IJCTIdentifiable"))
     (when (search "Create"            transformation-name) '("jct.kernel.IJCTFactory"))
     (when (search "Method Invocation" transformation-name) '("jct.kernel.IJCTSelector"))
     (when (search "Delete"            transformation-name) '("ptntt.transformation.kernel.ITransformation"))))

  (defun %exists-p (name type condition-kind &key (variable "t") already-declared-variable-p not-p no-curly-braces nullable)
    (let ((transformable (ecase condition-kind
                           (:pre       "before")
                           (:invariant "current")
                           (:post      "after")))
          (predicate     (if not-p
                             "null != ~A~@[ && JCTKind.~A == ~A~]"
                             "null == ~A~@[ || JCTKind.~A != ~A~]")))

      `(,@(unless no-curly-braces
                  `(,@(when nullable
                            `(,(generate-if-null-path (get-member name) :not-p t)))
                      "{"))
          ,(format nil "    ~:[~A~;~] ~A = ~A;"
                   already-declared-variable-p
                   (resolve-constituent-class type)
                   variable
                   (generate-walk-to-model transformable (get-member name) type))
          ,@(when (and no-curly-braces nullable)
                  `(,(format nil "    ~A" (generate-if-null-path (get-member name) :not-p t))))
          ,@(mapcar (if (and no-curly-braces nullable)
                        (lambda (line)
                          (format nil"    ~A" line))
                        #'identity)
                    `(,(format nil
                               "    if(~@?)"
                               predicate
                               variable
                               (extract-kind type)
                               (generate-method-call variable () nil "getKind"))
                       "         return false;"))
          ,@(unless no-curly-braces '("}")))))

  (defMMfun unsetted-p (%name type condition-kind &key nullable &aux (name (if (= (length %name) 0) nil %name)))
    (let ((exists (format nil "new jct.predicate.Exists(new jct.transformation.util.UnsettedPath(~A, 0))"
                          (if name
                              (format nil "~A.getResultKind()"(get-member name))
                              (format nil "jct.kernel.JCTKind.~A" (extract-kind type))))))
    (list (if nullable
              (format nil "(null == ~A ? (predicate.IPredicate<TransformableRootNode>)predicate.IPredicate.TRUE : ~A)"
                      (get-member name)
                      exists)
              exists))))

  (defMMfun exists-p (name type condition-kind &key not-p nullable)
    (let ((exists (format nil "new jct.predicate.Exists(~A)" (get-member name))))
      (list (format nil "~A~@[~A~]"
                    (if nullable
                        (format nil "(null == ~A ? (predicate.IPredicate<TransformableRootNode>)predicate.IPredicate.TRUE : ~A)"
                                (get-member name)
                                exists)
                        exists)
                    (when not-p ".negation()"))))
    #+(or) (%exists-p name type condition-kind :not-p not-p :nullable nullable))

  (defMMfun equals-p (name type container-name container-type getter condition-kind &key not-p nullable)
    (let ((value (if (constituent-p type)
                     (if nullable
                         (format nil "~A == null ? jct.predicate.util.ValueAccessor.createConstantValueAccessor(~@*~A) : jct.predicate.util.ValueAccessor.createConstantValueAccessor(~@*~A)"
                                 (get-member name))
                         (format nil "jct.predicate.util.ValueAccessor.createPathValueAccessor(~A)"
                                 (get-member name)))
                     (format nil "jct.predicate.util.ValueAccessor.createConstantValueAccessor(~A)" (get-member name)))))
        (list (format nil "new jct.predicate.AttributeValue(~A, new jct.predicate.util.Getter(\"~A\"), ~A)~@[~A~]"
                   (get-member container-name)
                   (java-method-name getter)
                   value
                   (when not-p ".negation()"))))
    #+(or) `("{"
      ,@(%exists-p container-name container-type condition-kind
                   :not-p not-p :variable "container" :no-curly-braces t)
      ,@(when (constituent-p type)
              `(""
                ,@(%exists-p name type condition-kind
                             :not-p not-p :variable "value"
                             :no-curly-braces t :nullable nullable)))
      ""
      ,(format nil "    if(~A ~:[!~;=~]= ~A)"
               (generate-method-call "container" () nil getter)
               not-p
               (if (constituent-p type) "value" (get-member name)))
      "         return false;"
      "}"))
  
  (defMMfun is-in-p (name type container-name container-type getter condition-kind &key not-p)
    (list (format nil "new jct.predicate.IsInAttribute(~A, new jct.predicate.util.Getter(\"~A\"), jct.predicate.util.ValueAccessor.create~:[Constant~;Path~]ValueAccessor(~A))~@[~A~]"
                  (get-member container-name)
                  (java-method-name getter)
                  (constituent-p type)
                  (get-member name)
                  (when not-p ".negation()")))
    #+(or) (let ((transformable (ecase condition-kind
                           (:pre       "before")
                           (:invariant "current")
                           (:post      "after"))))
      `("{"
        ,@(%exists-p container-name container-type condition-kind
                     :variable "container" :no-curly-braces t)
        ,@(when (constituent-p type)
                `(""
                  ,@(%exists-p name type condition-kind
                               :not-p not-p :variable "value" :no-curly-braces t)))
        ,(format nil "    if(~:[~;!~]~A)"
                 not-p
                 (generate-method-call
                  (generate-method-call "container" () nil getter)
                  `(,(if (constituent-p type)
                         (generate-walk-to-model transformable (get-member name) type)
                         (get-member "value")))
                  nil
                  "contains" '(("%%Element%%" "Element"))))
        "         return false;"
        "}")))

  (defMMfun is-in-list-p (name type container-name container-type index-name getter condition-kind &key container-p not-p type-only-p index-or-last-only-p)
    (assert (not (and not-p type-only-p)) nil "Only one of not-p and type-only-p may be specified.")
    (list (format nil "(null == ~A ? new jct.predicate.IsInAttribute(~A, new jct.predicate.util.Getter(\"~A\"), jct.predicate.util.ValueAccessor.create~:[Constant~;Path~]ValueAccessor(~A)) : new jct.predicate.IsIn~:[Attribute~;Container~]At~5:* (~A, new jct.predicate.util.Getter(\"~A\"), jct.predicate.util.ValueAccessor.create~:[Constant~;Path~]ValueAccessor(~A), ~A))~*~@[~A~]"
                  (get-member index-name)
                  (get-member container-name)
                  (java-method-name getter)
                  (constituent-p type)
                  (get-member name)
                  (get-member index-name)
                  container-p
                  (when not-p ".negation()")))
    #+ (or) (if not-p
        (not-is-in-p name type container-name container-type getter condition-kind)
        (let* ((transformable (ecase condition-kind
                                (:pre       "before")
                                (:invariant "current")
                                (:post      "after")))
               (getter-call   (generate-method-call "container" () nil getter))
               (index         (if index-or-last-only-p "index" (get-member index-name)))
               (kind          (extract-kind type))
               (value         (if (constituent-p type)
                                  (if type-only-p
                                      (when kind
                                        (format nil "JCTKind.~A" kind))
                                      "value")
                                  (generate-walk-to-model transformable (get-member name) type))))
          `("{"
            ,@(%exists-p container-name container-type condition-kind
                         :variable "container" :no-curly-braces t)
            ,@(when (constituent-p type)
                    `(""
                      ,@(%exists-p name type condition-kind :no-curly-braces t :variable "value")))
            ""
            ,@(when index-or-last-only-p
                    `(,(format nil "    Integer index = null == ~A ? ~A - 1 : ~@*~A;"
                               (get-member index-name)
                               (generate-method-call getter-call () nil "size"))))
            ,(format nil "    if((null == ~A && ~A)"
                     index
                     (generate-method-call getter-call `(,value) nil
                                           "contains" '(("%%Element%%" "Element"))))
            ,(format nil "       || (null != ~A && ~:*~A >= ~A~:[~; && ~A != ~A~]))"
                     index
                     (generate-method-call getter-call () nil "size")
                     kind
                     value
                     (let ((get (generate-method-call getter-call `(,index) nil
                                                      "get" '(("int" "index")))))
                       (if (and (constituent-p type) type-only-p)
                           (generate-method-call get () nil "getKind")
                           get)))
            "         return false;"
            "}"))))

  (defMMfun empty-constituent-stack-p (condition-kind &key not-p type)
    nil
    #+ (or) (let* ((transformable (ecase condition-kind
                            (:pre       "before")
                            (:invariant "current")
                            (:post      "after")))
           (peek-call      (generate-method-call transformable () nil
                                                 "peekUnsettedConstituent")))
      `(,(format nil "if(null ~:[=~;!~]= ~A~@[ && JCTKind.~A == ~A~])"
                 (or not-p type)
                 peek-call
                 (when type (extract-kind type))
                 (generate-method-call peek-call () nil "getKind"))
         "    return false;"))))
